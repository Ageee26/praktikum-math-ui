[
  {
    "objectID": "modulprak/2023_ganjil/strukdat/strukdat2023.html",
    "href": "modulprak/2023_ganjil/strukdat/strukdat2023.html",
    "title": "Praktikum Struktur Data 2023 Ganjil",
    "section": "",
    "text": "Kembali ke Praktikum"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/strukdat2023.html#part-1-sebelum-uts",
    "href": "modulprak/2023_ganjil/strukdat/strukdat2023.html#part-1-sebelum-uts",
    "title": "Praktikum Struktur Data 2023 Ganjil",
    "section": "Part 1: Sebelum UTS",
    "text": "Part 1: Sebelum UTS\nPsst… UTS Struktur Data itu “jenis” soalnya sama seperti ujian Alprog: ada beberapa soal pilihan ganda serta satu/dua soal esai berupa menulis pseudocode. Kalau kalian lancar di praktikum, mungkin UTS kalian akan lancar jaya~ aamiin.\n\nModul 0: Instalasi dan konfigurasi software\nModul 1: Pengenalan 1, bahasa pemrograman C\nModul 2: Pengenalan 2, bahasa pemrograman C\nModul 3: Operasi array, algoritma searching dan sorting\nModul 4: Modul 4: Pointer, memori, CodeChef, input dan manipulasi string\n\nModul 4a (opsional): ASCII, Unicode, inttypes.h, dan manipulasi text file\nModul 4b (opsional): membuat command-line interface (CLI) dengan argv\n\nModul 5: Linked-list dengan struct dan pointer\n\nModul 5a (opsional): Visualisasi berbagai jenis linked-list dengan graphviz"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/strukdat2023.html#part-2-setelah-uts",
    "href": "modulprak/2023_ganjil/strukdat/strukdat2023.html#part-2-setelah-uts",
    "title": "Praktikum Struktur Data 2023 Ganjil",
    "section": "Part 2: Setelah UTS",
    "text": "Part 2: Setelah UTS\nSemangat terus ya! Setelah mempelajari dasar-dasar bahasa pemrograman C, hingga array dan linked list, kalian akan mempelajari struktur data yang lebih kompleks, yang sebenarnya memanfaatkan konsep array maupun linked list.\n\nModul 6: Stack (tumpukan)\n\nModul 6a (opsional): notasi prefix, infix, dan postfix\n\nModul 7: Queue (antrian)\nModul 8: Binary Tree, Binary Search Tree (BST), dan N-ary Tree\n\nModul 8a (opsional): DFS (depth-first search) dan BFS (breadth-first search) untuk tree\nModul 8b (opsional): Visualisasi sembarang binary tree dengan graphviz\nModul 8c (opsional): Visualisasi sembarang N-ary tree dengan graphviz\n\nModul 9: “Balance Tree” (AVL), Max Heap, Min Heap, dan B-Tree\n\nModul 9a (opsional): Konversi antara bentuk array (BFS) dan bentuk pointer untuk sembarang binary tree, termasuk heap\nModul 9b (opsional): Visualisasi B-Tree dengan graphviz\n\nModul 10: Pengantar database (basis data) dengan SQLite"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/strukdat2023.html#part-3-pengayaan-python",
    "href": "modulprak/2023_ganjil/strukdat/strukdat2023.html#part-3-pengayaan-python",
    "title": "Praktikum Struktur Data 2023 Ganjil",
    "section": "Part 3 (pengayaan): Python",
    "text": "Part 3 (pengayaan): Python\nMeskipun semua materi pada bagian ini bersifat pengayaan dan tidak akan dibahas di sesi praktikum, ada baiknya tetap dibaca untuk sekadar menambah wawasan. (Apabila Anda nekat berniat menggunakan bahasa pemrograman Python untuk proyek akhir Struktur Data, semoga materi pengayaan ini membantu.)\n\nModul 11: Struktur data yang khas Python\nModul 12: Pengantar OOP dengan class di Python, pengganti struct di C\nModul 13: I/O dan text file di Python\nModul 14: Visualisasi tree (pohon) dengan graphviz di Python"
  },
  {
    "objectID": "praktikum.html",
    "href": "praktikum.html",
    "title": "Praktikum",
    "section": "",
    "text": "Struktur Data\n\n\n\n\n\nPersamaan Diferensial Numerik\nSains Data"
  },
  {
    "objectID": "praktikum.html#semester-ganjil-september-desember-1",
    "href": "praktikum.html#semester-ganjil-september-desember-1",
    "title": "Praktikum",
    "section": "Semester Ganjil (September-Desember)",
    "text": "Semester Ganjil (September-Desember)\n\nStruktur Data"
  },
  {
    "objectID": "praktikum.html#semester-genap-februari-juni-1",
    "href": "praktikum.html#semester-genap-februari-juni-1",
    "title": "Praktikum",
    "section": "Semester Genap (Februari-Juni)",
    "text": "Semester Genap (Februari-Juni)\n\nSains Data"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "",
    "text": "Kembali ke Struktur Data"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#array-adalah-pointer-ke-elemen-pertama",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#array-adalah-pointer-ke-elemen-pertama",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Array adalah pointer ke elemen pertama",
    "text": "Array adalah pointer ke elemen pertama\n(write some code to assign an array to another array apparently, even though then you are actually assigning a pointer to another pointer. For example assign a string to another string, or to a char pointer. Then try to access from the second pointer, and even modify from the second pointer, then check the new value from the first pointer)"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#pointer-arithmetic-penjumlahanpengurangan-pointer",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#pointer-arithmetic-penjumlahanpengurangan-pointer",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Pointer arithmetic: penjumlahan/pengurangan pointer",
    "text": "Pointer arithmetic: penjumlahan/pengurangan pointer\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#typecasting-untuk-pointer-mengubah-tipe-data-yang-ditunjuk",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#typecasting-untuk-pointer-mengubah-tipe-data-yang-ditunjuk",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Typecasting untuk pointer: mengubah tipe data yang ditunjuk",
    "text": "Typecasting untuk pointer: mengubah tipe data yang ditunjuk\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#char-pointer-sebagai-pointer-satuan-satu-byte",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#char-pointer-sebagai-pointer-satuan-satu-byte",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "char pointer sebagai “pointer satuan” (satu byte)",
    "text": "char pointer sebagai “pointer satuan” (satu byte)\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#penggunaan-memori-sementara-malloc-dan-free",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#penggunaan-memori-sementara-malloc-dan-free",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Penggunaan memori sementara: malloc dan free",
    "text": "Penggunaan memori sementara: malloc dan free\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#variasi-malloc-calloc-realloc",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#variasi-malloc-calloc-realloc",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Variasi malloc: calloc, realloc",
    "text": "Variasi malloc: calloc, realloc\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#pengenalan-segmentation-fault",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#pengenalan-segmentation-fault",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Pengenalan segmentation fault",
    "text": "Pengenalan segmentation fault\nSegmentation fault (sering juga disebut segfault atau SIGSEGV) adalah error yang menandakan adanya masalah pada alokasi memori dinamis, seperti:\n\nmalloc?\nfreeing the nonexistent or the already freed\n\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#memset-untuk-menyeragamkan-sejumlah-byte",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#memset-untuk-menyeragamkan-sejumlah-byte",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "memset untuk “menyeragamkan” sejumlah byte",
    "text": "memset untuk “menyeragamkan” sejumlah byte\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#memcpy-untuk-menduplikasi",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#memcpy-untuk-menduplikasi",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "memcpy untuk menduplikasi",
    "text": "memcpy untuk menduplikasi\n(termasuk duplikasi struct! :D)"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#pointer-ke-struct",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#pointer-ke-struct",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Pointer ke struct",
    "text": "Pointer ke struct\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#notasi--",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#notasi--",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Notasi ->",
    "text": "Notasi ->\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#pointer-di-dalam-struct",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#pointer-di-dalam-struct",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Pointer di dalam struct",
    "text": "Pointer di dalam struct\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#automatic-memory-allocation-vs.-dynamic-memory-allocation",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#automatic-memory-allocation-vs.-dynamic-memory-allocation",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Automatic memory allocation vs. dynamic memory allocation",
    "text": "Automatic memory allocation vs. dynamic memory allocation\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#function-yang-mengembalikan-pointer",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#function-yang-mengembalikan-pointer",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Function yang mengembalikan pointer",
    "text": "Function yang mengembalikan pointer\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#function-pointer-pointer-ke-fungsi",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#function-pointer-pointer-ke-fungsi",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Function pointer: pointer ke fungsi",
    "text": "Function pointer: pointer ke fungsi\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#menerima-input-buffer-fgets-dan-sscanf",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#menerima-input-buffer-fgets-dan-sscanf",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Menerima input: buffer, fgets, dan sscanf",
    "text": "Menerima input: buffer, fgets, dan sscanf\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#menyimpan-formatted-string-snprintf",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#menyimpan-formatted-string-snprintf",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Menyimpan formatted string: snprintf",
    "text": "Menyimpan formatted string: snprintf\nblabla (the main use of snprintf is indeed to store a formatted string instead of printing it with printf, so it’s like printf but to a string instead of to the console/stdin)"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#snprintf-untuk-copy-dan-penggabungan-string",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#snprintf-untuk-copy-dan-penggabungan-string",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "snprintf untuk copy dan penggabungan string",
    "text": "snprintf untuk copy dan penggabungan string\nSelain untuk menyimpan formatted string, snprintf ternyata juga bisa digunakan untuk meng-copy sebuah string maupun menggabungkan dua string.\n(blablabla, sebenarnya juga bisa dilakukan dengan memcpy? iya kah? blablabla)"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#pengenalan-codechef",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#pengenalan-codechef",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Pengenalan CodeChef",
    "text": "Pengenalan CodeChef\nCodeChef adalah blablabla\nNanti kalian akan menggunakan CodeChef untuk proyek, mencari soal, blablabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#problem-1-number-mirror-start01",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#problem-1-number-mirror-start01",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Problem 1: “Number Mirror” (START01)",
    "text": "Problem 1: “Number Mirror” (START01)\nlink soal: https://www.codechef.com/problems/START01\nContoh penyelesaian:\n\n\nstart01.c\n\n#include <stdio.h>\n\nint main() {\n    const size_t BUFFER_SIZE = 1000;\n    char buffer[BUFFER_SIZE];\n    \n    int number;\n    \n    fgets(buffer, BUFFER_SIZE, stdin);\n    sscanf(buffer, \"%d\", &number);\n    \n    printf(\"%d\", number);\n    \n    return 0;\n}"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#problem-2-add-two-numbers-flow001",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04.html#problem-2-add-two-numbers-flow001",
    "title": "Modul 4: Pointer, memori, CodeChef, input dan manipulasi string",
    "section": "Problem 2: “Add Two Numbers” (FLOW001)",
    "text": "Problem 2: “Add Two Numbers” (FLOW001)\nlink: https://www.codechef.com/problems/FLOW001\nContoh penyelesaian:\n```{.c filename=“flow001.c”, code-line-numbers=“true”} #include <stdio.h>\nint main() { const size_t BUFFER_SIZE = 1000; char buffer[BUFFER_SIZE];\nint T;\nfgets(buffer, BUFFER_SIZE, stdin);\nsscanf(buffer, \"%d\", &T);\n\nint a, b, result;\nfor (int i = 0; i < T; i++) {\n    fgets(buffer, BUFFER_SIZE, stdin);\n    sscanf(buffer, \"%d %d\", &a, &b);\n    result = a + b;\n    printf(\"%d\\n\", result);\n}\n\nreturn 0;\n} ```"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul02.html",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul02.html",
    "title": "Modul 2 Struktur Data: Pengenalan 2, bahasa pemrograman C",
    "section": "",
    "text": "Kembali ke Struktur Data\n\nOutline\n\nArray (larik)\nchar (huruf), putchar, dan getchar\nstring, puts, fgets, strlen, dan strcmp/strncmp\nTentang function (fungsi)\nMenampilkan semua elemen pada array\nstruct (“struktur” atau struktur data)\nMendalami proses kompilasi program\nPreprocessor directive dan header file (.h)\nBuild system make: kompilasi otomatis dengan Makefile\nReferensi tambahan: CMake\nHeader file untuk Modul 2 Praktikum: prakmodul2.h dan prakmodul2.c\n\n\n\nArray (larik)\nblabla\n(jangan lupa ukuran array dengan sizeof)\n\n\nchar (huruf), putchar, dan getchar\nblabla\n\n\nstring, puts, fgets, strlen, dan strcmp/strncmp\nblabla\n\n\nTentang function (fungsi)\nblabla\n\n\nMenampilkan semua elemen pada array\nUntuk menampilkan semua elemen yang ada di dalam suatu array, kita perlu melakukan iterasi pada tiap elemen di array, lalu menggunakan printf pada tiap iterasi. Agar mengetahui batasan for loop, kita perlu mengetahui panjang array. Kita bisa membuat fungsi yang mem-print satu per satu elemen suatu array sampai panjang array tersebut.\nvoid array_int_print(int arr[], int arr_length) {\n    for (int i = 0; i < arr_length; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}\n\n\nstruct (“struktur” atau struktur data)\nblabla\n\n\nMendalami proses kompilasi program\nblabla\n\n\nPreprocessor directive dan header file (.h)\nblabla\n\n\nBuild system make: kompilasi otomatis dengan Makefile\nblabla\n\n\nReferensi tambahan: CMake\nKita telah belajar cara membuat Makefile secara manual dan menggunakannya. Sejauh ini, Makefile yang kita buat melibatkan beberapa variabel yang perlu kita setting secara manual. Untuk program dan proyek skala kecil seperti di mata kuliah Struktur Data, itu tidak masalah.\nSebenarnya, sudah ada software untuk membuat Makefile secara otomatis, yaitu CMake. Bahkan, CMake bisa menghasilkan Makefile untuk berbagai sistem operasi yang memiliki berbagai macam ketergantungan yang berbeda-beda. Namun, cara penggunaannya bisa agak sulit, sehingga tidak kami ajarkan di praktikum untuk menghemat waktu. Anda bisa membaca lebih lanjut tentang CMake di internet, seperti di link berikut:\nhttps://earthly.dev/blog/cmake-vs-make-diff/\n\n\nHeader file untuk Modul 2 Praktikum: prakmodul2.h dan prakmodul2.c\nDi Modul 2 Praktikum Struktur Data ini, kita telah mendefinisikan fungsi, seperti array_int_print. Tentunya, fungsi ini bisa saja diperlukan untuk praktikum ke depannya ataupun untuk proyek lainnya. Oleh karena itu, berikut ini tercantum kode header file yang memiliki fungsi penting seperti array_int_print, yang bisa kalian libatkan ke dalam apapun proyek yang kalian buat dengan bahasa pemrograman C, melalui Makefile, seperti yang sudah kita praktekkan kali ini. Untuk modul-modul praktikum ke depannya, kode untuk header file juga akan tercantum di bagian paling bawah seperti di sini.\n\nprakmodul2.hprakmodul2.c\n\n\n#ifndef PRAKMODUL2_H\n#define PRAKMODUL2_H\n\nvoid array_int_print(int arr[], int arr_length);\n\n#endif\n\n\n#include <stdio.h>\n#include \"prakmodul2.h\"\n\nvoid array_int_print(int arr[], int arr_length) {\n    for (int i = 0; i < arr_length; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html",
    "title": "Modul 3 Struktur Data: Operasi array, algoritma searching dan sorting",
    "section": "",
    "text": "Kembali ke Struktur Data"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#linear-search",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#linear-search",
    "title": "Modul 3 Struktur Data: Operasi array, algoritma searching dan sorting",
    "section": "Linear search",
    "text": "Linear search\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#binary-search",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#binary-search",
    "title": "Modul 3 Struktur Data: Operasi array, algoritma searching dan sorting",
    "section": "Binary search",
    "text": "Binary search\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#bubble-sort",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#bubble-sort",
    "title": "Modul 3 Struktur Data: Operasi array, algoritma searching dan sorting",
    "section": "Bubble sort",
    "text": "Bubble sort\nBubble sort adalah suatu algoritma sorting yang dilakukan berkali-kali sampai array sudah terurut dengan benar, di mana tiap elemen diperiksa dengan sebelahnya, kemudian ditukar apabila urutan di antara keduanya belum benar. Ketika melakukan bubble sort, kita bisa yakin bahwa array sudah terurut apabila sudah tidak terjadi pertukaran sama sekali ketika memeriksa kembali semua elemen array dari awal sampai akhir.\nDengan konsep di atas, kita bisa membuat fungsi bubble sort seperti berikut.\nvoid array_int_bubblesort1_asc(int arr[], size_t arr_length) {\n    bool terjadi_pertukaran = true; // asumsi array belum terurut\n\n    // ulangi selama masih terjadi pertukaran\n    while (terjadi_pertukaran) {\n        terjadi_pertukaran = false;\n        // asumsi tidak akan terjadi pertukaran,\n        // akan diubah menjadi true ketika terjadi pertukaran\n\n        // for loop untuk melihat tiap elemen dari awal sampai akhir\n        for (int i = 0; i < (int)arr_length-1; i++) {\n            if (arr[i] > arr[i+1]) { // apabila ada yang harus ditukar\n                // maka tukarlah\n                int temp = arr[i];\n                arr[i] = arr[i+1];\n                arr[i+1] = temp;\n\n                // terjadi pertukaran\n                terjadi_pertukaran = true;\n            }\n        }\n    }\n}\nPerhatikan bahwa fungsi di atas memiliki return type berupa void, yang artinya tidak ada yang di-return. Bahkan, elemen array langsung ditukar menggunakan array yang dimasukkan ke dalam fungsi. Di bahasa pemrograman C, ada sesuatu yang spesial tentang array sehingga array bisa langsung dimanipulasi dari dalam fungsi. Hal ini akan dibahas di pertemuan selanjutnya bersama pointer.\nIntinya, terima saja dulu, bahwa ketika array masuk sebagai input fungsi, maka apapun yang dilakukan pada array tersebut di dalam fungsinya akan benar-benar mengubah array yang sesungguhnya.\nDengan demikian, penggunaan fungsi di atas bisa seperti berikut:\n\n\nbubblesort1.c\n\n#include <stdio.h>\n#include \"prakmodul2.h\"\n\n// deklarasi fungsi\nvoid array_int_bubblesort1_asc(int arr[], size_t arr_length);\n// fungsi ini akan didefinisikan setelah definisi fungsi main\n\nint main () {\n    int array1[] = {10, 3, 8, 4, 5, 7, 9, 6};\n    size_t panjang1 = sizeof(array1)/sizeof(array1[0]);\n\n    printf(\"Sebelum bubble sort: \");\n    array_int_print(array1, panjang1);\n    printf(\"\\n\");\n\n    printf(\"Setelah bubble sort: \");\n    array_int_bubblesort1_asc(array1, panjang1);\n    array_int_print(array1, panjang1);\n\n    return 0;\n}\n\n// definisi fungsi\nvoid array_int_bubblesort1_asc(int arr[], size_t arr_length) {\n    bool terjadi_pertukaran = true; // asumsi array belum terurut\n\n    // ulangi selama masih terjadi pertukaran\n    while (terjadi_pertukaran) {\n        terjadi_pertukaran = false;\n        // asumsi tidak akan terjadi pertukaran,\n        // akan diubah menjadi true ketika terjadi pertukaran\n\n        // for loop untuk melihat tiap elemen dari awal sampai akhir\n        for (int i = 0; i < (int)arr_length-1; i++) {\n            if (arr[i] > arr[i+1]) { // apabila ada yang harus ditukar\n                // maka tukarlah\n                int temp = arr[i];\n                arr[i] = arr[i+1];\n                arr[i+1] = temp;\n\n                // terjadi pertukaran\n                terjadi_pertukaran = true;\n            }\n        }\n    }\n}\n\nPerhatikan bahwa… (basically lead to optimizing bubble sort, provide two other variations as per the wikipedia page)"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#selection-sort",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#selection-sort",
    "title": "Modul 3 Struktur Data: Operasi array, algoritma searching dan sorting",
    "section": "Selection sort",
    "text": "Selection sort\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#insertion-sort",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#insertion-sort",
    "title": "Modul 3 Struktur Data: Operasi array, algoritma searching dan sorting",
    "section": "Insertion sort",
    "text": "Insertion sort\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#merge-sort",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#merge-sort",
    "title": "Modul 3 Struktur Data: Operasi array, algoritma searching dan sorting",
    "section": "Merge sort",
    "text": "Merge sort\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#quicksort-versi-hoare",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#quicksort-versi-hoare",
    "title": "Modul 3 Struktur Data: Operasi array, algoritma searching dan sorting",
    "section": "Quicksort versi Hoare",
    "text": "Quicksort versi Hoare\nTony Hoare menerbitkan paper tentang quicksort, yaitu algoritma sorting yang ia buat, pada tahun 1961, yang bisa dilihat di tautan (link) berikut.\n\nhttps://www.cs.ox.ac.uk/files/6226/H2006%20-%20Historic%20Quicksort.pdf\n(link alternatif) http://rabbit.eng.miami.edu/class/een511/quicksort.pdf\n\nSejak itu, sudah ada beberapa variasi quicksort, seperti versi Lomuto. Namun, inti sari dari algoritma quicksort secara umum adalah sebagai berikut:\n\nApabila array ternyata kosong atau hanya terdiri dari satu elemen, diamkan saja, tidak ada yang perlu disortir. Apabila terdiri dari 2+ elemen, lanjut ke langkah selanjutnya.\nPilih salah satu elemen pada array (boleh yang mana saja) sebagai elemen “pivot”. Jangan sampai lupa, baik nilainya maupun indeksnya/letaknya.\nLakukan “partisi”, yaitu pertukaran elemen seperlunya (bahkan elemen pivot boleh ikut ditukar dan dipindahkan) sedemikian sehingga, pada akhirnya,\n\nsemua elemen di sebelah kiri pivot pasti lebih kecil (atau sama dengan) pivot; dan\nsemua elemen di sebelah kanan pivot pasti lebih besar (atau sama dengan) pivot.\n\n“Partisi” yang dimaksud adalah bahwa, setelah proses partisi selesai, array seakan-akan telah terbagi (terpartisi) menjadi tiga bagian, yaitu (dari kiri ke kanan):\n\n“partisi kiri/bawah”, yaitu bagian di sebelah kiri pivot, terdiri dari semua elemen yang lebih kecil (atau sama dengan) pivot;\npivot itu sendiri; dan\n“partisi kanan/atas”, yaitu bagian di sebelah kanan pivot, terdiri dari semua elemen yang lebih besar (atau sama dengan) pivot.\n\nKemudian, memperhatikan letak pivot, lakukan quicksort pada semua elemen di sebelah kiri pivot (yaitu pada partisi kiri), dan lakukan quicksort pada semua elemen di sebelah kanan pivot (yaitu pada partisi kanan).\n\n(Menariknya, Tony Hoare tidak menggunakan istilah “pivot”. Beliau menggunakan istilah “bound” untuk “nilai pivot”, dan menuliskan “the element from which the bound was chosen” ketika bermaksud mengatakan “elemen pivot”.)\nTerlihat dari langkah terakhir, algoritma quicksort bersifat rekursif. Bagian tersulit dari quicksort adalah pada tahapan partisi. Tahapan inilah yang cara melakukannya bisa bervariasi (tidak seperti algoritma sorting lainnya yang cenderung begitu-begitu saja). Tidak hanya itu, bahkan cara memilih pivot bisa saja dengan memilih elemen pertama, elemen tengah, elemen terakhir, atau median dari ketiganya (“median-of-three”), ataupun variasi lainnya.\nDari paper aslinya, penjelasan Tony Hoare tentang cara melakukan partisi (menurut beliau) bisa dirangkum sebagai berikut:\n\nBuat dua “panah”, yaitu “panah bawah” (i) dan “panah atas” (j), di mana panah bawah menunjuk pada elemen pertama dan panah atas menunjuk pada elemen terakhir. (Secara pemrograman, simpan indeksnya saja.) Bisa dibayangkan, ada asumsi array sudah dipartisi, di mana panah bawah akan memastikan partisi kiri sudah benar, dan panah atas akan memastikan partisi kanan sudah benar.\nwhile loop: selama elemen yang ditunjuk oleh panah bawah itu masih lebih kecil atau sama dengan nilai pivot, (dan selama panah bawah belum melewati panah atas,) geser panah bawah satu langkah ke kanan. (Artinya, selama partisi kiri sudah benar, lanjut memeriksa elemen berikutnya yaitu ke kanan. Berhenti ketika ada yang lebih besar dari pivot, sehingga harusnya ada di partisi kanan; menunggu ditukar.)\nwhile loop: selama elemen yang ditunjuk oleh panah atas itu masih lebih besar atau sama dengan nilai pivot, (dan selama panah bawah belum melewati panah atas,) geser panah atas satu langkah ke kiri. (Artinya, selama partisi kanan sudah benar, lanjut memeriksa elemen berikutnya yaitu ke kiri. Berhenti ketika ada yang lebih kecil dari pivot, sehingga harusnya ada di partisi kiri; menunggu ditukar.)\nSampai sini, apabila panah bawah masih belum melewati panah atas, maka ada dua elemen yang menunggu ditukar, yaitu yang ditunjuk oleh panah bawah dan yang ditunjuk oleh panah atas. Maka tukarlah, lalu kembali ke langkah kedua.\nSampai sini, sudah tidak lagi kembali ke langkah kedua, sehingga panah bawah sudah melewati panah atas; sekarang panah atas ada di sebelah kiri dari panah bawah. Bayangkan, di antara dua panah tersebut, ada semacam garis pembagi: dari elemen pertama sampai panah atas adalah “partisi kiri”, sedangkan dari panah bawah sampai elemen terakhir adalah “partisi kanan”.\n\nApabila pivot jatuh pada partisi kiri (indeks pivot <= panah atas), tukarkan elemen pada panah atas dengan elemen pivot. (Lalu, bayangkan bahwa partisi kiri sedikit diperkecil karena elemen pivot tidak boleh masuk ke kedua partisi.)\nSedangkan, apabila pivot berada pada partisi kanan (indeks pivot >= panah bawah), tukarkan elemen pada panah bawah dengan elemen pivot. (Lalu, bayangkan bahwa partisi kanan sedikit diperkecil karena elemen pivot tidak boleh masuk ke kedua partisi.)\n\n(Dengan demikian, letak pivot sekarang berada di perbatasan antara partisi kiri dan partisi kanan.)\nKembalikan indeks letak pivot.\n\nCatatan: apabila, pada langkah keempat, ternyata antara panah bawah maupun panah atas sedang menunjuk ke elemen pivot, maka elemen pivot terlibat dalam pertukaran; jangan lupa mengubah indeks pivot menjadi posisi barunya setelah ditukar.\n(Sebenarnya, Tony Hoare menggunakan istilah lower pointer dan upper pointer untuk kedua panah. Namun, konsep pointer sebenarnya tidak diperlukan sama sekali, dan konsep yang beliau maksud juga bisa digambarkan dengan panah, yang letaknya berupa indeks array.)\nSebelum membuat kode untuk algoritma quicksort versi Tony Hoare, kita perlu membuat fungsi yang akan menentukan elemen pivot berdasarkan array, misalnya memanfaatkan indeks pertama dan/atau indeks terakhir. (Fungsi ini akan bisa diubah-ubah apabila ingin bereksperimen dengan metode pemilihan pivot.)\nint ChoosePivot_idx(int arr[], int low, int high) {\n    int choice_idx = low; // pilih elemen pertama saja lah~\n    return choice_idx;\n}\nBerikut ini, kita akan mencoba menerapkan quicksort versi Tony Hoare, sebelum nantinya mencoba dengan algoritma partisi menurut Lomuto.\nvoid HoarePartition(int arr[], int low, int high) {\n    return;\n}"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#quicksort-versi-lomuto",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul03.html#quicksort-versi-lomuto",
    "title": "Modul 3 Struktur Data: Operasi array, algoritma searching dan sorting",
    "section": "Quicksort versi Lomuto",
    "text": "Quicksort versi Lomuto\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "",
    "text": "Kembali ke Struktur Data\nSelamat datang di praktikum Struktur Data!"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#output-selain-string-format-specifier",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#output-selain-string-format-specifier",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "Output selain string: format specifier",
    "text": "Output selain string: format specifier\nTentu saja, kemampuan C bukan sekedar mengeluarkan output berupa string. Program C juga bisa mengeluarkan output berupa integer (bilangan bulat), dengan syntax (sintaks; cara penulisan) seperti berikut:\n\n\nhelloint.c\n\n#include <stdio.h>\n\nint main() {\n    printf(\"%d\", 98);\n    return 0;\n}\n\nPada contoh program helloint.c di atas, output yang dikeluarkan adalah suatu bilangan bulat yaitu 98. Adanya tulisan \"%d\" adalah bentuk string formatting, di mana huruf “d” melambangkan tipe data bilangan bulat dalam bentuk desimal (base 10). Artinya, bilangan bulat di sampingnya itu disisipkan ke dalam string, sehingga kita bisa melihat output berupa bilangan bulat tersebut.\nLambang seperti %d disebut format specifier.\nFun fact: huruf “f” dalam istilah printf artinya “formatted”.\nTentu saja, kita dapat menuliskan apapun sebelum dan sesudah format specifier %d tersebut:\n\n\nhelloint2.c\n\n#include <stdio.h>\n\nint main() {\n    printf(\"Anda memasukkan %d yaitu bilangan bulat\", 98);\n    return 0;\n}\n\nBilangan bulat tersebut akan disisipkan di dalam string, sesuai dengan posisi %d.\nBilangan bulat juga bisa negatif:\n\n\nhelloint3.c\n\n#include <stdio.h>\n\nint main() {\n    printf(\"Anda memasukkan %d yaitu bilangan bulat\", -5);\n    return 0;\n}\n\nSelain “d” yang berarti bilangan bulat, huruf “f” artinya float, atau floating-point number. Singkat cerita, tipe data float adalah bilangan yang bisa berupa desimal, sehingga tidak terbatas bilangan bulat saja. (Kalau penasaran detilnya dan mengapa namanya demikian, kalian bisa review kembali materi pertemuan pertama kuliah Metode Numerik, tentang floating-point arithmetic.) Kita dapat membuat program seperti berikut:\n\n\nhellofloat.c\n\n#include <stdio.h>\n\nint main() {\n    printf(\"%f\", 3.14);\n    return 0;\n}\n\ndan kita akan menerima output berupa float yang kita tuliskan, yaitu 3.14. Tentu saja, tipe data float juga bisa negatif:\n\n\nhellofloat2.c\n\n#include <stdio.h>\n\nint main() {\n    printf(\"%f\", -0.618);\n    return 0;\n}\n\nKita bisa menyisipkan lebih dari satu bilangan:\n\n\nhellonum.c\n\n#include <stdio.h>\n\nint main() {\n    printf(\"%d %f %f\", 98, -0.618, 3.14);\n    return 0;\n}\n\nPerhatikan bahwa tiap bilangan di dalam string di atas dipisah dengan spasi. Sehingga, pada output, tiap bilangan akan dipisah dengan spasi.\nPerhatikan apa yang terjadi kalau kita memisahkan proses print menjadi satu bilangan saja per printf:\n\n\nhellonum2.c\n\n#include <stdio.h>\n\nint main() {\n    printf(\"%d\", 98);\n    printf(\"%f\", -0.618);\n    printf(\"%f\", 3.14);\n\n    return 0;\n}\n\n(Catatan: return 0; tidak harus selalu menempel dengan baris-baris sebelumnya. Bahkan, tidak ada baris yang harus saling menempel.)\nTernyata, semua output tetap di baris yang sama. Bahkan, tidak ada spasi yang memisahkan (karena tidak kita tulis). Ada kode khusus untuk membuat baris baru (new line), yaitu \\n. Perhatikan:\n\n\nhellonum3.c\n\n#include <stdio.h>\n\nint main() {\n    printf(\"%d\\n\", 98);\n    printf(\"%f\\n\", -0.618);\n    printf(\"%f\", 3.14);\n\n    return 0;\n}\n\nTiap kali ada \\n, dikeluarkan “output” berupa baris baru. Sehingga, output selanjutnya akan mulai dari baris baru tersebut. Kalau mau, kita bisa memisahkan pembuatan baris baru, seperti berikut:\n\n\nhellonum4.c\n\n#include <stdio.h>\n\nint main() {\n  printf(\"%d\", 98);\n  printf(\"\\n\");\n  printf(\"%f\", -0.618);\n  printf(\"\\n\");\n  printf(\"%f\", 3.14);\n\n  return 0;\n}"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#escape-sequence-untuk-string",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#escape-sequence-untuk-string",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "Escape sequence untuk string",
    "text": "Escape sequence untuk string\n\\n adalah contoh escape sequence, yaitu kode khusus untuk mem-print hal-hal yang tidak bisa kita ketik begitu saja. Contoh lain, bagaimana caranya kita mem-print output \"Hello world\" dengan tanda kutip? Masalahnya, tanda kutip sudah digunakan untuk menandakan awal dan akhir string, sehingga tidak bisa kita ketik begitu saja. Solusinya, kita gunakan escape sequence lain yaitu \\\" seperti berikut.\n\n\nescapequote.c\n\n#include <stdio.h>\n\nint main() {\n    printf(\"Kita coba print \\\"Hello world!\\\" apakah berhasil?\");\n    return 0;\n}\n\nPerhatikan kalimat berikut.\n\nSejauh ini, kita sudah mempelajari \\n dan \\” yaitu dua contoh escape sequence.\n\nBagaimana caranya kita mem-print keseluruhan kalimat tersebut di C, misalnya tanpa membuat baris baru? Masalanhya ada pada tanda backslash \\ yang memang sudah menjadi ciri khas untuk escape sequence. Kita ingin menampilkan escape sequence tersebut tanpa mengaktifkannya. Solusinya, bahkan tanda backslash itu sendiri bisa “dinonaktifkan” dengan menuliskan \\\\ seperti berikut:\n\n\nescapebackslash.c\n\n#include <stdio.h>\n\nint main() {\n    printf(\"Sejauh ini, kita sudah mempelajari \\\\n dan \\\\\\\" yaitu dua contoh escape sequence.\");\n    return 0;\n}\n\nPerhatikan bahwa, untuk \\n, hanya diperlukan satu backslash agar bisa ditampilkan. Sedangkan, diperlukan dua backslash untuk menampilkan \\\". Seandainya hanya digunakan satu backslash, yaitu mengetik \\\\\", maka output nya akan menjadi seperti berikut,\n\nSejauh ini, kita sudah mempelajari \\n dan \\\n\nkarena, melihat \\\\\", tanda kutip tersebut dianggap sebagai penutup string. Anggapan tersebut bisa kita nonaktifkan menggunakan backslash juga (yang ditambahkan tepat sebelum tanda kutip tersebut), sehingga kita ketik \\\\\\\".\nAda banyak escape sequence lainnya yang tidak dibahas di sini (bisa dicari di Google)."
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#comment",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#comment",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "Comment",
    "text": "Comment\nDalam pemrograman, comment adalah semacam catatan yang tidak diperhatikan oleh komputer sama sekali; gunanya hanya untuk memudahkan manusia memahami kode. Pada bahasa pemrograman C, ada dua jenis comment, yaitu:\n\nsingle-line (satu baris), yang diawali dengan // dan bisa dituliskan di mana saja. Penggunaan // pada C sama persis dengan penggunaan # pada Python.\nmulti-line (banyak baris), yang diawali dengan /* dan diakhiri dengan */, dan juga bisa ditempatkan di mana saja. Penggunaan ini bahkan lebih fleksibel daripada \"\"\" di Python.\n\nPerhatikan program berikut.\n\n\nhellocomment.c\n\n#include <stdio.h>\n\n// comment tidak harus di dalam main()\n\nint main() {\n    // ini comment\n    printf(\"Hello world!\\n\");\n    /* ini\n    juga\n    comment */\n\n    /*\n    bisa\n    seperti\n    ini\n    */\n\n    printf(\"%d adalah bilangan bulat.\\n\", 22);\n    printf(/* penyusup */ \"%f\\n\", /* tes */ -273.15);\n}\n\nSesuai kegunaannya, semua comment diabaikan oleh C; kode tetap diijalankan seolah-olah tidak ada comment sama sekali."
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#variabel-dan-tipe-data-bilangan",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#variabel-dan-tipe-data-bilangan",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "Variabel dan tipe data bilangan",
    "text": "Variabel dan tipe data bilangan\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#operasi-dasar",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#operasi-dasar",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "Operasi dasar",
    "text": "Operasi dasar\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#konstanta",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#konstanta",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "Konstanta",
    "text": "Konstanta\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#ukuran-data-dengan-sizeof-dan-size_t",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#ukuran-data-dengan-sizeof-dan-size_t",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "Ukuran data dengan sizeof dan size_t",
    "text": "Ukuran data dengan sizeof dan size_t\nnitip https://stackoverflow.com/questions/19732319/difference-between-size-t-and-unsigned-int\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#format-specifier",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#format-specifier",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "Format specifier",
    "text": "Format specifier\nSebelumnya, kita sudah menggunakan beberapa format specifier seperti %d, %f, dan %lf. Format specifier lainnya bisa dilihat di link berikut:\nhttps://www.tutorialspoint.com/format-specifiers-in-c"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#if-else",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#if-else",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "if, else",
    "text": "if, else\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#tipe-data-boolean",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#tipe-data-boolean",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "Tipe data boolean",
    "text": "Tipe data boolean\n\nPengartian data sebagai nilai kebenaran di bahasa pemrograman C\n\n\nData\nDiartikan sebagai\n\n\n\n\n0 (nol), NULL, \\0\nFalse (salah)\n\n\napapun data lainnya\nTrue (benar)\n\n\n\nAda juga istilah falsy value dan truthy value untuk mengkategorikan jenis data yang diartikan sebagai False dan yang diartikan sebagai True. Dalam hal ini, nol, NULL, dan \\0 adalah falsy values, dan semua data lainnya adalah truthy values.\n(Kita akan berjumpa dengan NULL dan \\0 di sesi praktikum yang akan datang.)\nPerlu diingat, klasifikasi antara data yang termasuk falsy values dan yang termasuk truthy values bisa berbeda-beda antara beberapa bahasa pemrograman. Oleh karena itu, ada semacam “standar” untuk data boolean di bahasa pemrgoraman C, di mana didefinisikan variabel false=0 dan true=1. Untuk menggunakan kedua variabel ini, kita perlu #include <stdbool.h>, yang juga akan memperkenalkan tipe data baru, yaitu bool, sebagai tipe data boolean. (Sudah menjadi standar untuk melakukan include tersebut daripada mendefinisikan kedua variabel secara manual.)\n(kode include stdbool)"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#switch-case-dan-enum",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#switch-case-dan-enum",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "switch case dan enum",
    "text": "switch case dan enum\nblabla\n(contoh switch case)\nSayangnya, bagian case hanya bisa menggunakan bilangan bulat dan huruf. Untungnya, bahasa pemrograman C memiliki fitur enum (dibaca “inam”) atau enumeration yang bisa digunakan untuk membuat tipe data baru yang sebenarnya merupakan bilangan bulat tetapi bisa dituliskan sebagai semacam variabel. Dengan demikian, kita seolah-olah bisa menggunakan switch case dengan variabel yang tidak terlihat seperti bilangan bulat, atau setidaknya kita bisa mendefinisikan beberapa bilangan bulat sekaligus yang merupakan bilangan bulat untuk digunakan dengan switch case.\nContohnya, kita bisa membuat enum untuk tipe data baru bernama “Hari” seperti berikut.\nenum Hari = {\n    Senin, Selasa, Rabu, Kamis, Jumat, Sabtu, Minggu\n}\nKemudian, enum bisa digunakan dengan switch case, karena Senin, Selasa, Rabu, Kamis, Jumat, Sabtu, dan Minggu sudah menjadi semacam variabel konstanta yang mengandung bilangan bulat yang berbeda-beda (dan berurut).\n\n\nenumhari.c\n\n#include <stdio.h>\n\nenum Hari = {\n    Senin, Selasa, Rabu, Kamis, Jumat, Sabtu, Minggu\n}\n\nint main() {\n    enum Hari sekarang = Rabu;\n\n    switch (sekarang) {\n        case Senin:\n        case Rabu:\n        case Kamis:\n            puts(\"Toko buka\");\n            printf(\"Urutan: %d\\n\", sekarang);\n            break;\n        case Selasa:\n        case Jumat:\n        case Sabtu:\n        case Minggu:\n            puts(\"Toko tutup\");\n            printf(\"Urutan: %d\\n\", sekarang);\n            break;\n        default:\n            puts(\"Hari tidak jelas\");\n            printf(\"Urutan: %d\\n\", sekarang);\n    }\n\n    return 0;\n}\n\nTentu saja, kegunaan enum tidak sebatas switch case. Meskipun cukup jarang dijumpai, enum bisa digunakan dalam kondisi apapun yang mengharuskan penggunaan bilangan bulat. Selain itu, dengan sifat enum yang selalu memasang nilai bilangan bulat secara terurut, enum bisa digunakan ketika ada variabel (atau ingin membuat tipe data baru) yang diharapkan hanya memiliki beberapa kemungkinan nilai (misalnya enum Hari di atas hanya memiliki 7 kemungkinan nilai), apalagi ketika urutan itu penting (walaupun tidak masalah juga menggunakan enum ketika urutan tidak penting).\nBahkan, kalau mau, kita bisa memasang nilai bilangan bulat tertentu untuk beberapa “konstanta” di dalam suatu enum, dan “konstanta” berikutnya akan selalu lebih besar daripada yang sebelumnya.\nenum KategoriUsia {\n    batita, balita=4, anak, remaja=13, dewasa=19, quarterlifecrisis, lansia=60\n};\nKita bisa melihat semua nilai yang dipasang:\n\n\nenumusia.c\n\n#include <stdio.h>\n\nenum KategoriUsia {\n    batita, balita=4, anak, remaja=13, dewasa=19, quarterlifecrisis, lansia=60\n};\n\nint main() {\n    printf(\n        \"%d %d %d %d %d %d %d\",\n        batita, balita, anak, remaja, dewasa, quarterlifecrisis, lansia\n    );\n    // output: 0 4 5 13 19 20 60\n\n    return 0;\n}\n\nKita juga bisa memaksakan agar beberapa “konstanta” memiliki nilai yang sama atau bahkan lebih rendah:\nenum Warna {\n    merah=100, putih=100, ungu=0, hijau, kuning, kelabu=1, biru\n};\nKarena enum merupakan bilangan bulat, kita bahkan bisa membandingkan apakah suatu bilangan bulat (ataupun suatu enum) itu sama dengan, lebih besar dari, atau lebih kecil dari suatu “konstanta” dalam enum.\n\n\nenumwarna.c\n\n#include <stdio.h>\n\nenum Warna {\n    merah=100, putih=100, ungu=0, hijau, kuning, kelabu=1, biru\n};\n\nint main() {\n    printf(\n        \"%d %d %d %d %d %d %d\",\n        merah, putih, ungu, hijau, kuning, kelabu, biru\n    );\n    // output: 100 100 0 1 2 1 \n    \n    if (merah==putih) {\n        puts(\"Merah dan putih setara\");\n    } else {\n        puts(\"Merah dan putih tidak setara\");\n    }\n\n    enum Warna warna_saya = biru;\n    if (warna_saya < hijau) {\n        puts(\"warna_saya < hijau\");\n    } else {\n        puts(\"warna_saya >= hijau\");\n    }\n\n    return 0;\n}"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#while-loop",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#while-loop",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "while loop",
    "text": "while loop\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#for-loop",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#for-loop",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "for loop",
    "text": "for loop\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#do-while-loop",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul01.html#do-while-loop",
    "title": "Modul 1 Struktur Data: Pengenalan bahasa pemrograman C",
    "section": "do while loop",
    "text": "do while loop\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html",
    "title": "Modul 0 Struktur Data: Instalasi dan konfigurasi software",
    "section": "",
    "text": "Kembali ke Struktur Data\nUntuk praktikum Struktur Data, kita akan menggunakan bahasa pemrograman C, sehingga perlu diinstal beberapa software, terutama gcc dan aplikasi Visual Studio Code. Apabila Anda tidak bersedia menginstal software tersebut di laptop, Anda tetap dapat menggunakan Sololearn Compiler Playground atau situs serupa. Kebetulan, aplikasi Sololearn juga tersedia untuk smartphone (Android, iOS).\nSelain itu, di praktikum terakhir, kita juga akan mulai membahas database dan SQL menggunakan SQLite, termasuk aplikasi DB Viewer (database viewer) untuk SQLite, sehingga keduanya perlu diinstal juga.\nAda juga graphviz (opsional) apabila Anda berniat ingin membuat visualisasi untuk berbagai struktur data, terutama berbagai jenis tree."
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#instalasi-gcc",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#instalasi-gcc",
    "title": "Modul 0 Struktur Data: Instalasi dan konfigurasi software",
    "section": "Instalasi gcc",
    "text": "Instalasi gcc\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#instalasi-dan-konfigurasi-visual-studio-code",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#instalasi-dan-konfigurasi-visual-studio-code",
    "title": "Modul 0 Struktur Data: Instalasi dan konfigurasi software",
    "section": "Instalasi dan konfigurasi Visual Studio Code",
    "text": "Instalasi dan konfigurasi Visual Studio Code\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#instalasi-sqlite",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#instalasi-sqlite",
    "title": "Modul 0 Struktur Data: Instalasi dan konfigurasi software",
    "section": "Instalasi SQLite",
    "text": "Instalasi SQLite\nhttps://www.sqlite.org/download.html\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#instalasi-db-browser-for-sqlite-db4s",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#instalasi-db-browser-for-sqlite-db4s",
    "title": "Modul 0 Struktur Data: Instalasi dan konfigurasi software",
    "section": "Instalasi DB Browser for SQLite (DB4S)",
    "text": "Instalasi DB Browser for SQLite (DB4S)\n\nWindows: dari installer\nStorage yang dibutuhkan: perkiraan 50-70 MB\n\nBuka situs https://sqlitebrowser.org/dl/, scroll ke bagian “Windows”, lalu pencet tulisan “DB Browser for SQLite - Standard installer for 64-bit Windows” untuk men-download/mengunduh installer untuk DB Browser for SQLite.\nSetelah proses download selesai, buka installer nya. Ikuti saja. Secara keseluruhan, Anda tinggal menekan Next berkali-kali sampai proses instalasi selesai. Apabila ada persetujuan seperti EULA (End-User License Agreement), setujui saja (centang). Namun, akan ada bagian Shortcuts, di mana Anda bisa mencentang semua pilihan untuk DB Browser (SQLite). Abaikan “SQLCipher” (tidak perlu dicentang).\nSetelah menekan Next beberapa kali, akan ada semacam proses loading, yang artinya proses instalasi sedang berjalan. Tunggu saja selama perkiraan 1 (satu) menit.\nNantinya, apabila proses instalasi sudah selesai, tombol Next akan berubah menjadi Finish, maka tekan Finish. Anda boleh menghapus installer nya.\n\n\n\nmacOS: dari file DMG\nStorage yang dibutuhkan: perkiraan 50-70 MB\n\nTentukan apakah laptop Anda memiliki prosesor Intel atau Apple Silicon. Di ujung kiri atas layar laptop Anda, tekan tombol Apple (), lalu “About This Mac”. Setelah itu, akan muncul beberapa informasi tentang MacBook Anda, termasuk keterangan prosesor atau chip, apakah Apple M1/M2 (Apple Silicon) atau Intel.\nBuka situs https://sqlitebrowser.org/dl/, scroll ke bagian “macOS”, lalu pencet tulisan “DB Browser for SQLite” yang sesuai dengan prosesor laptop Anda (antara Intel atau Apple Silicon) untuk men-download/mengunduh installer DB Browser for SQLite, yang berupa file DMG.\nSetelah proses download selesai, buka file DMG tersebut. Apabila muncul peringatan bahwa aplikasi tidak dikenal, tidak masalah, pencet Open saja.\nAkan muncul gambar/icon aplikasinya, dengan tulisan “DB Browser for SQLite”, serta folder Applications di sampingnya (dan ada panah di antaranya). Tarik gambar aplikasinya ke folder Applications tersebut, sesuai panah. Sebenarnya, ini adalah proses copy-paste agar aplikasinya menjadi tersedia di laptop Anda. Tunggu saja selama perkiraan 1 (satu) menit.\nProses instalasi sudah selesai dan aplikasi DB Browser untuk SQLite sudah bisa dibuka melalui folder Applications. Apabila, di Desktop, muncul semacam file Disk Image dengan tulisan DB Browser atau semacamnya, klik kanan lalu Eject saja. Anda boleh menghapus file DMG nya."
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#instalasi-graphviz",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#instalasi-graphviz",
    "title": "Modul 0 Struktur Data: Instalasi dan konfigurasi software",
    "section": "Instalasi graphviz",
    "text": "Instalasi graphviz\n\nWindows: dari installer\nhttps://graphviz.gitlab.io/download/\nblabla\n\n\nmacOS: dari source code\nStorage yang dibutuhkan: perkiraan 200-500 MB\n\nBuka situs https://graphviz.gitlab.io/download/source/, scroll ke bagian “Stable Releases”, lalu unduh/download versi yang terbaru (teratas), dengan menekan tulisan biru yang berakhiran “gz” (bukan yang sha256).\nSetelah proses download selesai, akan muncul file yang berakhiran .tar.gz. Itulah file yang telah diunduh. Klik file tersebut dua kali, seolah-olah ingin membuka suatu aplikasi. (Proses ini bernama extraction/unzipping. Daripada klik dua kali, Anda juga bisa klik kanan lalu “Extract”.) Kemudian, akan muncul folder baru dengan nama yang sama, tetapi tanpa akhiran .tar.gz, kira-kira bernama “graphviz-(versi)”, yang selanjutnya akan kita sebut “folder graphviz”.\nKlik kanan pada folder graphviz tersebut, lalu pencet “New Terminal at Folder”. Akan muncul Terimnal, yaitu semacam cmd atau command prompt untuk macOS.\nKetik ./configure, lalu tekan enter. Akan muncul banyak tulisan yang terus membanjiri Terminal. Tunggu saja selama perkiraan 3 (tiga) menit, sampai banjir berhenti. (Tentu saja, sambil menunggu, Anda boleh sambil melakukan hal lain, menggunakan aplikasi lain dan sebagainya, selama tidak menutup Terminal.)\nLalu, ketik make, tekan enter. Akan muncul banyak tulisan yang terus membanjiri Terminal lagi, tetapi kali ini lebih lama. Tunggu saja selama perkiraan 10 (sepuluh) menit, sampai banjir berhenti.\nTerakhir, ketik make install, dan tekan enter. Akan muncul banyak tulisan yang membanjiri Terminal lagi, tetapi tidak lama. Tunggu saja selama perkiraan 1 (satu) menit.\nSetelah banjir berhenti, proses instalasi sudah selesai dan Anda boleh menutup Terminal.\n\nSetelah instalasi selesai, Anda bisa membuka aplikasi Terminal (ada di folder Applications, lalu masuk folder Utilities) kapan saja, di mana saja, lalu menggunakan command dot untuk menggunakan graphviz. Contohnya, Anda bisa mengetik dot -V untuk memeriksa versi graphviz yang telah terinstal, atau mengetik dot -? untuk melihat daftar command yang ada."
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#konfigurasi-visual-studio-code-untuk-graphviz",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#konfigurasi-visual-studio-code-untuk-graphviz",
    "title": "Modul 0 Struktur Data: Instalasi dan konfigurasi software",
    "section": "Konfigurasi Visual Studio Code untuk graphviz",
    "text": "Konfigurasi Visual Studio Code untuk graphviz\nInstal extension berikut ini agar lebih mudah melihat gambar yang dihasilkan oleh bahasa Graphviz DOT:\nName: Graphviz Interactive Preview Id: tintinweb.graphviz-interactive-preview Description: Graphviz (dot) Interactive Preview Version: 0.3.5 Publisher: tintinweb VS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=tintinweb.graphviz-interactive-preview\nblabla"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#sololearn-compiler-playground",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#sololearn-compiler-playground",
    "title": "Modul 0 Struktur Data: Instalasi dan konfigurasi software",
    "section": "Sololearn Compiler Playground",
    "text": "Sololearn Compiler Playground\nhttps://www.sololearn.com/compiler-playground/"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#graphviz-online",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul00.html#graphviz-online",
    "title": "Modul 0 Struktur Data: Instalasi dan konfigurasi software",
    "section": "Graphviz Online",
    "text": "Graphviz Online\nhttps://dreampuf.github.io/GraphvizOnline/"
  },
  {
    "objectID": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04a.html",
    "href": "modulprak/2023_ganjil/strukdat/Strukdat2023_Modul04a.html",
    "title": "Modul 4a (opsional): ASCII, Unicode, inttypes.h, dan manipulasi text file",
    "section": "",
    "text": "Kembali ke Struktur Data\n\nOutline\n\nTentang ASCII, char, dan int\nManipulasi text file berformat ASCII\nTentang stderr\ninttypes.h untuk tipe data bilangan bulat dengan berbagai ukuran\nTentang Unicode: UTF-32, UTF-8\nManipulasi text file berformat UTF-8\nHeader file untuk Modul 4a Praktikum: prakmodul4a.h\n\n\n\nTentang ASCII, char, dan int\nblablabla chart table thingy\n\n\nManipulasi text file berformat ASCII\nhttps://stackoverflow.com/questions/4627330/difference-between-fprintf-printf-and-sprintf\nhttps://www.tutorialspoint.com/c_standard_library/c_function_fprintf.htm\nfopen, fprintf, fclose later fgets, sscanf\nhttps://www.guru99.com/c-file-input-output.html\nblabla\n\n\nTentang stderr\nhttps://stackoverflow.com/questions/12102332/when-should-i-use-perror-and-fprintfstderr\nblabla\n\n\ninttypes.h untuk tipe data bilangan bulat dengan berbagai ukuran\nblabla\n\n\nTentang Unicode: UTF-32, UTF-8\nblabla\n\n\nManipulasi text file berformat UTF-8\nhttps://stackoverflow.com/questions/21737906/how-to-read-write-utf8-text-files-in-c\nblabla\nhttps://www.youtube.com/watch?v=70b9ineDgLU\nhttps://gitlab.com/greggink/youtube_episode_understanding_text/-/blob/master/main.c\nblabla\n\n\nHeader file untuk Modul 4a Praktikum: prakmodul4a.h\nblabla"
  }
]