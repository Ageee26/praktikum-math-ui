[
  {
    "objectID": "semuahalaman/modulprak/2024/genap/eda/eda2024genap.html",
    "href": "semuahalaman/modulprak/2024/genap/eda/eda2024genap.html",
    "title": "Exploratory Data Analysis",
    "section": "",
    "text": "Kembali ke Praktikum\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython for Data Analysis (Pertemuan 1)\n\n\n\nFeb 27, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/saindat2024genap.html",
    "href": "semuahalaman/modulprak/2024/genap/saindat/saindat2024genap.html",
    "title": "Praktikum Saindat (Sains Data) 2024 Genap (Kurikulum 2020)",
    "section": "",
    "text": "Kembali ke Praktikum\n\nTimeline\n\nModul 1: Pengenalan Pandas, Transformasi Data, 19-20 Februari 2024 (offline di Lab Komputer D.311)\nModul 2: Pengenalan Seaborn, Visualisasi Data, 26-27 Februari 2024 (offline di Lab Komputer D.311)\nModul 3: Encoding Data Kategotik dan Imputasi Data, 4-5 Maret 2024 (offline di Lab Komputer D.311)"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul1.html",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul1.html",
    "title": "Modul 1 Sains Data: Pengenalan Pandas, Transformasi Data",
    "section": "",
    "text": "Kembali ke Sains Data"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul1.html#prerequisites",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul1.html#prerequisites",
    "title": "Modul 1 Sains Data: Pengenalan Pandas, Transformasi Data",
    "section": "Prerequisites",
    "text": "Prerequisites\nPada module ini kita akan coba mememahami package pandas, yang merupakan package inti dalam sains-data. kita akan coba melakukan beberapa transformasi data menggunakan pandas.\nsebelum itu, python module di bawah ini yang akan digunakan selama praktikum.\n\nimport numpy as np\nimport pandas as pd\n\nApabila ada yang belum terinstal, silakan instal terlebih dahulu menggunakan pip:\n!pip install numpy\n!pip install pandas\natau conda jika sedang menggunakan Anaconda:\nconda install numpy\nconda install pandas"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul1.html#series",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul1.html#series",
    "title": "Modul 1 Sains Data: Pengenalan Pandas, Transformasi Data",
    "section": "Series",
    "text": "Series\npandas.Series sangat mirip dengan array NumPy (bahkan dibangun di atas objek array NumPy). Yang membedakan array NumPy dari sebuah Series adalah bahwa sebuah Series dapat memiliki label index, yang berarti dapat diindeks dengan label, bukan hanya lokasi nomor saja. Selain itu, sebuah Series tidak perlu menyimpan data numerik, ia dapat menyimpan objek Python sembarang.\n\nMembuat pd.Series dengan list\nPaling mudah, ktia dapat membuat pd.Series dengan python list\n\nmy_index= ['a','b','c','d','e']\nmy_data= [1,2,3,4,5]\nmy_series= pd.Series(data=my_data, index=my_index)\n\n\nprint(my_series)\n\na    1\nb    2\nc    3\nd    4\ne    5\ndtype: int64\n\n\n\nprint(my_series.__class__)\n\n&lt;class 'pandas.core.series.Series'&gt;\n\n\n\n\nMembuat pd.Series dengan dictionary\nKita juga dapat membuat pd.Series dengan dictionary\n\n# creating a series from a dictionary\nmy_dict= {'a':1, 'b':2, 'c':3, 'd':4, 'e':5}\nmy_series_dict= pd.Series(my_dict)\n\n\nprint(my_series_dict)\n\na    1\nb    2\nc    3\nd    4\ne    5\ndtype: int64\n\n\n\nprint(my_series_dict.__class__)\n\n&lt;class 'pandas.core.series.Series'&gt;\n\n\n\n\nOperasi pada Series\n\n# Imaginary Sales Data for 1st and 2nd Quarters for Global Company\nq1 = {'Japan': 80, 'China': 450, 'India': 200, 'USA': 250}\nq2 = {'Brazil': 100,'China': 500, 'India': 210,'USA': 260}\n\n\n# Creating a Series from a Dictionary q1 and q2\nq1_series= pd.Series(q1)\nq2_series= pd.Series(q2)\n\n\nprint(q1_series)\n\nJapan     80\nChina    450\nIndia    200\nUSA      250\ndtype: int64\n\n\nKita dapat mengindeks dengan label\n\n# call values of q1_series based on named index\nprint(q1_series['Japan'])\nprint(q1_series['China'])\nprint(q1_series['India'])\n\n80\n450\n200\n\n\nkita dapat tetap dapat mengindeks dengan integer\n\n# u can also call values of q1_series based on positional index\nprint(q1_series[0])\nprint(q1_series[1])\nprint(q1_series[2])\n\n80\n450\n200\n\n\nhati-hati dalam melakukan indexing dengan label. bisa saja terjadi error jika label tidak ada di dalam pd.series\n\n# remember named index is case sensitive\ntry:\n    print(q1_series['japan'])\nexcept:\n    print('something went wrong')\n\nsomething went wrong\n\n\nOperasi aritmatik sederhana pada pd.Series bersifat broadcasting, yaitu diterapkan ke masing-masing elemen\n\n# operations with arithmetic on series are broadcasted to all values\nprint(q1_series*2)\n\nJapan    160\nChina    900\nIndia    400\nUSA      500\ndtype: int64\n\n\n\nprint(q1_series+1000)\n\nJapan    1080\nChina    1450\nIndia    1200\nUSA      1250\ndtype: int64\n\n\nUntuk penjumlahan antara dua pd.Series, apabila ada label yang hanya muncul di salah satu series, maka label tersebut akan muncul di hasil jumlah dengan data NaN (not a number, di sini artinya tidak ada data).\n(Kebetulan, keterangan NaN hanya bisa muncul untuk tipe data float atau koma-komaan, sehingga tipe data terpaksa diubah menjadi float.)\n\n# operation between series are also broadcasted\nprint(q1_series+q2_series)\n\nBrazil      NaN\nChina     950.0\nIndia     410.0\nJapan       NaN\nUSA       510.0\ndtype: float64\n\n\nMengapa tidak nol saja? Ketiadaan label pada salah satu series dianggap sebagai ketidaktahuan data untuk label tersebut, bukan dianggap nol.\nApabila diinginkan agar data yang tiada dianggap nol terlebih dahulu baru dijumlahkan, bisa seperti berikut:\n\nprint(q1_series.add(q2_series, fill_value=0))\n\nBrazil    100.0\nChina     950.0\nIndia     410.0\nJapan      80.0\nUSA       510.0\ndtype: float64"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul1.html#data-frame",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul1.html#data-frame",
    "title": "Modul 1 Sains Data: Pengenalan Pandas, Transformasi Data",
    "section": "data frame",
    "text": "data frame\nSebuah pd.DataFrame terdiri dari beberapa pd.Series yang berbagi nilai indeks.\nMisalkan kita punya data seperti berikut.\n\nmy_data = np.array([\n    [25, 59, 18],\n    [75, 54, 65],\n    [29, 21,  7],\n    [32, 68, 16]\n])\n\n\nmy_data\n\narray([[25, 59, 18],\n       [75, 54, 65],\n       [29, 21,  7],\n       [32, 68, 16]])\n\n\nKita akan membuat pd.Dataframe melalui python list. Perhatikan bahwa kita dapat memberikan nama pada kolom dan baris\n\nmy_index= [\"Toko A\", \"Toko B\", \"Toko C\", \"Toko D\"]\nmy_columns= [\"Apel\", \"Jeruk\", \"Pisang\"]\n\ndf= pd.DataFrame(data=my_data, index=my_index, columns=my_columns)\n\n\ndf\n\n\n\n\n\n\n\n\nApel\nJeruk\nPisang\n\n\n\n\nToko A\n25\n59\n18\n\n\nToko B\n75\n54\n65\n\n\nToko C\n29\n21\n7\n\n\nToko D\n32\n68\n16\n\n\n\n\n\n\n\n\ndf_2 = pd.DataFrame(data=my_data)\ndf_2\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n25\n59\n18\n\n\n1\n75\n54\n65\n\n\n2\n29\n21\n7\n\n\n3\n32\n68\n16\n\n\n\n\n\n\n\n\ndf_3 = pd.DataFrame(data=my_data, columns=my_columns)\ndf_3\n\n\n\n\n\n\n\n\nApel\nJeruk\nPisang\n\n\n\n\n0\n25\n59\n18\n\n\n1\n75\n54\n65\n\n\n2\n29\n21\n7\n\n\n3\n32\n68\n16\n\n\n\n\n\n\n\n\nmembaca file csv sebagai pd.DataFrame\nJika berkas .py atau .ipynb Anda berada di lokasi folder yang sama persis dengan berkas .csv yang ingin Anda baca, cukup berikan nama berkas sebagai string, misalnya:\ndf = pd.read_csv('some_file.csv')\nBerikan s berkas jika Anda berada di direktori yang berbeda. Jalur berkas harus 100% benar agar ini berfungsi. Misalnya:\ndf = pd.read_csv(\"C:\\\\Users\\\\myself\\\\files\\\\some_file.csv\")\nsebelum itu, kalian dapat mendownload dataset “Waiter’s Tips Dataset” melalui salah satu link berikut:\n\nDirect link (langsung dari GitHub Pages ini)\nKaggle\nGoogle Drive\n\n\ndf_tips = pd.read_csv('./tips.csv')\n\n\ndf_tips\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\n\n\n\n\n0\n16.99\n1.01\nFemale\nNo\nSun\nDinner\n2\n8.49\nChristy Cunningham\n3560325168603410\nSun2959\n\n\n1\n10.34\n1.66\nMale\nNo\nSun\nDinner\n3\n3.45\nDouglas Tucker\n4478071379779230\nSun4608\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\nSun4458\n\n\n3\n23.68\n3.31\nMale\nNo\nSun\nDinner\n2\n11.84\nNathaniel Harris\n4676137647685994\nSun5260\n\n\n4\n24.59\n3.61\nFemale\nNo\nSun\nDinner\n4\n6.15\nTonya Carter\n4832732618637221\nSun2251\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n239\n29.03\n5.92\nMale\nNo\nSat\nDinner\n3\n9.68\nMichael Avila\n5296068606052842\nSat2657\n\n\n240\n27.18\n2.00\nFemale\nYes\nSat\nDinner\n2\n13.59\nMonica Sanders\n3506806155565404\nSat1766\n\n\n241\n22.67\n2.00\nMale\nYes\nSat\nDinner\n2\n11.34\nKeith Wong\n6011891618747196\nSat3880\n\n\n242\n17.82\n1.75\nMale\nNo\nSat\nDinner\n2\n8.91\nDennis Dixon\n4375220550950\nSat17\n\n\n243\n18.78\n3.00\nFemale\nNo\nThur\nDinner\n2\n9.39\nMichelle Hardin\n3511451626698139\nThur672\n\n\n\n\n244 rows × 11 columns\n\n\n\n\n\nOperasi sederhana pada DataFrame\n\n# mengecek nama kolom\ndf_tips.columns\n\nIndex(['total_bill', 'tip', 'sex', 'smoker', 'day', 'time', 'size',\n       'price_per_person', 'Payer Name', 'CC Number', 'Payment ID'],\n      dtype='object')\n\n\n\n# mengecek \ndf_tips.index\n\nRangeIndex(start=0, stop=244, step=1)\n\n\n\ndf_tips.head()\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\n\n\n\n\n0\n16.99\n1.01\nFemale\nNo\nSun\nDinner\n2\n8.49\nChristy Cunningham\n3560325168603410\nSun2959\n\n\n1\n10.34\n1.66\nMale\nNo\nSun\nDinner\n3\n3.45\nDouglas Tucker\n4478071379779230\nSun4608\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\nSun4458\n\n\n3\n23.68\n3.31\nMale\nNo\nSun\nDinner\n2\n11.84\nNathaniel Harris\n4676137647685994\nSun5260\n\n\n4\n24.59\n3.61\nFemale\nNo\nSun\nDinner\n4\n6.15\nTonya Carter\n4832732618637221\nSun2251\n\n\n\n\n\n\n\n\ndf_tips.head(10)\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\n\n\n\n\n0\n16.99\n1.01\nFemale\nNo\nSun\nDinner\n2\n8.49\nChristy Cunningham\n3560325168603410\nSun2959\n\n\n1\n10.34\n1.66\nMale\nNo\nSun\nDinner\n3\n3.45\nDouglas Tucker\n4478071379779230\nSun4608\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\nSun4458\n\n\n3\n23.68\n3.31\nMale\nNo\nSun\nDinner\n2\n11.84\nNathaniel Harris\n4676137647685994\nSun5260\n\n\n4\n24.59\n3.61\nFemale\nNo\nSun\nDinner\n4\n6.15\nTonya Carter\n4832732618637221\nSun2251\n\n\n5\n25.29\n4.71\nMale\nNo\nSun\nDinner\n4\n6.32\nErik Smith\n213140353657882\nSun9679\n\n\n6\n8.77\n2.00\nMale\nNo\nSun\nDinner\n2\n4.38\nKristopher Johnson\n2223727524230344\nSun5985\n\n\n7\n26.88\n3.12\nMale\nNo\nSun\nDinner\n4\n6.72\nRobert Buck\n3514785077705092\nSun8157\n\n\n8\n15.04\n1.96\nMale\nNo\nSun\nDinner\n2\n7.52\nJoseph Mcdonald\n3522866365840377\nSun6820\n\n\n9\n14.78\n3.23\nMale\nNo\nSun\nDinner\n2\n7.39\nJerome Abbott\n3532124519049786\nSun3775\n\n\n\n\n\n\n\n\ndf_tips.tail()\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\n\n\n\n\n239\n29.03\n5.92\nMale\nNo\nSat\nDinner\n3\n9.68\nMichael Avila\n5296068606052842\nSat2657\n\n\n240\n27.18\n2.00\nFemale\nYes\nSat\nDinner\n2\n13.59\nMonica Sanders\n3506806155565404\nSat1766\n\n\n241\n22.67\n2.00\nMale\nYes\nSat\nDinner\n2\n11.34\nKeith Wong\n6011891618747196\nSat3880\n\n\n242\n17.82\n1.75\nMale\nNo\nSat\nDinner\n2\n8.91\nDennis Dixon\n4375220550950\nSat17\n\n\n243\n18.78\n3.00\nFemale\nNo\nThur\nDinner\n2\n9.39\nMichelle Hardin\n3511451626698139\nThur672\n\n\n\n\n\n\n\n\ndf_tips.tail(10)\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\n\n\n\n\n234\n15.53\n3.00\nMale\nYes\nSat\nDinner\n2\n7.76\nTracy Douglas\n4097938155941930\nSat7220\n\n\n235\n10.07\n1.25\nMale\nNo\nSat\nDinner\n2\n5.04\nSean Gonzalez\n3534021246117605\nSat4615\n\n\n236\n12.60\n1.00\nMale\nYes\nSat\nDinner\n2\n6.30\nMatthew Myers\n3543676378973965\nSat5032\n\n\n237\n32.83\n1.17\nMale\nYes\nSat\nDinner\n2\n16.42\nThomas Brown\n4284722681265508\nSat2929\n\n\n238\n35.83\n4.67\nFemale\nNo\nSat\nDinner\n3\n11.94\nKimberly Crane\n676184013727\nSat9777\n\n\n239\n29.03\n5.92\nMale\nNo\nSat\nDinner\n3\n9.68\nMichael Avila\n5296068606052842\nSat2657\n\n\n240\n27.18\n2.00\nFemale\nYes\nSat\nDinner\n2\n13.59\nMonica Sanders\n3506806155565404\nSat1766\n\n\n241\n22.67\n2.00\nMale\nYes\nSat\nDinner\n2\n11.34\nKeith Wong\n6011891618747196\nSat3880\n\n\n242\n17.82\n1.75\nMale\nNo\nSat\nDinner\n2\n8.91\nDennis Dixon\n4375220550950\nSat17\n\n\n243\n18.78\n3.00\nFemale\nNo\nThur\nDinner\n2\n9.39\nMichelle Hardin\n3511451626698139\nThur672\n\n\n\n\n\n\n\n\ndf_tips.describe()\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsize\nprice_per_person\nCC Number\n\n\n\n\ncount\n244.000000\n244.000000\n244.000000\n244.000000\n2.440000e+02\n\n\nmean\n19.785943\n2.998279\n2.569672\n7.888197\n2.563496e+15\n\n\nstd\n8.902412\n1.383638\n0.951100\n2.914234\n2.369340e+15\n\n\nmin\n3.070000\n1.000000\n1.000000\n2.880000\n6.040679e+10\n\n\n25%\n13.347500\n2.000000\n2.000000\n5.800000\n3.040731e+13\n\n\n50%\n17.795000\n2.900000\n2.000000\n7.255000\n3.525318e+15\n\n\n75%\n24.127500\n3.562500\n3.000000\n9.390000\n4.553675e+15\n\n\nmax\n50.810000\n10.000000\n6.000000\n20.270000\n6.596454e+15\n\n\n\n\n\n\n\n\ndf_tips.describe().transpose()\n\n\n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\n\n\n\n\ntotal_bill\n244.0\n1.978594e+01\n8.902412e+00\n3.070000e+00\n1.334750e+01\n1.779500e+01\n2.412750e+01\n5.081000e+01\n\n\ntip\n244.0\n2.998279e+00\n1.383638e+00\n1.000000e+00\n2.000000e+00\n2.900000e+00\n3.562500e+00\n1.000000e+01\n\n\nsize\n244.0\n2.569672e+00\n9.510998e-01\n1.000000e+00\n2.000000e+00\n2.000000e+00\n3.000000e+00\n6.000000e+00\n\n\nprice_per_person\n244.0\n7.888197e+00\n2.914234e+00\n2.880000e+00\n5.800000e+00\n7.255000e+00\n9.390000e+00\n2.027000e+01\n\n\nCC Number\n244.0\n2.563496e+15\n2.369340e+15\n6.040679e+10\n3.040731e+13\n3.525318e+15\n4.553675e+15\n6.596454e+15\n\n\n\n\n\n\n\n\n\nTransformasi data (row-wise)\n\nfiltering\n\ndf_tips.head()\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\n\n\n\n\n0\n16.99\n1.01\nFemale\nNo\nSun\nDinner\n2\n8.49\nChristy Cunningham\n3560325168603410\nSun2959\n\n\n1\n10.34\n1.66\nMale\nNo\nSun\nDinner\n3\n3.45\nDouglas Tucker\n4478071379779230\nSun4608\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\nSun4458\n\n\n3\n23.68\n3.31\nMale\nNo\nSun\nDinner\n2\n11.84\nNathaniel Harris\n4676137647685994\nSun5260\n\n\n4\n24.59\n3.61\nFemale\nNo\nSun\nDinner\n4\n6.15\nTonya Carter\n4832732618637221\nSun2251\n\n\n\n\n\n\n\n\nprint(df_tips[\"size\"] == 3)\n\n0      False\n1       True\n2       True\n3      False\n4      False\n       ...  \n239     True\n240    False\n241    False\n242    False\n243    False\nName: size, Length: 244, dtype: bool\n\n\n\nconditional_size = (df_tips[\"size\"] == 3)\ndf_tips[conditional_size]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\n\n\n\n\n1\n10.34\n1.66\nMale\nNo\nSun\nDinner\n3\n3.45\nDouglas Tucker\n4478071379779230\nSun4608\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\nSun4458\n\n\n16\n10.33\n1.67\nFemale\nNo\nSun\nDinner\n3\n3.44\nElizabeth Foster\n4240025044626033\nSun9715\n\n\n17\n16.29\n3.71\nMale\nNo\nSun\nDinner\n3\n5.43\nJohn Pittman\n6521340257218708\nSun2998\n\n\n18\n16.97\n3.50\nFemale\nNo\nSun\nDinner\n3\n5.66\nLaura Martinez\n30422275171379\nSun2789\n\n\n19\n20.65\n3.35\nMale\nNo\nSat\nDinner\n3\n6.88\nTimothy Oneal\n6568069240986485\nSat9213\n\n\n35\n24.06\n3.60\nMale\nNo\nSat\nDinner\n3\n8.02\nJoseph Mullins\n5519770449260299\nSat632\n\n\n36\n16.31\n2.00\nMale\nNo\nSat\nDinner\n3\n5.44\nWilliam Ford\n3527691170179398\nSat9139\n\n\n37\n16.93\n3.07\nFemale\nNo\nSat\nDinner\n3\n5.64\nErin Lewis\n5161695527390786\nSat6406\n\n\n38\n18.69\n2.31\nMale\nNo\nSat\nDinner\n3\n6.23\nBrandon Bradley\n4427601595688633\nSat4056\n\n\n39\n31.27\n5.00\nMale\nNo\nSat\nDinner\n3\n10.42\nMr. Brandon Berry\n6011525851069856\nSat6373\n\n\n40\n16.04\n2.24\nMale\nNo\nSat\nDinner\n3\n5.35\nAdam Edwards\n3544447755679420\nSat8549\n\n\n48\n28.55\n2.05\nMale\nNo\nSun\nDinner\n3\n9.52\nAustin Fisher\n6011481668986587\nSun4142\n\n\n64\n17.59\n2.64\nMale\nNo\nSat\nDinner\n3\n5.86\nMichael Johnson\n2222114458088108\nSat1667\n\n\n65\n20.08\n3.15\nMale\nNo\nSat\nDinner\n3\n6.69\nJustin Dixon\n180021262464926\nSat6840\n\n\n71\n17.07\n3.00\nFemale\nNo\nSat\nDinner\n3\n5.69\nTeresa Fisher\n5442222963796367\nSat3469\n\n\n102\n44.30\n2.50\nFemale\nYes\nSat\nDinner\n3\n14.77\nHeather Cohen\n379771118886604\nSat6240\n\n\n112\n38.07\n4.00\nMale\nNo\nSun\nDinner\n3\n12.69\nJeff Lopez\n3572865915176463\nSun591\n\n\n114\n25.71\n4.00\nFemale\nNo\nSun\nDinner\n3\n8.57\nKatie Smith\n5400160161311292\nSun6492\n\n\n129\n22.82\n2.18\nMale\nNo\nThur\nLunch\n3\n7.61\nRaymond Torres\n4855776744024\nThur9424\n\n\n146\n18.64\n1.36\nFemale\nNo\nThur\nLunch\n3\n6.21\nKelly Estrada\n60463302327\nThur3941\n\n\n152\n17.26\n2.74\nMale\nNo\nSun\nDinner\n3\n5.75\nGregory Smith\n4292362333741\nSun5205\n\n\n162\n16.21\n2.00\nFemale\nNo\nSun\nDinner\n3\n5.40\nJennifer Baird\n4227834176859693\nSun5521\n\n\n165\n24.52\n3.48\nMale\nNo\nSun\nDinner\n3\n8.17\nJacob Hansen\n4031116007387\nSun9043\n\n\n170\n50.81\n10.00\nMale\nYes\nSat\nDinner\n3\n16.94\nGregory Clark\n5473850968388236\nSat1954\n\n\n182\n45.35\n3.50\nMale\nYes\nSun\nDinner\n3\n15.12\nJose Parsons\n4112207559459910\nSun2337\n\n\n186\n20.90\n3.50\nFemale\nYes\nSun\nDinner\n3\n6.97\nHeidi Atkinson\n4422858423131187\nSun4254\n\n\n188\n18.15\n3.50\nFemale\nYes\nSun\nDinner\n3\n6.05\nGlenda Wiggins\n578329325307\nSun430\n\n\n189\n23.10\n4.00\nMale\nYes\nSun\nDinner\n3\n7.70\nRichard Stevens\n3560193117506187\nSun1821\n\n\n200\n18.71\n4.00\nMale\nYes\nThur\nLunch\n3\n6.24\nJason Conrad\n4581233003487\nThur6048\n\n\n205\n16.47\n3.23\nFemale\nYes\nThur\nLunch\n3\n5.49\nCarly Reyes\n4787787236486\nThur8084\n\n\n206\n26.59\n3.41\nMale\nYes\nSat\nDinner\n3\n8.86\nDaniel Owens\n38971087967574\nSat1\n\n\n210\n30.06\n2.00\nMale\nYes\nSat\nDinner\n3\n10.02\nShawn Mendoza\n30184049218122\nSat8361\n\n\n214\n28.17\n6.50\nFemale\nYes\nSat\nDinner\n3\n9.39\nMarissa Jackson\n4922302538691962\nSat3374\n\n\n223\n15.98\n3.00\nFemale\nNo\nFri\nLunch\n3\n5.33\nMary Rivera\n5343428579353069\nFri6014\n\n\n231\n15.69\n3.00\nMale\nYes\nSat\nDinner\n3\n5.23\nJason Parks\n4812333796161\nSat6334\n\n\n238\n35.83\n4.67\nFemale\nNo\nSat\nDinner\n3\n11.94\nKimberly Crane\n676184013727\nSat9777\n\n\n239\n29.03\n5.92\nMale\nNo\nSat\nDinner\n3\n9.68\nMichael Avila\n5296068606052842\nSat2657\n\n\n\n\n\n\n\n\nconditional = (df_tips[\"size\"] == 3) & (df_tips[\"total_bill\"] &gt; 20)\nprint(conditional)\n\n0      False\n1      False\n2       True\n3      False\n4      False\n       ...  \n239     True\n240    False\n241    False\n242    False\n243    False\nLength: 244, dtype: bool\n\n\n\ndf_tips[conditional]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\n\n\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\nSun4458\n\n\n19\n20.65\n3.35\nMale\nNo\nSat\nDinner\n3\n6.88\nTimothy Oneal\n6568069240986485\nSat9213\n\n\n35\n24.06\n3.60\nMale\nNo\nSat\nDinner\n3\n8.02\nJoseph Mullins\n5519770449260299\nSat632\n\n\n39\n31.27\n5.00\nMale\nNo\nSat\nDinner\n3\n10.42\nMr. Brandon Berry\n6011525851069856\nSat6373\n\n\n48\n28.55\n2.05\nMale\nNo\nSun\nDinner\n3\n9.52\nAustin Fisher\n6011481668986587\nSun4142\n\n\n65\n20.08\n3.15\nMale\nNo\nSat\nDinner\n3\n6.69\nJustin Dixon\n180021262464926\nSat6840\n\n\n102\n44.30\n2.50\nFemale\nYes\nSat\nDinner\n3\n14.77\nHeather Cohen\n379771118886604\nSat6240\n\n\n112\n38.07\n4.00\nMale\nNo\nSun\nDinner\n3\n12.69\nJeff Lopez\n3572865915176463\nSun591\n\n\n114\n25.71\n4.00\nFemale\nNo\nSun\nDinner\n3\n8.57\nKatie Smith\n5400160161311292\nSun6492\n\n\n129\n22.82\n2.18\nMale\nNo\nThur\nLunch\n3\n7.61\nRaymond Torres\n4855776744024\nThur9424\n\n\n165\n24.52\n3.48\nMale\nNo\nSun\nDinner\n3\n8.17\nJacob Hansen\n4031116007387\nSun9043\n\n\n170\n50.81\n10.00\nMale\nYes\nSat\nDinner\n3\n16.94\nGregory Clark\n5473850968388236\nSat1954\n\n\n182\n45.35\n3.50\nMale\nYes\nSun\nDinner\n3\n15.12\nJose Parsons\n4112207559459910\nSun2337\n\n\n186\n20.90\n3.50\nFemale\nYes\nSun\nDinner\n3\n6.97\nHeidi Atkinson\n4422858423131187\nSun4254\n\n\n189\n23.10\n4.00\nMale\nYes\nSun\nDinner\n3\n7.70\nRichard Stevens\n3560193117506187\nSun1821\n\n\n206\n26.59\n3.41\nMale\nYes\nSat\nDinner\n3\n8.86\nDaniel Owens\n38971087967574\nSat1\n\n\n210\n30.06\n2.00\nMale\nYes\nSat\nDinner\n3\n10.02\nShawn Mendoza\n30184049218122\nSat8361\n\n\n214\n28.17\n6.50\nFemale\nYes\nSat\nDinner\n3\n9.39\nMarissa Jackson\n4922302538691962\nSat3374\n\n\n238\n35.83\n4.67\nFemale\nNo\nSat\nDinner\n3\n11.94\nKimberly Crane\n676184013727\nSat9777\n\n\n239\n29.03\n5.92\nMale\nNo\nSat\nDinner\n3\n9.68\nMichael Avila\n5296068606052842\nSat2657\n\n\n\n\n\n\n\n\ndf_tips[(df_tips[\"size\"] == 3) & (df_tips[\"total_bill\"] &gt; 20)]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\n\n\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\nSun4458\n\n\n19\n20.65\n3.35\nMale\nNo\nSat\nDinner\n3\n6.88\nTimothy Oneal\n6568069240986485\nSat9213\n\n\n35\n24.06\n3.60\nMale\nNo\nSat\nDinner\n3\n8.02\nJoseph Mullins\n5519770449260299\nSat632\n\n\n39\n31.27\n5.00\nMale\nNo\nSat\nDinner\n3\n10.42\nMr. Brandon Berry\n6011525851069856\nSat6373\n\n\n48\n28.55\n2.05\nMale\nNo\nSun\nDinner\n3\n9.52\nAustin Fisher\n6011481668986587\nSun4142\n\n\n65\n20.08\n3.15\nMale\nNo\nSat\nDinner\n3\n6.69\nJustin Dixon\n180021262464926\nSat6840\n\n\n102\n44.30\n2.50\nFemale\nYes\nSat\nDinner\n3\n14.77\nHeather Cohen\n379771118886604\nSat6240\n\n\n112\n38.07\n4.00\nMale\nNo\nSun\nDinner\n3\n12.69\nJeff Lopez\n3572865915176463\nSun591\n\n\n114\n25.71\n4.00\nFemale\nNo\nSun\nDinner\n3\n8.57\nKatie Smith\n5400160161311292\nSun6492\n\n\n129\n22.82\n2.18\nMale\nNo\nThur\nLunch\n3\n7.61\nRaymond Torres\n4855776744024\nThur9424\n\n\n165\n24.52\n3.48\nMale\nNo\nSun\nDinner\n3\n8.17\nJacob Hansen\n4031116007387\nSun9043\n\n\n170\n50.81\n10.00\nMale\nYes\nSat\nDinner\n3\n16.94\nGregory Clark\n5473850968388236\nSat1954\n\n\n182\n45.35\n3.50\nMale\nYes\nSun\nDinner\n3\n15.12\nJose Parsons\n4112207559459910\nSun2337\n\n\n186\n20.90\n3.50\nFemale\nYes\nSun\nDinner\n3\n6.97\nHeidi Atkinson\n4422858423131187\nSun4254\n\n\n189\n23.10\n4.00\nMale\nYes\nSun\nDinner\n3\n7.70\nRichard Stevens\n3560193117506187\nSun1821\n\n\n206\n26.59\n3.41\nMale\nYes\nSat\nDinner\n3\n8.86\nDaniel Owens\n38971087967574\nSat1\n\n\n210\n30.06\n2.00\nMale\nYes\nSat\nDinner\n3\n10.02\nShawn Mendoza\n30184049218122\nSat8361\n\n\n214\n28.17\n6.50\nFemale\nYes\nSat\nDinner\n3\n9.39\nMarissa Jackson\n4922302538691962\nSat3374\n\n\n238\n35.83\n4.67\nFemale\nNo\nSat\nDinner\n3\n11.94\nKimberly Crane\n676184013727\nSat9777\n\n\n239\n29.03\n5.92\nMale\nNo\nSat\nDinner\n3\n9.68\nMichael Avila\n5296068606052842\nSat2657\n\n\n\n\n\n\n\n\nconditional_or = (df_tips[\"tip\"] &gt; 4) | (df_tips[\"total_bill\"] &gt; 20)\ndf_tips[conditional_or]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\n\n\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\nSun4458\n\n\n3\n23.68\n3.31\nMale\nNo\nSun\nDinner\n2\n11.84\nNathaniel Harris\n4676137647685994\nSun5260\n\n\n4\n24.59\n3.61\nFemale\nNo\nSun\nDinner\n4\n6.15\nTonya Carter\n4832732618637221\nSun2251\n\n\n5\n25.29\n4.71\nMale\nNo\nSun\nDinner\n4\n6.32\nErik Smith\n213140353657882\nSun9679\n\n\n7\n26.88\n3.12\nMale\nNo\nSun\nDinner\n4\n6.72\nRobert Buck\n3514785077705092\nSun8157\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n237\n32.83\n1.17\nMale\nYes\nSat\nDinner\n2\n16.42\nThomas Brown\n4284722681265508\nSat2929\n\n\n238\n35.83\n4.67\nFemale\nNo\nSat\nDinner\n3\n11.94\nKimberly Crane\n676184013727\nSat9777\n\n\n239\n29.03\n5.92\nMale\nNo\nSat\nDinner\n3\n9.68\nMichael Avila\n5296068606052842\nSat2657\n\n\n240\n27.18\n2.00\nFemale\nYes\nSat\nDinner\n2\n13.59\nMonica Sanders\n3506806155565404\nSat1766\n\n\n241\n22.67\n2.00\nMale\nYes\nSat\nDinner\n2\n11.34\nKeith Wong\n6011891618747196\nSat3880\n\n\n\n\n101 rows × 11 columns\n\n\n\n\nweekend = [\"Sun\", \"Sat\"]\nconditional_in = df_tips[\"day\"].isin(weekend)\ndf_tips[conditional_in]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\n\n\n\n\n0\n16.99\n1.01\nFemale\nNo\nSun\nDinner\n2\n8.49\nChristy Cunningham\n3560325168603410\nSun2959\n\n\n1\n10.34\n1.66\nMale\nNo\nSun\nDinner\n3\n3.45\nDouglas Tucker\n4478071379779230\nSun4608\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\nSun4458\n\n\n3\n23.68\n3.31\nMale\nNo\nSun\nDinner\n2\n11.84\nNathaniel Harris\n4676137647685994\nSun5260\n\n\n4\n24.59\n3.61\nFemale\nNo\nSun\nDinner\n4\n6.15\nTonya Carter\n4832732618637221\nSun2251\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n238\n35.83\n4.67\nFemale\nNo\nSat\nDinner\n3\n11.94\nKimberly Crane\n676184013727\nSat9777\n\n\n239\n29.03\n5.92\nMale\nNo\nSat\nDinner\n3\n9.68\nMichael Avila\n5296068606052842\nSat2657\n\n\n240\n27.18\n2.00\nFemale\nYes\nSat\nDinner\n2\n13.59\nMonica Sanders\n3506806155565404\nSat1766\n\n\n241\n22.67\n2.00\nMale\nYes\nSat\nDinner\n2\n11.34\nKeith Wong\n6011891618747196\nSat3880\n\n\n242\n17.82\n1.75\nMale\nNo\nSat\nDinner\n2\n8.91\nDennis Dixon\n4375220550950\nSat17\n\n\n\n\n163 rows × 11 columns\n\n\n\n\ndf_tips.head()\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\n\n\n\n\n0\n16.99\n1.01\nFemale\nNo\nSun\nDinner\n2\n8.49\nChristy Cunningham\n3560325168603410\nSun2959\n\n\n1\n10.34\n1.66\nMale\nNo\nSun\nDinner\n3\n3.45\nDouglas Tucker\n4478071379779230\nSun4608\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\nSun4458\n\n\n3\n23.68\n3.31\nMale\nNo\nSun\nDinner\n2\n11.84\nNathaniel Harris\n4676137647685994\nSun5260\n\n\n4\n24.59\n3.61\nFemale\nNo\nSun\nDinner\n4\n6.15\nTonya Carter\n4832732618637221\nSun2251\n\n\n\n\n\n\n\n\n\nmencari nilai unik\n\ndf_tips[\"day\"].unique()\n\narray(['Sun', 'Sat', 'Thur', 'Fri'], dtype=object)\n\n\n\ndf_tips[[\"day\",\"time\"]]\n\n\n\n\n\n\n\n\nday\ntime\n\n\n\n\n0\nSun\nDinner\n\n\n1\nSun\nDinner\n\n\n2\nSun\nDinner\n\n\n3\nSun\nDinner\n\n\n4\nSun\nDinner\n\n\n...\n...\n...\n\n\n239\nSat\nDinner\n\n\n240\nSat\nDinner\n\n\n241\nSat\nDinner\n\n\n242\nSat\nDinner\n\n\n243\nThur\nDinner\n\n\n\n\n244 rows × 2 columns\n\n\n\n\ndf_tips.drop_duplicates([\"day\",\"time\"])[[\"day\",\"time\"]]\n\n\n\n\n\n\n\n\nday\ntime\n\n\n\n\n0\nSun\nDinner\n\n\n19\nSat\nDinner\n\n\n77\nThur\nLunch\n\n\n90\nFri\nDinner\n\n\n220\nFri\nLunch\n\n\n243\nThur\nDinner\n\n\n\n\n\n\n\n\n\n\nTransforming Data (Column Wise)\n\nSelecting Columns\n\nprint(df_tips[\"day\"])\n\n0       Sun\n1       Sun\n2       Sun\n3       Sun\n4       Sun\n       ... \n239     Sat\n240     Sat\n241     Sat\n242     Sat\n243    Thur\nName: day, Length: 244, dtype: object\n\n\n\nprint(df_tips.day)\n\n0       Sun\n1       Sun\n2       Sun\n3       Sun\n4       Sun\n       ... \n239     Sat\n240     Sat\n241     Sat\n242     Sat\n243    Thur\nName: day, Length: 244, dtype: object\n\n\n\ndf_tips[[\"day\",\"time\"]]\n\n\n\n\n\n\n\n\nday\ntime\n\n\n\n\n0\nSun\nDinner\n\n\n1\nSun\nDinner\n\n\n2\nSun\nDinner\n\n\n3\nSun\nDinner\n\n\n4\nSun\nDinner\n\n\n...\n...\n...\n\n\n239\nSat\nDinner\n\n\n240\nSat\nDinner\n\n\n241\nSat\nDinner\n\n\n242\nSat\nDinner\n\n\n243\nThur\nDinner\n\n\n\n\n244 rows × 2 columns\n\n\n\n\n\nMutating (create new column)\n\ndf_tips[\"tips_percentage\"]= df_tips[\"tip\"]/df_tips[\"total_bill\"]*100\n\ndf_tips.head()\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\ntips_percentage\n\n\n\n\n0\n16.99\n1.01\nFemale\nNo\nSun\nDinner\n2\n8.49\nChristy Cunningham\n3560325168603410\nSun2959\n5.944673\n\n\n1\n10.34\n1.66\nMale\nNo\nSun\nDinner\n3\n3.45\nDouglas Tucker\n4478071379779230\nSun4608\n16.054159\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\nSun4458\n16.658734\n\n\n3\n23.68\n3.31\nMale\nNo\nSun\nDinner\n2\n11.84\nNathaniel Harris\n4676137647685994\nSun5260\n13.978041\n\n\n4\n24.59\n3.61\nFemale\nNo\nSun\nDinner\n4\n6.15\nTonya Carter\n4832732618637221\nSun2251\n14.680765\n\n\n\n\n\n\n\n\n\nrenaming column\n\ndf_tips.rename(columns={\"tips_percentage\": \"tips_%\"}, inplace=True)\ndf_tips.head()\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\nPayment ID\ntips_%\n\n\n\n\n0\n16.99\n1.01\nFemale\nNo\nSun\nDinner\n2\n8.49\nChristy Cunningham\n3560325168603410\nSun2959\n5.944673\n\n\n1\n10.34\n1.66\nMale\nNo\nSun\nDinner\n3\n3.45\nDouglas Tucker\n4478071379779230\nSun4608\n16.054159\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\nSun4458\n16.658734\n\n\n3\n23.68\n3.31\nMale\nNo\nSun\nDinner\n2\n11.84\nNathaniel Harris\n4676137647685994\nSun5260\n13.978041\n\n\n4\n24.59\n3.61\nFemale\nNo\nSun\nDinner\n4\n6.15\nTonya Carter\n4832732618637221\nSun2251\n14.680765\n\n\n\n\n\n\n\n\n\nrelocate columns\n\n#relocate tips_percentage_% column to the rightmost\ncols = list(df_tips.columns)\ncols = [cols[-1]]+ cols[:-2]\n\ndf_tips = df_tips[cols]\n\n\ndf_tips\n\n\n\n\n\n\n\n\ntips_%\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\nprice_per_person\nPayer Name\nCC Number\n\n\n\n\n0\n5.944673\n16.99\n1.01\nFemale\nNo\nSun\nDinner\n2\n8.49\nChristy Cunningham\n3560325168603410\n\n\n1\n16.054159\n10.34\n1.66\nMale\nNo\nSun\nDinner\n3\n3.45\nDouglas Tucker\n4478071379779230\n\n\n2\n16.658734\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n7.00\nTravis Walters\n6011812112971322\n\n\n3\n13.978041\n23.68\n3.31\nMale\nNo\nSun\nDinner\n2\n11.84\nNathaniel Harris\n4676137647685994\n\n\n4\n14.680765\n24.59\n3.61\nFemale\nNo\nSun\nDinner\n4\n6.15\nTonya Carter\n4832732618637221\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n239\n20.392697\n29.03\n5.92\nMale\nNo\nSat\nDinner\n3\n9.68\nMichael Avila\n5296068606052842\n\n\n240\n7.358352\n27.18\n2.00\nFemale\nYes\nSat\nDinner\n2\n13.59\nMonica Sanders\n3506806155565404\n\n\n241\n8.822232\n22.67\n2.00\nMale\nYes\nSat\nDinner\n2\n11.34\nKeith Wong\n6011891618747196\n\n\n242\n9.820426\n17.82\n1.75\nMale\nNo\nSat\nDinner\n2\n8.91\nDennis Dixon\n4375220550950\n\n\n243\n15.974441\n18.78\n3.00\nFemale\nNo\nThur\nDinner\n2\n9.39\nMichelle Hardin\n3511451626698139\n\n\n\n\n244 rows × 11 columns"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul1.html#export-dataframe-ke-csv",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul1.html#export-dataframe-ke-csv",
    "title": "Modul 1 Sains Data: Pengenalan Pandas, Transformasi Data",
    "section": "Export DataFrame ke CSV",
    "text": "Export DataFrame ke CSV\n\ndf_tips.to_csv(\"tips_modified.csv\")"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul1.html",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul1.html",
    "title": "Modul 1 Persamaan Diferensial Numerik: Pengenalan GNU Octave",
    "section": "",
    "text": "Kembali ke Persamaan Diferensial Numerik\nOctave adalah software dan bahasa pemrograman yang umum digunakan dalam analisis numerik. Syntax pada Octave kompatibel dengan MATLAB, bahkan script file dari Octave juga menggunakan ekstensi yang sama (.m). Pada praktikum ini, akan dijelaskan tentang penggunaan Octave dan pengaplikasiannya dalam Persamaan Diferensial Numerik.\nPastikan Octave telah terinstal pada computer kalian. Kalian dapat mengunduh Octave di https://www.gnu.org/software/octave/download\nAlternatif untuk macOS: https://octave-app.org/"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul1.html#operasi-variabel-matriks",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul1.html#operasi-variabel-matriks",
    "title": "Modul 1 Persamaan Diferensial Numerik: Pengenalan GNU Octave",
    "section": "Operasi, Variabel, Matriks",
    "text": "Operasi, Variabel, Matriks\nSetelah terinstal, akan ada dua jenis launcher, yaitu “Octave (GUI)” dan “Octave (CLI)”. Jalankan “Octave (GUI)”, lalu akan muncul jendela seperti ini:\n\nSecara default, Terdapat 4 sub-jendela, yaitu File Explorer, Workspace, Command History, dan Command Window (dll.)\n\nFile Explorer berisi path yang dituju pada address bar. File Explorer berguna untuk membuka file .m ataupun file-file lain tanpa harus membuka Windows Explorer.\nWorkspace berisi data tentang variabel yang didefinisikan saat menjalankan pemrograman nantinya. Data-data yang disajikan berupa identitas dari tiap variabel, seperti nama, kelas, dimensi, value, dan atribut.\nCommand History berisi Riwayat dari semua command yang dijalankan pada Command Window.\nCommand Window sebenarnya mempunyai 3 sub-jendela lain yang dapat ditukar ataupun ditumpuk.\n\nCommand Window adalah command line utama dari Octave dan digunakan untuk menjalankan semua kode maupun program dari Octave. Untuk menjalankan kode dari Command Window, ketikkan kode yang diinginkan, lalu tekan Enter.\nDocumentation berisi dokumentasi dari Octave, seperti tutorial, detail dari fungsi-fungsi built-in, penerapan, dll.\nVariable Editor berguna untuk mengubah variabel yang ada di Workspace. Variable Editor berbentuk baris dan kolom sehingga memudahkan untuk membuat matriks.\nEditor adalah jendela scripting utama dari Octave. Script yang dibuat di Editor dapat disimpan dalam file ekstensi .m dan dijalankan dengan Command Window ataupun dengan menekan F5.\n\n\n\nAritmatika Standar\nOctave dapat digunakan untuk kalkulasi numerik dasar. Octave mengenal operator aritmatika (+, -, *, /), operator pangkat (^) (berbeda dengan kebanyakan Bahasa pemrograman), fungsi eksponen dan logaritma (exp, log), dan fungsi trigonometri (sin, cos, …). Kalkulasi pada Octave juga bekerja pada bilangan real ataupun imajiner (I, j). Beberapa konstanta, seperti bilangan Euler (e) dan bilangan pi (pi), sudah pre-defined pada Octave. Anda juga dapat menambahkan komentar pada kode dengan menggunakan persen (%).\n\n1 + 2 %Operasi Aritmatika Standar\n\nans = 3\n\n\nTerlihat bahwa value hasil running disimpan dalam suatu variabel yang bernama ans. Variabel ini akan menyimpan seluruh hasil dari ekspresi yang di-input dan akan ditimpa jika ada ekspresi baru yang menyimpan hasil.\nEkspresi tersebut juga dapat disimpan ke suatu variabel.\n\na = 2 + 3\n\na = 5\n\n\nTerlihat bahwa output menunjukkan variabel a, bukan ans.\nJika tidak ingin print hasilnya, beri titik koma (;) pada akhir line…\n\na = 1 + 3;\n\n… dan jika ingin menampilkan lagi outputnya, cukup memanggil variabelnya.\n\na\n\na = 4\n\n\nUntuk update variabel, dapat menggunakan cara ini:\n\na = a + 6 %Variabel a ditambah 6\n\na = 10\n\n\n\na = a / 5 %Dapat disesuaikan dengan operator lainnya\n\na = 2\n\n\n\na -= 6 %Idem\n\na = -4\n\n\n\na *= -5 %Idem\n\na = 20\n\n\n\na = \"ayam\" %Update variabel a dengan nilai baru\n\na = ayam\n\n\nSebagai tambahan, tidak seperti Mathematica, value pada Octave menggunakan presisi mesin (machine precision), sehingga beberapa hasil yang ditampilkan mungkin saja tidak bulat. Sebagai contoh, akan ditampilkan hasil dari \\(e^{i \\pi}\\) (Identitas Euler)\n\ne^(i*pi)\n\nans = -1.0000e+00 + 1.2246e-16i\n\n\nHarusnya tepat -1, tetapi ternyata ada sedikit error \\(10^{-16}\\).\n\n\nPendefinisian dan Pemanggilan Matriks\nMatriks ataupun vektor akan menjadi hal esensial untuk analisis numerik. Untuk mendefinisikan matriks, gunakan kurung siku ([]) untuk membuat matriks. Elemen pada baris dipisahkan dengan koma (,), dan elemen pada kolom dipisahkan dengan titik koma (;)\nContoh:\n\nA = [1, 2, 3; 4, 5, 6; 7, 8, 9]\n\n\n\n\nA\n1\n2\n3\n\n\n1\n1\n2\n3\n\n\n2\n4\n5\n6\n\n\n3\n7\n8\n9\n\n\n\n\n\nCatatan: Sebenarnya kita dapat mendefinisikan kode untuk matriks tanpa menggunakan koma ataupun titik koma. Cukup dengan menggunakan spasi dan Enter…\n\nB = [1 2 3\n4 5 6\n7 8 9]\n\n\n\n\nB\n1\n2\n3\n\n\n1\n1\n2\n3\n\n\n2\n4\n5\n6\n\n\n3\n7\n8\n9\n\n\n\n\n\n… namun hal ini dapat menyebabkan beberapa ambiguitas dalam pendefinisian beberapa elemen dalam matriks. Disarankan tetap menggunakan titik dan titik koma, kecuali untuk matriks yang isinya simpel.\nSelanjutnya, untuk memanggil elemen dari matriks, gunakan tanda kurung ((a, b)) dengan a adalah indeks baris dan b adalah indeks kolom. Catatan: Indeks pada Octave dimulai dari 1.\n\nA(2, 3)\n\nans = 6\n\n\nJika ingin memanggil lebih dari satu elemen, kalian dapat menggunakan titik dua (a:b) ataupun kurung siku ([a,b]). Titik dua (a:b) akan memanggil elemen baris/kolom dari a hingga b…\nContoh: Memanggil elemen baris ke-2 dan kolom dari 2 hingga 3:\n\nA(2, 2:3)\n\n\n\n\nans\n1\n2\n\n\n1\n5\n6\n\n\n\n\n\n… dan kurung siku ([a,b]) akan memanggil elemen baris/kolom ke-a dan ke-b.\nContoh: Memanggil elemen baris ke-1 dan kolom ke-1 dan ke-3:\n\nA(1, [1,3])\n\n\n\n\nans\n1\n2\n\n\n1\n1\n3\n\n\n\n\n\nContoh: Memanggil elemen baris ke-1 dan ke-3, dan kolom dari 2 hingga 3:\n\nA([1,3], 2:3)\n\n\n\n\nans\n1\n2\n\n\n1\n2\n3\n\n\n2\n8\n9\n\n\n\n\n\n\n\nOperasi Matriks\nMatriks yang telah dibuat dapat diubah isinya, ditranspos, diinvers, dll. Untuk mengubah isi dari matriks, dapat menggunakan pemanggilan indeks.\n\nA\n\n\n\n\nA\n1\n2\n3\n\n\n1\n1\n2\n3\n\n\n2\n4\n5\n6\n\n\n3\n7\n8\n9\n\n\n\n\n\n\nA(2, 3) = 5 %Mengubah satu elemen\n\n\n\n\nA\n1\n2\n3\n\n\n1\n1\n2\n3\n\n\n2\n4\n5\n5\n\n\n3\n7\n8\n9\n\n\n\n\n\n\nA(2, [1,3]) = 3 %Mengubah banyak elemen dengan 1 nilai \n\n\n\n\nA\n1\n2\n3\n\n\n1\n1\n2\n3\n\n\n2\n3\n5\n3\n\n\n3\n7\n8\n9\n\n\n\n\n\nMengubah banyak elemen dengan nilai yang bersesuaian dengan tempat:\n\nA(1:3, 1) = [2; 4; 8]\n\n\n\n\nA\n1\n2\n3\n\n\n1\n2\n2\n3\n\n\n2\n4\n5\n3\n\n\n3\n8\n8\n9\n\n\n\n\n\nJika posisi salah, akan dicoba dengan transpose nya:\n\nA(1:3, 3) = [2, 4, 8] \n\n\n\n\nA\n1\n2\n3\n\n\n1\n2\n2\n2\n\n\n2\n4\n5\n4\n\n\n3\n8\n8\n8\n\n\n\n\n\nJika masih tidak bisa dengan transpose nya, akan ada pesan error\n\nA(2, 1:3) = [2, 4]\n\nExecution exception: =: nonconformant arguments (op1 is 1x3, op2 is 1x2)\n\n\nOperasi matriks pada Octave mengikuti operasi pada aljabar linear biasa, dimana perkalian matriks harus mengikuti baris dan kolom yang sesuai.\n\nA * 2 %Perkalian scalar\n\n\n\n\nans\n1\n2\n3\n\n\n1\n4\n4\n4\n\n\n2\n8\n10\n8\n\n\n3\n16\n16\n16\n\n\n\n\n\n\nA + B %Penjumlahan matriks \n\n\n\n\nans\n1\n2\n3\n\n\n1\n3\n4\n5\n\n\n2\n8\n10\n10\n\n\n3\n15\n16\n17\n\n\n\n\n\n\nA * B %Perkalian matriks \n\n\n\n\nans\n1\n2\n3\n\n\n1\n24\n30\n36\n\n\n2\n52\n65\n78\n\n\n3\n96\n120\n144\n\n\n\n\n\nUntuk memanggil transpos dari matriks, gunakan tanda petik satu (’), dan untuk memanggil invers dari matriks, gunakan fungsi inv. Jika matriks yang diinvers singular (det = 0), maka akan muncul pesan peringatan dan elemennya akan menjadi Inf.\n\nD = [1, 2, 3; 4, 5, 6]\n\n\n\n\nD\n1\n2\n3\n\n\n1\n1\n2\n3\n\n\n2\n4\n5\n6\n\n\n\n\n\n\nD' %Transpos dari matriks \n\n\n\n\nans\n1\n2\n\n\n1\n1\n4\n\n\n2\n2\n5\n\n\n3\n3\n6\n\n\n\n\n\n\nE = [1, 2; 5, 7]\n\n\n\n\nE\n1\n2\n\n\n1\n1\n2\n\n\n2\n5\n7\n\n\n\n\n\n\ninv(E) %Invers dari matriks\n\n\n\n\nans\n1\n2\n\n\n1\n-2.33333\n0.666667\n\n\n2\n1.66667\n-0.333333\n\n\n\n\n\n\nF = [1, 2; 4, 8]\n\n\n\n\nF\n1\n2\n\n\n1\n1\n2\n\n\n2\n4\n8\n\n\n\n\n\n\ninv(F) %Contoh invers untuk matriks singular\n\nwarning: matrix singular to machine precision\n\n\n\n\n\nans\n1\n2\n\n\n1\ninf\ninf\n\n\n2\ninf\ninf\n\n\n\n\n\nOctave juga mempunyai operator khusus, yaitu (\\). Operator ini adalah operator “pembagian” matriks. Pendefinisian untuk A \\ b ekuivalen dengan inv(A) * b. Operasi ini sangat berguna untuk penyelesaian sistem linear. Sebagai contoh, misalkan kita mempunyai sistem linear berikut:\n\\[4x_1 - 2x_2 = 20\\] \\[-5x_1 - 5x_2 = -10\\]\nJika kita ubah dalam bentuk perkalian matriks \\(Ax=b\\) (dengan penyelesaian \\(x = A^{-1} b\\)), diperoleh:\n\\[A = \\begin{pmatrix}\n    4 & -2 \\\\\n    -5 & -5\n\\end{pmatrix}\\]\n\\[x = \\begin{pmatrix}\n    x_1 \\\\\n    x_2\n\\end{pmatrix}\\]\n\\[b = \\begin{pmatrix}\n    20 \\\\\n    -10\n\\end{pmatrix}\\]\nJika dimasukkan ke Octave, kita akan memperoleh:\n\nA = [4, -2; -5, -5]\n\n\n\n\nA\n1\n2\n\n\n1\n4\n-2\n\n\n2\n-5\n-5\n\n\n\n\n\n\nb = [20; -10]\n\n\n\n\nb\n1\n\n\n1\n20\n\n\n2\n-10\n\n\n\n\n\n\nx = inv(A) * b\n\n\n\n\nx\n1\n\n\n1\n4\n\n\n2\n-2\n\n\n\n\n\n\nx = A \\ b\n\n\n\n\nx\n1\n\n\n1\n4\n\n\n2\n-2\n\n\n\n\n\nDiproleh \\(x_1 = 4\\) dan \\(x_2 = -2\\).\n\n\nVariable Editor\nSesuai namanya, Variable Editor digunakan untuk mengubah nilai dari suatu variabel. Untuk menggunakannya, double-click variabel yang ingin diubah pada workspace. Variabel tersebut akan muncul pada tab Variable Editor (atau tekan Ctrl+6).\n\nAntarmuka dari Variable Editor mirip seperti Excel, sehingga kalian bisa langsung mengubah nilai matriks yang ada dengan memilih kotak yang berisi elemen yang ingin diubah, lalu mengetik nilai yang baru.\nJika kalian memberi nilai baru pada kotak kosong di Variable Editor, matriks tersebut akan mengalami perubahan bentuk, menyesuaikan dengan posisi elemen nilai baru tersebut.\n\nPada gambar di atas, nilai baru dimasukkan pada baris 5 kolom 5, sehingga matriks tersebut berubah menjadi 5x5.\nUntuk menghapus suatu baris/kolom, klik kanan angka baris/kolom (atau pilih lebih dari satu baris/kolom dengan Ctrl/Shift), lalu klik Delete rows/Delete columns.\n\n\n\nFile dan Editor untuk kode\nSejauh ini, kita menggunakan command line untuk menjalankan kode. Namun, kalian juga bisa melakukan scripting seperti pemrograman pada umumnya dengan menggunakan Editor. Untuk memunculkan Editor, klik Tab Editor (atau tekan Ctrl+4).\n\nUntuk membuat file baru, klik New Script (ikon kertas). Kalian juga dapat membuka file .m (file MATLAB) yang tersimpan dengan double-click file tersebut di File Explorer pada Octave ataupun di Windows Explorer (atau /root atau lainnya).\nScript bekerja layaknya Bahasa pemrograman biasa. Kalian dapat menjalankan script yang telah dibuat dengan menekan F5 (jika file belum di-save, akan muncul kotak dialog untuk save). Output dari script tersebut akan muncul pada Command Window.\nCatatan: Jika kalian menggunakan Editor, disarankan mengubah layout dari Editor dan Command Window untuk mempermudah melihat output (tidak perlu ganti tab). Untuk memindahkan layout, klik dan drag tulisan Editor pada bagian atas jendela Editor ke tempat yang diinginkan. Contohnya seperti gambar berikut:"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul1.html#pemrograman-dan-fungsi",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul1.html#pemrograman-dan-fungsi",
    "title": "Modul 1 Persamaan Diferensial Numerik: Pengenalan GNU Octave",
    "section": "Pemrograman dan Fungsi",
    "text": "Pemrograman dan Fungsi\n\nI/O\nDalam pemrograman, seringkali pengguna diminta memberi suatu input, entah suatu nilai, string, dll., ke program, lalu program tersebut akan menggunakan input tersebut sebagai nilai dari suatu variabel. Hal ini juga dapat dilakukan pada Octave. Untuk membuat Octave meminta input dari user, gunakan syntax input(prompt), dengan prompt adalah string yang berisi pesan dalam input.\n\nA = input(\"Masukkan suatu angka: \")\n\nMasukkan suatu angka:  135\n\n\nA = 135\n\n\nJika tidak ingin membuat pesan input, cukup isi “” sebagai prompt.\n\nA = input(\"\")\n\n 100\n\n\nA = 100\n\n\nPerlu diketahui bahwa input yang diberikan pengguna akan dievaluasi sebagai ekspresi. Jadi, bisa saja input yang diberikan akan dievaluasi sebagai kode Octave (sebagaimana eval(input(...)) pada Python). Sebagai contoh, jika kita memasukkan operasi bilangan pada input…\n\nB = input(\"Operasi bilangan: \")\n\nOperasi bilangan:  2 + 3\n\n\nB = 5\n\n\n…, maka operasi tersebut akan dievaluasi dan memberikan hasil operasinya. Jika kita memasukkan kode Octave, seperti meng-assign suatu variabel…\n\nC = input(\"Assign variabel: \")\n\nAssign variabel:  x = 25\n\n\nC = 25\n\n\n…, maka nilai dari variabel yagn di-assign akan masuk ke variabel input…\n\nx\n\nx = 25\n\n\n… sekaligus variabel yang di-assign di dalam input. Jika kalian ingin agar input yang dimasukkan tidak dievaluasi, input tersebut dapat diubah terlebih dahulu menjadi string.\n\nD = input(\"Masukkan string: \")\n\nMasukkan string:  \"x + 25\"\n\n\nD = x + 25\n\n\n\ntypeinfo(D) % untuk menanyakan tipe data variabel\n\nans = string\n\n\nTernyata tipe data string, sesuai yang kita harapkan.\nCara lain, bisa juga dengan menambah argumen pada input() menjadi input(prompt, “s”). Jika menambahkan argumen, maka apapun input yang kalian masukkan akan menjadi string tanpa perlu menggunakan tanda petik.\n\nE = input(\"Masukkan string: \", \"s\")\n\nMasukkan string:  x + 25\n\n\nE = x + 25\n\n\n\ntypeinfo(E)\n\nans = sq_string\n\n\nNote: Syntax input() sebaiknya digunakan sebagai nilai dari suatu variabel.\nSelain menggunakan input(), kita juga bisa menggunakan syntax menu(title, op1, op2, …). Syntax tersebut akan memunculkan kotak dialog dengan judul title dan pilihan op1, op2, dst. (sesuai yang dimasukkan). Syntax ini sangat berguna untuk program-program interaktif karena mempunyai GUI sendiri.\nF = menu(\"Pilih buah favorit.\", \"Apel\", \"Jeruk\", \"Pisang\")\n\nF = 1\nTergantung pilihan kalian, variabel yang mengandung menu() akan diisi bilangan dari 1 hingga n tergantung banyaknya pilihan. Dalam contoh di atas, pilihan “Apel” akan memberi nilai 1, “Jeruk” akan memberi nilai 2, dan “Pisang” akan memberi nilai 3. Jika kalian memilih Cancel atau membuat pilihan yang tidak valid, maka variabelnya akan diberi nilai 0.\nUntuk output, mungkin cukup untuk memanggil variabel itu sendiri, seperti…\n\nC\n\nC = 25\n\n\n…, namun kalian juga bisa hanya memunculkan nilai dari variabelnya tanpa sekaligus memunculkan variabel tersebut dengan menggunakan syntax disp(). Syntax ini digunakan jika yang di-output hanya suatu variabel atau string simpel, dll.\n\ndisp(C)\n\n25\n\n\n\ndisp(\"Simple string\")\n\nSimple string\n\n\nJika yang ingin dimunculkan adalah pesan yang membutuhkan banyak formatting, kalian bisa menggunakan syntax printf(). Syntax tersebut dapat melakukan formatting pesan agar dapat menerima variabel selain string.\nNote: Gunakan \\n pada akhir string di printf() agar program memasukkan “Enter”.\n\nx = input(\"Masukkan angka: \"); printf(\"Anda memasukkan angka %d\\n\", x)\n\nMasukkan angka:  25Anda memasukkan angka 25\n\n\nPada contoh di atas, kita ingin agar variabel x dapat di-output bersama dengan pesan string. Kita menggunakan %d agar nilai x dapat di-print sebagai bilangan desimal. Jika variabelnya berisi string, maka gunakan %s. Jika variabelnya berisi float, gunakan %f untuk print dalam bentuk desimal, atau %.nf untuk sekaligus mengatur angka di belakang koma sebanyak n.\n\nprintf(\"pi = %f\\n\", pi)\n\npi = 3.141593\n\n\n\nprintf(\"pi = %.12f\\n\", pi)\n\npi = 3.141592653590\n\n\nJika float tersebut ingin di-print dalam notasi saintifik, gunakan %e atau %E. Keduanya hanya berbeda di hasil output yang berupa E (besar) ataupun e (kecil).\n\nprintf(\"euler = %e\\n\", e)\n\neuler = 2.718282e+00\n\n\n\nprintf(\"euler = %E\\n\", e)\n\neuler = 2.718282E+00\n\n\nJika ingin print karakter persen itu sendiri (%), gunakan %%.\nJika ada lebih dari satu formatting di satu printf(), maka variabelnya juga harus dimasukkan secara berurutan.\n\nnama = input(\"Masukkan nama: \", \"s\");\n\nMasukkan nama:  Burden\n\n\n\nminuman_fav = input(\"Minuman favorit: \", \"s\");\n\nMinuman favorit:  Kopi\n\n\n\nharga = input([\"Harga \" minuman_fav \": \"]);\n\nHarga Kopi:  25000\n\n\n\nprintf(\"%s suka %s seharga Rp%d\", nama, minuman_fav, harga);\n\nBurden suka Kopi seharga Rp25000\n\n\n\n\nStruktur Bersyarat: If-Else-Elseif, Switch-Case\nSeperti halnya bahas pemrograman, Octave pun juga memiliki conditional statements (pernyataan kondisional, pernyataan bersyarat, atau struktur bersyarat). Secara umum, conditional statement pada Octave berbentuk:\ncond\n  body\nendcond\n\nPada potongan kode di atas, cond adalah jenis conditional statement yagn digunakan, bisa berupa if, for, dan lainnya, body berisi kode yang dijalankan ketika cond terpenuhi, dan endcond adalah bagian penutup dari conditional statement, bisa berupa endif, endfor, dan lainnya tergantung cond apa yang digunakan.\n\nOperasi dasar yang digunakan pada conditional statements adalah operasi perbandingan, dimana pada dasarnya, dua atau lebih nilai dibandingkan dengan operator dan dicek apakah memenuhi atau tidak. Jika memenuhi, maka nilainya 1, dan jika tidak, maka nilainya 0. Ada 6 operator dasar untuk perbandingan:\n\n* sama dengan (==)\n* lebih dari (&gt;)\n* kurang dari (&lt;)\n* lebih dari atau sama dengan (&gt;=)\n* kurang dari atau sama dengan (&lt;=)\n* tidak sama dengan (!= atau ~=)\n\n::: {.cell vscode='{\"languageId\":\"octave\"}' execution_count=72}\n``` {.octave .cell-code}\n2 &lt; 3\n\nans = 1\n\n:::\n\n4 == 5\n\nans = 0\n\n\nSelain operator di atas, ada juga syntax untuk perbandingan:\n\nisequal(a, b, c, …)\nmengecek apakah a, b, dan c semuanya sama.\nstrcmp(s1, s2)\nmengecek apakah s1 dan s2 adalah string yang sama.\nstrncmp(s1, s2, n)\nmengecek apakah n karakter pertama pada s1 dan s2 sama.\nstrcmpi(s1, s2)\nmirip strcmp(), namun tidak case-sensitive.\nstrncmpi(s1, s2, n)\nmirip strncmp(), namun tidak case-sensitive.\n\n\nisequal(1, 3, 5)\n\nans = 0\n\n\n\nstrcmp(\"ayam\", \"Ayam\")\n\nans = 0\n\n\n\nstrcmpi(\"ayam\", \"Ayam\")\n\nans = 1\n\n\n\nstrncmp(\"sayamakan\", \"saya makan\", 4)\n\nans = 1\n\n\nBerikut beberapa jenis conditional statement pada Octave. Kode-kode ini akan ditulis di editor dan output akan dipisahkan oleh &gt;&gt;\n\nIf, Elseif, Else\nIf adalah conditional statement dasar dalam decision-making melalui perbandingan nilai. If memiliki 3 bentuk. Bentuk pertama:\nif (cond)\n  body\nendif\nBentuk ini adalah bentuk paling simpel dalam menggunakan if. Jika cond bernilai 1, maka body dieksekusi, dan sebaliknya. Contoh:\n\nx = input(\"Masukkan nilai x: \");\nif (x &gt; 0)\n  printf(\"%d adalah bilangan positif\\n\", x);\nendif\n\nMasukkan nilai x:  2525 adalah bilangan positif\n\n\nSeringkali if dipasangkan dengan else. Untuk itu, cukup menyelipkan bagian else layaknya if, sehingga menjadi:\nif (cond)\n  body1;\nelse\n  body2;\nendif\nContoh:\n\nx = input(\"Masukkan x: \");\nif mod(x, 2) == 0\n  printf(\"x genap\\n\");\nelse\n  printf(\"x ganjil\\n\");\nendif\n\nMasukkan x:  5x ganjil\n\n\nKita pun juga dapat membuat lebih dari 2 condition selain if dan else. Cukup tambahkan bagian elseif. Kita dapat menambahkan berapapun banyaknya elseif sesuka hati, selama bagian akhirnya adalah else.\nif (cond1)\n  body1;\nelseif (cond2)\n  body2;\nelse\n  body3;\nendif\n\n\nSwitch-Case\nUntuk beberapa kasus, sudah jelas jika kita menggunakan model kode seperti di atas. Namun, terkadang kita ingin membuat program berjalan sesuai input, dan jika menggunakan if-else, kodenya akan terlihat jelek. Maka, kita juga bisa menggantinya dengan kode switch. Bentuk umum dari switch adalah:\nswitch (var)\n  case nilai1\n    body1;\n  case nilai2\n    body2;\n  otherwise\n    body3;\nendswitch\nPada kode di atas, var akan dicocokkan dengan nilai1, nilai2, dst. yang sesuai. Jika tidak ada yang sesuai, kode akan masuk ke bagian otherwise. Layaknya elseif, kita juga dapat menambahkan berapapun banyaknya case sesuka hati, selama terdapat paling tidak satu case (bahkan bagian otherwise opsional).\nContoh:\n\npilihan = input(\"Masukkan pilihan warna (1-4): \");\nswitch (pilihan)\n  case 1\n    printf(\"Warna merah\")\n  case 2\n    printf(\"Warna hijau\")\n  case 3\n    printf(\"Warna biru\")\n  case 4\n    printf(\"Warna kuning\")\n  otherwise\n    printf(\"Input tidak valid\")\nendswitch\n\nMasukkan pilihan warna (1-4):  4Warna kuning\n\n\nJika case berisi array, kode akan masuk case tersebut jika var sesuai dengan salah satu elemen di array tersebut.\n\n\n\nStruktur Berulang: For, While-Do, Do-Until\n\nFor Loop\nBentuk umum dari for adalah:\nfor var = expr\n  body;\nendfor\nBiasanya isi dari expr adalah a:b, yang menyebabkan var diiterasi dari a hingga b. Secara umum, for akan meng-assign tiap kolom pada expr ke var (bentuk range a:b secara umum adalah vektor baris, sehingga iterasi kolom pada a:b adalah dari a hingga b). Contoh:\n\nfib = ones(1, 10); % matriks 1x10 berisi nilai 1 semua\nfor i = 3:10\n  fib(i) = fib(i-1) + fib(i-2);\nendfor\ndisp(fib)\n\n    1    1    2    3    5    8   13   21   34   55\n\n\nKarena iterasinya antar kolom, maka jika expr adalah suatu matriks, maka var akan diiterasi sebagai vektor kolom.\n\nfor i = [1, 2, 3; 4, 5, 6; 7, 8, 9]\n  disp(i)\nendfor\n\n   1\n   4\n   7\n   2\n   5\n   8\n   3\n   6\n   9\n\n\n\n\nWhile Loop\nBentuk umum dari while adalah:\nwhile (cond)\n  body;\nendwhile\nSerupa dengan if, while akan menjalankan body jika cond bernilai taknol. Namun, akan diulang terus hingga cond bernilai nol, baru berhenti.\nContoh:\n\nfib = ones(1, 10);\ni = 3;\nwhile (i &lt;= 10)\n  fib(i) = fib(i-1) + fib(i-2);\n  i++;\nendwhile\ndisp(fib)\n\n    1    1    2    3    5    8   13   21   34   55\n\n\nPada contoh di atas, penting untuk memasukkan bagian i++ agar suatu saat nilai i akan lebih dari 10. Hati-hati menggunakan while, karena dapat mengakibatkan infinite loop.\n\n\nDo-Until\nBentuk umum dari do-until adalah:\ndo\n  body\nuntil (cond)\nSekilas, do terlihat serupa dengan while. Yang membedakannya adalah do akan terus menjalankan body ketika cond bernilai 0 dan berhenti ketika cond bernilai taknol. Kondisi cond pada do juga berada di akhir, sehingga body pasti akan dijalankan paling tidak sekali. Perbedaan kecil selanjutnya adalah do tidak memakai enddo seperti layaknya endif, endwhile, dan sejenisnya.\nContoh:\n\nfib = ones(1, 10);\ni = 2;\ndo\n  i++;\n  fib(i) = fib(i-1) + fib(i-2);\nuntil (i == 10)\ndisp(fib)\n\n    1    1    2    3    5    8   13   21   34   55\n\n\n\n\nBreak, Continue\nbreak dan continue adalah dua statement yang digunakan dan hanya digunakan dalam loop. Statement break akan langsung mengeluarkan program dari loop, sedangkan continue akan langsung menuju iterasi selanjutnya tanpa menyelesaikan sisa kode pada badan loop.\nContoh perbedaan break dan continue:\n\na = [];\nfor i = 1:10\n  if mod(i, 5) == 0\n    break;\n  endif\n  a = [a, i];\nendfor\ndisp(a)\n\n   1   2   3   4\n\n\n\na = [];\nfor i = 1:10\n  if mod(i, 5) == 0\n    continue;\n  endif\n  a = [a, i];\nendfor\ndisp(a)\n\n   1   2   3   4   6   7   8   9"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul1.html#function-file-dan-script-file",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul1.html#function-file-dan-script-file",
    "title": "Modul 1 Persamaan Diferensial Numerik: Pengenalan GNU Octave",
    "section": "Function File dan Script File",
    "text": "Function File dan Script File\nSebelum kita lanjutkan, kita harus terlebih dahulu mengetahui tentang function file dan script file.\nFunction file adalah file yang dapat digunakan oleh Octave untuk memanggil fungsi yang telah didefinisikan di dalamnya. Function file ini berguna jika kalian ingin menggunakan fungsi tersebut secara berkala.\nScript file adalah file yang berisi kumpulan perintah Octave, layaknya script pemrograman. Script file berguna untuk pemrograman dan menjalankan/menyimpan suatu urutan perintah, sehingga bisa dijalankan kembali nantinya. Untuk selanjutnya, script file akan disebut “program”.\nPermasalahannya, kedua jenis file tersebut mempunyai ekstensi yang serupa (.m), namun function file tidak dapat dijalankan layaknya program.\nMisal kita mempunyai fungsi yang ingin disimpan dalam program bernama testfile.m (untuk sekarang kita akan abaikan dulu maksud dari tiap bagian dari fungsi ini. Intinya fungsi ini akan menampilkan variabel message yang kita masukkan.\n\nfunction test(message)\n  printf(\"%s\\n\", message);\nendfunction\n\ntest(\"PDNum\");\n\nPDNum\n\n\nJika program tersebut dijalankan, akan muncul pesan peringatan…\nwarning: function name 'test' does not agree with function filename...\n…dan mungkin saja akan diikuti error lain. Jika kalian ingin membuat program, jangan gunakan function di line pertama yang dieksekusi.\nSekarang kita modifikasi testfile.m di atas.\n\n1;\nfunction test(message)\n  printf(\"%s\\n\", message);\nendfunction\n\ntest(\"PDNum\");\n\nPDNum\n\n\nDi sini, kita menambahkan line yang tidak berpengaruh apa-apa dalam program kita sebelum line pendefinisian fungsi. Untuk membedakan function file dengan program, Octave mengecek perintah pertama yang dieksekusi. Jika perintah tersebut adalah pendefinisian fungsi, maka file tersebut akan dianggap sebagai function file, dan jika bukan, maka file tersebut akan dianggap sebagai program.\nSekarang kita masuk ke fungsi, pendefinisian, dan embel-embelnya. Fungsi adalah suatu bagian dari program yang nantinya akan dipanggil. Fungsi sangat berguna jika bagian program tersebut nantinya akan digunakan berkali-kali. Fungsi juga berguna agar pengorganisasian kode program lebih bagus. Syntax untuk pendefinisian fungsi adalah:\nfunction name\n  body\nendfunction\nPotongan kode di atas akan membuat fungsi name dengan body adalah isi dari fungsi tersebut. Untuk memanggil fungsi tersebut, cukup dengan memanggil name. Contoh:\n\nfunction bangun\n  printf(\"BANGUN!!!\\n\");\nendfunction\n\nbangun;\n\nBANGUN!!!\n\n\nKalian juga bisa menambahkan argumen (biasanya berupa variabel), ke fungsinya.\n\nfunction bangun(message)\n  printf(\"%s\\n\", message);\nendfunction\n\nbangun(\"BANGUN WOY!!!\");\n\nBANGUN WOY!!!\n\n\nPada kedua contoh di atas, fungsinya tidak benar-benar memberikan suatu value, melainkan hanya sekedar output. Dalam kebanyakan kasus, kita menggunakan fungsi agar bisa mendapatkan suatu nilai yang dapat di-assign ke suatu variabel. Agar kita bisa mendapatkan value, maka kita harus meng-assign variabel untuk return. Strukturnya menjadi:\nfunction retval = name (args)\n  body\nendfunction\nretval adalah variabel lokal (namanya tidak harus retval) yang akan digunakan sebagai return value sehingga dapat di-assign. retval bisa berupa variabel, jika kita ingin me-return satu value, ataupun bisa berupa list dari variabel jika ingin me-return lebih dari satu value.\nContoh return satu nilai:\n\nfunction x = kuadratkan(a)\n  x = a^2;\nendfunction\n\ny = kuadratkan(5);\ndisp(y);\n\n25\n\n\nContoh return lebih dari satu nilai:\n\nfunction [y1, y2] = jumlah_kali(x1, x2)\n  y1 = x1 + x2;\n  y2 = x1 * x2;\nendfunction\n\nz1, z2 = jumlah_kali(5, 7);\ndisp(z);\n\n12"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/modul0.html",
    "href": "semuahalaman/modulprak/2024/genap/metnum/modul0.html",
    "title": "Modul 0 Metode Numerik: Review Python, NumPy",
    "section": "",
    "text": "Kembali ke Metode Numerik\nCatatan: Modul 0 ini adalah modul pengantar/review yang tidak dibahas ketika sesi praktikum.\nBerikut topik-topik yang akan dibahas pada Modul 0 ini:\n\nReview Python\n\nOperasi, Variabel, dan Comment\nString dan Formatting\nInput nilai\nList\nPernyataan Kondisional\nLooping\n\nError Handling\nNumPy\n\n\n\n\n\nDi Python, kita bisa melakukan beberapa operasi aritmetika, menggunakan simbol sebagai berikut:\n(+) untuk penjumlahan\n(-) untuk pengurangan\n(*) untuk perkalian\n(/) untuk pembagian\n(**) untuk pangkat\n(%) untuk operasi mod atau modulo (sisa pembagian)\n(//) untuk operasi div (hasil bagi tanpa sisa)\n\nprint(5 + 2)\nprint(5 - 2)\nprint(5 * 2)\nprint(5 / 2)\nprint(5 ** 2)\nprint(5 % 2)\nprint(5 // 2)\n\n7\n3\n10\n2.5\n25\n1\n2\n\n\nSeandainya kita tidak menggunakan print untuk menampilkan hasil perhitungan,\n\n5 + 2\n\n7\n\n\n\n5 - 2\n5 * 2\n\n10\n\n\nmaka hanya hasil dari baris terakhir yang akan ditampilkan. Oleh karena itu, sangat disarankan untuk SELALU menuliskan print, termasuk untuk baris terakhir, agar modifikasi program menjadi lebih mudah dan cepat, apalagi ketika ingin menambah baris baru.\nPerhatikan bahwa tanda % sudah dikhususkan untuk modulo, sehingga artinya BUKAN PERSEN, ya! Persen dalam Python bisa dituliskan sebagai pembagian dengan 100 (sesuai definisi persen), misalnya untuk 50% atau 21%:\n\nprint(50/100)\nprint(21/100)\n\n0.5\n0.21\n\n\nKita bisa menyimpan nilai (termasuk hasil perhitungan) ke suatu tempat penyimpanan yang disebut variabel. Tiap variabel memiliki nama tersendiri, yang kita definisikan sendiri. Proses penyimpanan nilai ke suatu variabel disebut proses assignment, yang memiliki syntax (cara penulisan) sebagai berikut:\ncontoh_variabel = 23\ndi mana 23 adalah contoh nilai yang ingin dipasang ke contoh variabel yang kita beri nama “contoh_variabel”. Untuk assignment, tanda = cukup ditulis sekali saja, ya!\nKemudian, kita bisa menggunakan print untuk menampilkan isi variabel tersebut.\n\ncontoh_variabel = 23\nprint(contoh_variabel)\n\n23\n\n\nJangan sampai salah ketik, ya! Penggunaan huruf besar/kecil perlu diperhatikan, jangan sampai tertukar.\n\nprint(contoh_Variabel)\n\nNameError: name 'contoh_Variabel' is not defined\n\n\nKita mendapat error “name ‘contoh_Variabel’ is not defined”, artinya ‘contoh_Variabel’ itu tidak didefinisikan, karena Python menganggap itu berbeda dengan contoh_variabel yang memang sudah kita definisikan. Tentu kita tetap bisa mendefinisikannya:\n\ncontoh_variabel = 23\ncontoh_Variabel = 45\nprint(contoh_variabel)\nprint(contoh_Variabel)\n\n23\n45\n\n\nAda beberapa hal yang dilarang dalam penamaan variabel.\n\nNama variabel hanya boleh terdiri dari huruf, angka, dan tanda _\nNama variabel tidak boleh diawali angka\n\nContoh penamaan yang valid (boleh, bisa diterima):\n\nabc1 = 21\nxyz9000 = 3\n\nKarena valid, variabel berhasil tersimpan dengan baik, sehingga bisa dilihat isinya:\n\nprint(abc1)\nprint(xyz9000)\n\n21\n3\n\n\nContoh penamaan yang dilarang (akan menghasilkan error):\n\n999nama = 10\n\nSyntaxError: invalid decimal literal (678666226.py, line 1)\n\n\nSelain keterangan spesifik seperti “invalid decimal literal”, kita juga bisa mendapatkan keterangan error yang lebih umum yaitu “invalid syntax” atau “syntax tidak valid”. Karena terjadi error, proses assignment tidak berhasil, sehingga kita tidak bisa melihat isinya karena variabel tersebut memang gagal didefinisikan:\n\nprint(999nama)\n\nSyntaxError: invalid decimal literal (4165728206.py, line 1)\n\n\nKita juga bisa menggunakan variabel, seperti mengoperasikan variabel untuk menghasilkan nilai baru:\n\nprint(abc1 * 10)\nprint(abc1 / xyz9000)\n\n210\n7.0\n\n\nBahkan, kita bisa memasang hasil operasi tersebut ke variabel lain:\n\nhasil_bagi = abc1 / xyz9000\nprint(hasil_bagi)\n\n7.0\n\n\nPerhatikan potongan kode berikut.\n\na = 6\nb = 3\nprint(a / b)\na, b = b, a\nprint(a / b)\n\n2.0\n0.5\n\n\nPada baris 4, kita menukar nilai pada variabel a dan b. Python bisa meng-assign lebih dari 1 variabel dalam 1 baris, cukup dengan memisahkan tiap variabel dan nilai dengan , (tanda koma).\n\nx, y, z = 0, 1, 2\nprint(x)\nprint(y)\nprint(z)\n\n0\n1\n2\n\n\nWalaupun cara tersebut berlaku untuk sebanyak-banyaknya variabel, pada umumnya lebih baik melakukan assignment satu variabel per baris saja agar kode tetap mudah dibaca, apalagi fitur tersebut hanya ada di bahasa pemrograman Python.\nPenukaran variabel tetap bisa dilakukan sesuai cara yang dipelajari di mata kuliah Algortma dan Pemrograman, yaitu dengan bantuan variabel yang bisa dinamakan temp atau semacamnya (variabel dummy yang “tidak penting” dan hanya digunakan untuk bantuan sementara saja):\n\nc = 10\nd = 5\nprint(c/d)\ntemp = d\nd = c\nc = temp\nprint(c/d)\n\n2.0\n0.5\n\n\natau sama saja,\n\nc = 10\nd = 5\nprint(c/d)\ntemp = c\nc = d\nd = temp\nprint(c/d)\n\n2.0\n0.5\n\n\nTerkadang, program yang kita buat bisa menjadi rumit, sehingga kita perlu menambahkan semacam penjelasan atau catatan supaya orang lain bisa lebih memahami kode kita. Di Python, kita bisa menambahkan comment atau semacam catatan di samping kanan tiap baris (atau pada baris tersendiri), dimulai dengan tanda #\n\nprint(\"Selamat pagi\") # buat apa? gapapa iseng aja\n# print(\"Selamat siang\")\nprint(\"Selamat sore\") # wah dari pagi langsung sore\n\nSelamat pagi\nSelamat sore\n\n\nPython tidak memperhatikan comment sama sekali. Adanya fitur comment hanyalah untuk membantu kita sebagai programmer.\n\n\n\nDi Python, selain tipe data numerik/angka, ada juga yang dinamakan “string”, yaitu kumpulan huruf/karakter/kata, yang bisa diawali dan diakhiri dengan tanda petik ’ atau tanda kutip ”\n\nmata_kuliah = \"Metode Numerik\"\ndepartemen = 'matematika'\ngelar = 'S1'\nprint(mata_kuliah)\nprint(departemen)\nprint(gelar)\n\nMetode Numerik\nmatematika\nS1\n\n\nPenggunaan tanda petik ataupun tanda kutip itu sama-sama valid, yang penting konsisten.\nSuatu string bisa dicek “panjang”nya, atau jumlah karakter di dalam string (termasuk spasi, koma, dan sebagainya), dengan len (artinya length):\n\npanjang1 = len(mata_kuliah)\npanjang2 = len(departemen)\npanjang3 = len(gelar)\nprint(panjang1)\nprint(panjang2)\nprint(panjang3)\n\n14\n10\n2\n\n\nString juga bisa digabung dengan semacam “penjumlahan” atau penggabungan (juga disebut string concatenation):\n\nnama_depan = \"Johan\"\nnama_tengah = \"Frederik\"\nnama_belakang = \"Steffensen\"\nprint(nama_depan + nama_belakang)\nprint(nama_depan + nama_tengah + nama_belakang)\n\nJohanSteffensen\nJohanFrederikSteffensen\n\n\nPerhatikan bahwa, pada ketiga string yang kita definisikan, tidak ada spasi, sehingga dalam penggabungannya itu juga tidak ada spasi.\nPenggabungan string tidak harus antar variabel, bisa juga antar nilai, atau bahkan antara variabel dengan nilai.\n\nprint(\"Halo! Nama saya \" + nama_depan)\n\nHalo! Nama saya Johan\n\n\nKita telah menggabungkan string “Halo! Nama saya” dengan variabel nama_depan (perhatikan bahwa string tersebut diakhiri satu spasi).\n\nprint(nama_belakang + \", \" + nama_depan + \" \" + nama_tengah)\n\nSteffensen, Johan Frederik\n\n\nDi sini, kita telah menggabungkan variabel nama_belakang dengan suatu string yang tediri dari dua karakter (yaitu koma dan spasi), yang kemudian digabungkan dengan variabel nama_depan, kemudian suatu string yang terdiri dari spasi saja, dan akhirnya dengan variabel nama_tengah.\nPenjumlahan yang dilakukan secara berulang kali adalah perkalian. Begitu juga untuk string:\n\nprint(3 * \"Belajar\")\nprint(\"Panik\" * 5)\n\nBelajarBelajarBelajar\nPanikPanikPanikPanikPanik\n\n\nKita juga bisa mengubah atau mengkonversi nilai selain string (seperti angka) agar menjadi string dan bisa digabungkan juga, menggunakan str. Contohnya,\n\nnilai_semester = 2\nstring_semester = str(nilai_semester)\nprint(\"Saya masih semester \" + string_semester)\n\nSaya masih semester 2\n\n\nSeandainya kita tidak mengkonversi nilai tersebut, akan terjadi error:\n\nnilai_semester = 2\nprint(\"Saya masih semester \" + nilai_semester)\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\nPython hanya paham cara menggabungkan string dengan string, bukan string dengan selain string, sehingga kita harus mengkonversi nilai tersebut menjadi string terlebih dahulu.\nSebaliknya, kita juga bisa “menghilangkan tanda petik/kutip” dari suatu string (misalnya untuk mengkonversi kembali menjadi angka), dengan eval.\n\nangka_semester = eval(string_semester)\nsemester_atas = 2 + angka_semester\nstring_atas = str(semester_atas)\nprint(\"Dia sudah semester \" + string_atas)\n\nDia sudah semester 4\n\n\nSeandainya tidak digunakan eval,\n\nsemester_atas =  2 + string_semester\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\nLagi-lagi, Python tidak paham penjumlahan antara bilangan dengan string.\nAda cara lain untuk memadukan nilai string dengan variabel yang berisi string, yaitu dengan yang namanya string formatting. Sejak Python 3.6, ada yang namanya f-strings, yang diawali dengan huruf “f” tepat sebelum penulisan string. Pada suatu f-string, kita bisa menggunakan kurung kurawal yaitu { dan } untuk menggantikan isi string dengan suatu variabel, yang nama variabelnya kita masukkan ke dalam kurung kurawal tersebut.\nMisalnya, kita bisa memasukkan nilai variabel mata_kuliah di dalam suatu f-string, seperti berikut:\n\nprint(f\"Saya sedang mengikuti praktikum {mata_kuliah}.\")\n\nSaya sedang mengikuti praktikum Metode Numerik.\n\n\nTentu, kita bisa menyisipkan lebih dari satu variabel.\n\nprint(f\"Saya sedang mengikuti praktikum {mata_kuliah} untuk mendapatkan gelar {gelar}.\")\n\nSaya sedang mengikuti praktikum Metode Numerik untuk mendapatkan gelar S1.\n\n\nSelain menggunakan f-string, kita juga bisa menggunakan .format() pada akhir string (fitur ini sudah ada sejak Python 3.0), dengan syntax sebagai berikut:\n\nprint(\"Saya sedang mengikuti praktikum {0} untuk mendapatkan gelar {1}\".format(mata_kuliah, gelar))\n\nSaya sedang mengikuti praktikum Metode Numerik untuk mendapatkan gelar S1\n\n\nAgar kode lebih mudah dibaca,\n\nkalimat = \"Saya sedang mengikuti praktikum {0} untuk mendapatkan gelar {1}\".format(mata_kuliah, gelar)\nprint(kalimat)\n\nSaya sedang mengikuti praktikum Metode Numerik untuk mendapatkan gelar S1\n\n\nPerhatikan bahwa, dengan cara .format(), kita harus mengisi tempat penyisipan dengan {0}, {1}, {2}, dan seterusnya tergantung banyaknya penyisipan, kemudian variabel-variabel yang ingin disisipkan itu baru ditempel di akhir, yaitu di dalam kurung .format().\nLagi-lagi, kedua cara sama-sama valid, yang penting konsisten. Ketika hendak menggunakan f-string, jangan tiba-tiba mengetik .format() pada akhir f-string.\nSebagai tambahan, kita bisa menyisipkan angka, dan kita juga bisa mempersingkat penulisannya menjadi beberapa angka di belakang koma, misalnya cukup 7 angka di belakang koma:\n\nakar_dua = 2**(1/2)\nprint(\"Akar dua bernilai kurang lebih {0:.7f}\".format(akar_dua))\nprint(\"atau lebih tepatnya {0}\".format(akar_dua))\n\nAkar dua bernilai kurang lebih 1.4142136\natau lebih tepatnya 1.4142135623730951\n\n\nBeberapa link (pengayaan, tidak wajib) untuk mempelajari string formatting lebih lanjut:\n\nhttps://www.w3schools.com/python/ref_string_format.asp\nhttps://realpython.com/python-string-formatting/\n\n\n\n\nSelain mengeluarkan output atau menampilkan nilai, Python juga bisa menerima nilai (yang kemudian dipasangkan ke variabel), menggunakan input(pesan), di mana pesan yang ada di dalam kurung itu bisa berisi pertanyaan yang ingin ditanyakan, atau keterangan yang diminta:\n\nangkatan = input(\"Masukkan angkatan: \")\nprint(\"Anda angkatan \" + angkatan)\n\nMasukkan angkatan: 2022\nAnda angkatan 2022\n\n\nPerhatikan bahwa input telah masuk dalam bentuk string, sehingga bisa langsung digabungkan dengan string lainnya. Karena masih berbentuk string, operasi aritmetika tidak sesuai harapan:\n\nangka = input(\"Masukkan angka: \")\ndobel = angka / 2\nprint(\"Setelah dibagi dua, angka tersebut menjadi \" + str(dobel))\n\nMasukkan angka: 24\n\n\nTypeError: unsupported operand type(s) for /: 'str' and 'int'\n\n\nTerjadi error karena operasi pembagian tidak bisa dilakukan pada string. Oleh karena itu, kita juga perlu eval agar nilai yang masuk itu dihilangkan tanda petik/kutipnya agar tidak lagi berbentuk string.\n\nangka = eval(input(\"Masukkan angka: \"))\ndobel = angka / 2\nprint(\"Setelah dibagi dua, angka tersebut menjadi \" + str(dobel))\n\nMasukkan angka: 24\nSetelah dibagi dua, angka tersebut menjadi 12.0\n\n\nKombinasi eval(input(pesan)) akan sering digunakan selama praktikum Metode Numerik.\n\n\n\nSuatu list bisa menyimpan beberapa nilai sekaligus, yang masing-masing disebut elemen dari list tersebut. Pendefinisiannya menggunakan kurung siku, di mana tiap elemen dituliskan di dalamnya, saling dipisahkan dengan koma:\n\nbuah = [\"apel\", \"pisang\", \"jeruk\"]\nprint(buah)\n\n['apel', 'pisang', 'jeruk']\n\n\nTiap elemen memiliki posisi atau indeks (index). Di Python, indeks dimulai dari 0 (nol). Kita bisa memeriksa elemen pada indeks ke-sekian di list, dengan menuliskan nama list tersebut, diikuti dengan kurung siku yang berisi indeks ke berapa yang ingin dilihat nilainya.\n\nprint(buah[0])\nprint(buah[1])\nprint(buah[2])\n\napel\npisang\njeruk\n\n\nSuatu list bisa berisi beragam tipe data, tidak hanya string tetapi juga angka, atau bahkan keduanya sekaligus.\n\ndata_diri = [\"Guido van Rossum\", 1956, \"Belanda\", \"Pembuat bahasa pemrograman Python\"]\nprint(\"Nama: \" + data_diri[0])\nprint(\"Tahun kelahiran: \" + str(data_diri[1]))\nprint(\"Kewarganegaraan: \" + data_diri[2])\nprint(\"Dikenal sebagai: \" + data_diri[3])\n\nNama: Guido van Rossum\nTahun kelahiran: 1956\nKewarganegaraan: Belanda\nDikenal sebagai: Pembuat bahasa pemrograman Python\n\n\nKita dapat menambahkan elemen baru pada akhir list menggunakan .append()\n\nprima = [2, 3, 5]\nprint(prima)\nprima.append(7)\nprint(prima)\n\n[2, 3, 5]\n[2, 3, 5, 7]\n\n\n\n\n\nSeringkali kita dihadapi oleh beberapa kondisi. Misalkan pada metode Bisection, kalian perlu mengecek apakah nilai fungsi di ujung-ujung intervalnya berbeda tanda atau tidak. Jika tidak, metode tidak bisa berjalan. Maka, kita perlu menggunakan pernyataan kondisional.\nTerdapat tiga pernyataan kondisional: * If…else berguna jika hanya ada satu kondisi yang perlu dicek, dan perlu ada aksi yang dijalankan jika kondisi tidak terpenuhi. * If…elif berguna jika ada lebih dari satu kondisi yang perlu dicek, dan tidak ada aksi yang dijalankan apabila semua kondisi tidak terpenuhi. * If…elif…else berguna jika ada lebih dari satu kondisi yang perlu dicek, dan perlu ada aksi yang dijalankan jika kondisi tidak terpenuhi.\nAdvanced note: Ada pernyataan kondisional lain, yaitu try…except, naum akan dijelaskan pada bagian selanjutnya\n\nx = eval(input('Masukkan bilangan: '))\nif x &lt; 0:\n    print('Haha')\nelif x &gt;= 0 and x &lt;= 4:\n    print('Hehe')\nelse:\n    print('Hoho')\n\nMasukkan bilangan: 2\nHehe\n\n\n\n\n\nKebanyakan metode pada Metnum bersifat iteratif, artinya algoritmanya dijalankan berulang hingga tercapai batas tertentu (biasanya terdapat nilai toleransi antara aproksimasi dengan nilai eksaknya). Looping pada Python biasanya menggunakan for loop dan while loop.\nfor loop digunakan ketika kita mengetahui berapa kali kita harus mengulang perintah. Beberapa cara untuk for loop:\n\nfor i in range(a, b, n) : Loop ini akan membuat for loop berjalan mulai dari a hingga b - 1 dengan step sebesar n. Argumen n bersifat opsional dengan nilai default 1. Jika menggunakan range(b), maka bisa dianggap a = 0.\nfor i in list atau for i in string : Loop ini akan membuat for loop mengiterasikan tiap elemen list atau karakter string yang akan disimpan pada i. while loop digunakan ketika ada syarat tertentu yang harus dipenuhi untuk mengulang perintah tersebut.\nwhile cond : Loop ini akan membuat while loop berjalan selama cond bernilai True . Berhati-hatilah dalam menggunakan while loop. Pastikan kondisi yang dimasukkan akan bisa bernilai False . Jika tidak, maka kode akan stuck di infinite loop.\n\nAdvanced note: range() sejatinya adalah fungsi yang mengoutput list angka dengan aturan seperti di atas.\n\nprint('FOR LOOP EXAMPLE 1')\nfor i in range(3):\n    print('Print 3 kali')\nprint('FOR LOOP EXAMPLE 2')\nfor i in range(1, 4):\n    print(2 * i)\nprint('FOR LOOP EXAMPLE 3')\nfor i in range(1, 10, 3):\n    print('Angka sekarang:', i)\nprint('FOR LOOP EXAMPLE 4')\nfor i in [1, 4, 8, 2]:\n    print(i)\nprint('FOR LOOP EXAMPLE 5')\nfor i in 'mondstad':\n    if i == 'd':\n        print(i)\nprint('WHILE LOOP EXAMPLE')\ni = 0\nwhile i &lt;= 5:\n    print('Hati-hati while')\n    i += 1\nprint('While iteration DONE')\n\nFOR LOOP EXAMPLE 1\nPrint 3 kali\nPrint 3 kali\nPrint 3 kali\nFOR LOOP EXAMPLE 2\n2\n4\n6\nFOR LOOP EXAMPLE 3\nAngka sekarang: 1\nAngka sekarang: 4\nAngka sekarang: 7\nFOR LOOP EXAMPLE 4\n1\n4\n8\n2\nFOR LOOP EXAMPLE 5\nd\nd\nWHILE LOOP EXAMPLE\nHati-hati while\nHati-hati while\nHati-hati while\nHati-hati while\nHati-hati while\nHati-hati while\nWhile iteration DONE\n\n\n\n\n\n\nMisalkan kalian membuat program tentang menghitung kebalikan dari suatu bilangan bulat. Tentu bilangan selain nol memiliki kebalikan. Namun, apa yang terjadi jika kalian memasukkan 0 sebagai input? Pasti error.\nError pada program mengakibatkan program terhenti di tengah-tengah, sehingga belum semua baris dieksekusi. Mungkin tidak berpengaruh banyak jika programnya digunakan untuk sendiri, namun seandainya kalian membuat program yang digunakan untuk mengatur server perusahaan, entah apa jadinya kalau programnya error.\nUntuk itu, terdapat cara untuk mengatasi error tersebut. Di Python, kalian dapat menggunakan try…except . Ini adalah penyataan kondisional serupa dengan if…else , namun pengecekan dilakukan pada bagian try . Jika pada bagian tersebut tidak ada masalah yang menyebabkab error, maka bagian except tidak dijalankan. Sebaliknya, jika error, maka bagian except akan dijalankan. Ada beberapa macam error di Python:\n\nZeroDivisionError : Error ini keluar jika terdapat pembagian dengan nol.\nValueError : Error ini keluar jika tipe data yang dimasukkan tidak bisa diproses karena tidak sesuai. dll. Silahkan cari di Google :)\n\nAdvanced note: Kalian dapat mengecek tipe data pada python dengan fungsi type() .\n\ntry:\n    x = int(input('Masukkan integer taknol: '))\n    print(1 / x)\nexcept:\n    print('Yhaa programnya error :(')\n\nMasukkan integer taknol: 0\nYhaa programnya error :(\n\n\n\n\n\nNumPy adalah package Python yng sangat multifungsi. Kita akan menggunakan NumPy untuk membuat array yang elemennya hanya mempunyai satu tipe data. NumPy juga mempunyai fungsi fungsi seperti sin, cos, log, dll.\nMula-mula, kita perlu meng-import package NumPy.\n\nimport numpy as np\n\nJika pada langkah ini kalian menemukan error, kemungkinan besar kalian belum mempunyai package NumPy terinstal. Jika kalian menggunakan Jupyter Notebook atau Spyder melalui Anaconda, kalian bisa mencoba mengikuti langkah ini:\n\nBuka Anaconda Prompt\nKetik conda install numpy (Jika tidak berhasil gunakan pip install numpy )\nTunggu hingga proses mengunduh selesai.\n\nAlternatif yang lebih mudah adalah langsung mengetik pip install numpy (atau !pip install numpy dengan tanda seru) pada Jupyter Notebook (bisa juga pada Google Colaboratory), kemudian menutup dan membuka kembali Jupyter Notebook:\n\npip install numpy\n\nRequirement already satisfied: numpy in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (1.24.2)\nNote: you may need to restart the kernel to use updated packages.\n\n\n\n!pip install numpy\n\nRequirement already satisfied: numpy in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (1.24.2)\n\n\nNumpy Array\nSeperti yang sudah dikatakan sebelumnya, list bukan array karena dapat diisi dengan berbagai tipe data. Kalau begitu, bagaimana array yang benar? Di NumPy, ada fungsi bernama array yang berfungsi mengubah list menjadi array.\n\nA = np.array([True, 4, 7.5, 'Jean'])\nB = np.array([5, 6.2])\nC = np.array([4, 2, -1, -3])\ntype(A)\n\nnumpy.ndarray\n\n\nTerlihat tipe data dari A bukan list, melainkan numpy.ndarray. Perhatikan juga bahwa kita mengisi list yang akan dijadikan array A dan B dengan beragam tipe data…\n\nprint(A)\nprint(B)\nprint(C)\n\n['True' '4' '7.5' 'Jean']\n[5.  6.2]\n[ 4  2 -1 -3]\n\n\n…maka tipe datanya akan berubah menjadi sama. Karena NumPy array hanya bisa menyimpan satu tipe data, maka jika tipenya berbeda akan berubah. Urutan pengecekannya adalah string , float , integer , boolean (tipe data boolean menyimpan nilai 1 jika True dan 0 jika False ).\nKita juga dapat membuat array 2 dimensi seperti matriks, dan jika di-print, maka outputnya juga seperti matriks.\n\nP = np.array([[1, 2],[-1, 0]])\nQ = np.array([[4, -1],[5, 0]])\nR = np.array([[1, 2, 4, 5], [-1, -8, 9, 11], [3, -2, -4, 6]])\n\nDi sini kalian juga bisa melakukan indexing dan slicing seperti halnya pada liat.\n\nprint(A[0])\nprint(B[-1])\nprint(P[0])\nprint(Q[0,1])\nprint()\nprint(A[2:])\nprint(R[1:])\nprint(R[1, 2:])\nprint(R[:, 1])\n\nTrue\n6.2\n[1 2]\n-1\n\n['7.5' 'Jean']\n[[-1 -8  9 11]\n [ 3 -2 -4  6]]\n[ 9 11]\n[ 2 -8 -2]\n\n\nOperasi aritmatika juga dapat diterapkan pada NumPy array. Operasi aritmatika antar dua NumPy array akan dilakukan secara element- wise, artinya operasinya dilakukan tiap elemen (bukan seperti dot product pada aljabar linear).\n\nA = np.array([1, 4, 7, 10])\nB = np.array([1, 2, 3, 4])\n#operasi pada array\nprint(A + B)\nprint(A - B)\nprint(A * B)\nprint(A / B)\nprint(A % B)\nprint(A // B)\nprint(A ** B)\n\n[ 2  6 10 14]\n[0 2 4 6]\n[ 1  8 21 40]\n[1.         2.         2.33333333 2.5       ]\n[0 0 1 2]\n[1 2 2 2]\n[    1    16   343 10000]\n\n\nSelain itu, operasi aritmatika juga bisa dilakukan dengan skalar. Operasi aritmatika antara NumPy array dengan suatu skalar akan dilakukan seolah-olah skalar tersebut adalah NumPy array berukuran sama yang isinya skalar tersebut. Istilahnya biasanya disebut Broadcasting\n\nprint(A + 2)\nprint(C * 3)\nprint(P ** 2)\nprint(1 / R)\n\n[ 3  6  9 12]\n[12  6 -3 -9]\n[[1 4]\n [1 0]]\n[[ 1.          0.5         0.25        0.2       ]\n [-1.         -0.125       0.11111111  0.09090909]\n [ 0.33333333 -0.5        -0.25        0.16666667]]"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/modul0.html#review-python",
    "href": "semuahalaman/modulprak/2024/genap/metnum/modul0.html#review-python",
    "title": "Modul 0 Metode Numerik: Review Python, NumPy",
    "section": "",
    "text": "Di Python, kita bisa melakukan beberapa operasi aritmetika, menggunakan simbol sebagai berikut:\n(+) untuk penjumlahan\n(-) untuk pengurangan\n(*) untuk perkalian\n(/) untuk pembagian\n(**) untuk pangkat\n(%) untuk operasi mod atau modulo (sisa pembagian)\n(//) untuk operasi div (hasil bagi tanpa sisa)\n\nprint(5 + 2)\nprint(5 - 2)\nprint(5 * 2)\nprint(5 / 2)\nprint(5 ** 2)\nprint(5 % 2)\nprint(5 // 2)\n\n7\n3\n10\n2.5\n25\n1\n2\n\n\nSeandainya kita tidak menggunakan print untuk menampilkan hasil perhitungan,\n\n5 + 2\n\n7\n\n\n\n5 - 2\n5 * 2\n\n10\n\n\nmaka hanya hasil dari baris terakhir yang akan ditampilkan. Oleh karena itu, sangat disarankan untuk SELALU menuliskan print, termasuk untuk baris terakhir, agar modifikasi program menjadi lebih mudah dan cepat, apalagi ketika ingin menambah baris baru.\nPerhatikan bahwa tanda % sudah dikhususkan untuk modulo, sehingga artinya BUKAN PERSEN, ya! Persen dalam Python bisa dituliskan sebagai pembagian dengan 100 (sesuai definisi persen), misalnya untuk 50% atau 21%:\n\nprint(50/100)\nprint(21/100)\n\n0.5\n0.21\n\n\nKita bisa menyimpan nilai (termasuk hasil perhitungan) ke suatu tempat penyimpanan yang disebut variabel. Tiap variabel memiliki nama tersendiri, yang kita definisikan sendiri. Proses penyimpanan nilai ke suatu variabel disebut proses assignment, yang memiliki syntax (cara penulisan) sebagai berikut:\ncontoh_variabel = 23\ndi mana 23 adalah contoh nilai yang ingin dipasang ke contoh variabel yang kita beri nama “contoh_variabel”. Untuk assignment, tanda = cukup ditulis sekali saja, ya!\nKemudian, kita bisa menggunakan print untuk menampilkan isi variabel tersebut.\n\ncontoh_variabel = 23\nprint(contoh_variabel)\n\n23\n\n\nJangan sampai salah ketik, ya! Penggunaan huruf besar/kecil perlu diperhatikan, jangan sampai tertukar.\n\nprint(contoh_Variabel)\n\nNameError: name 'contoh_Variabel' is not defined\n\n\nKita mendapat error “name ‘contoh_Variabel’ is not defined”, artinya ‘contoh_Variabel’ itu tidak didefinisikan, karena Python menganggap itu berbeda dengan contoh_variabel yang memang sudah kita definisikan. Tentu kita tetap bisa mendefinisikannya:\n\ncontoh_variabel = 23\ncontoh_Variabel = 45\nprint(contoh_variabel)\nprint(contoh_Variabel)\n\n23\n45\n\n\nAda beberapa hal yang dilarang dalam penamaan variabel.\n\nNama variabel hanya boleh terdiri dari huruf, angka, dan tanda _\nNama variabel tidak boleh diawali angka\n\nContoh penamaan yang valid (boleh, bisa diterima):\n\nabc1 = 21\nxyz9000 = 3\n\nKarena valid, variabel berhasil tersimpan dengan baik, sehingga bisa dilihat isinya:\n\nprint(abc1)\nprint(xyz9000)\n\n21\n3\n\n\nContoh penamaan yang dilarang (akan menghasilkan error):\n\n999nama = 10\n\nSyntaxError: invalid decimal literal (678666226.py, line 1)\n\n\nSelain keterangan spesifik seperti “invalid decimal literal”, kita juga bisa mendapatkan keterangan error yang lebih umum yaitu “invalid syntax” atau “syntax tidak valid”. Karena terjadi error, proses assignment tidak berhasil, sehingga kita tidak bisa melihat isinya karena variabel tersebut memang gagal didefinisikan:\n\nprint(999nama)\n\nSyntaxError: invalid decimal literal (4165728206.py, line 1)\n\n\nKita juga bisa menggunakan variabel, seperti mengoperasikan variabel untuk menghasilkan nilai baru:\n\nprint(abc1 * 10)\nprint(abc1 / xyz9000)\n\n210\n7.0\n\n\nBahkan, kita bisa memasang hasil operasi tersebut ke variabel lain:\n\nhasil_bagi = abc1 / xyz9000\nprint(hasil_bagi)\n\n7.0\n\n\nPerhatikan potongan kode berikut.\n\na = 6\nb = 3\nprint(a / b)\na, b = b, a\nprint(a / b)\n\n2.0\n0.5\n\n\nPada baris 4, kita menukar nilai pada variabel a dan b. Python bisa meng-assign lebih dari 1 variabel dalam 1 baris, cukup dengan memisahkan tiap variabel dan nilai dengan , (tanda koma).\n\nx, y, z = 0, 1, 2\nprint(x)\nprint(y)\nprint(z)\n\n0\n1\n2\n\n\nWalaupun cara tersebut berlaku untuk sebanyak-banyaknya variabel, pada umumnya lebih baik melakukan assignment satu variabel per baris saja agar kode tetap mudah dibaca, apalagi fitur tersebut hanya ada di bahasa pemrograman Python.\nPenukaran variabel tetap bisa dilakukan sesuai cara yang dipelajari di mata kuliah Algortma dan Pemrograman, yaitu dengan bantuan variabel yang bisa dinamakan temp atau semacamnya (variabel dummy yang “tidak penting” dan hanya digunakan untuk bantuan sementara saja):\n\nc = 10\nd = 5\nprint(c/d)\ntemp = d\nd = c\nc = temp\nprint(c/d)\n\n2.0\n0.5\n\n\natau sama saja,\n\nc = 10\nd = 5\nprint(c/d)\ntemp = c\nc = d\nd = temp\nprint(c/d)\n\n2.0\n0.5\n\n\nTerkadang, program yang kita buat bisa menjadi rumit, sehingga kita perlu menambahkan semacam penjelasan atau catatan supaya orang lain bisa lebih memahami kode kita. Di Python, kita bisa menambahkan comment atau semacam catatan di samping kanan tiap baris (atau pada baris tersendiri), dimulai dengan tanda #\n\nprint(\"Selamat pagi\") # buat apa? gapapa iseng aja\n# print(\"Selamat siang\")\nprint(\"Selamat sore\") # wah dari pagi langsung sore\n\nSelamat pagi\nSelamat sore\n\n\nPython tidak memperhatikan comment sama sekali. Adanya fitur comment hanyalah untuk membantu kita sebagai programmer.\n\n\n\nDi Python, selain tipe data numerik/angka, ada juga yang dinamakan “string”, yaitu kumpulan huruf/karakter/kata, yang bisa diawali dan diakhiri dengan tanda petik ’ atau tanda kutip ”\n\nmata_kuliah = \"Metode Numerik\"\ndepartemen = 'matematika'\ngelar = 'S1'\nprint(mata_kuliah)\nprint(departemen)\nprint(gelar)\n\nMetode Numerik\nmatematika\nS1\n\n\nPenggunaan tanda petik ataupun tanda kutip itu sama-sama valid, yang penting konsisten.\nSuatu string bisa dicek “panjang”nya, atau jumlah karakter di dalam string (termasuk spasi, koma, dan sebagainya), dengan len (artinya length):\n\npanjang1 = len(mata_kuliah)\npanjang2 = len(departemen)\npanjang3 = len(gelar)\nprint(panjang1)\nprint(panjang2)\nprint(panjang3)\n\n14\n10\n2\n\n\nString juga bisa digabung dengan semacam “penjumlahan” atau penggabungan (juga disebut string concatenation):\n\nnama_depan = \"Johan\"\nnama_tengah = \"Frederik\"\nnama_belakang = \"Steffensen\"\nprint(nama_depan + nama_belakang)\nprint(nama_depan + nama_tengah + nama_belakang)\n\nJohanSteffensen\nJohanFrederikSteffensen\n\n\nPerhatikan bahwa, pada ketiga string yang kita definisikan, tidak ada spasi, sehingga dalam penggabungannya itu juga tidak ada spasi.\nPenggabungan string tidak harus antar variabel, bisa juga antar nilai, atau bahkan antara variabel dengan nilai.\n\nprint(\"Halo! Nama saya \" + nama_depan)\n\nHalo! Nama saya Johan\n\n\nKita telah menggabungkan string “Halo! Nama saya” dengan variabel nama_depan (perhatikan bahwa string tersebut diakhiri satu spasi).\n\nprint(nama_belakang + \", \" + nama_depan + \" \" + nama_tengah)\n\nSteffensen, Johan Frederik\n\n\nDi sini, kita telah menggabungkan variabel nama_belakang dengan suatu string yang tediri dari dua karakter (yaitu koma dan spasi), yang kemudian digabungkan dengan variabel nama_depan, kemudian suatu string yang terdiri dari spasi saja, dan akhirnya dengan variabel nama_tengah.\nPenjumlahan yang dilakukan secara berulang kali adalah perkalian. Begitu juga untuk string:\n\nprint(3 * \"Belajar\")\nprint(\"Panik\" * 5)\n\nBelajarBelajarBelajar\nPanikPanikPanikPanikPanik\n\n\nKita juga bisa mengubah atau mengkonversi nilai selain string (seperti angka) agar menjadi string dan bisa digabungkan juga, menggunakan str. Contohnya,\n\nnilai_semester = 2\nstring_semester = str(nilai_semester)\nprint(\"Saya masih semester \" + string_semester)\n\nSaya masih semester 2\n\n\nSeandainya kita tidak mengkonversi nilai tersebut, akan terjadi error:\n\nnilai_semester = 2\nprint(\"Saya masih semester \" + nilai_semester)\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\nPython hanya paham cara menggabungkan string dengan string, bukan string dengan selain string, sehingga kita harus mengkonversi nilai tersebut menjadi string terlebih dahulu.\nSebaliknya, kita juga bisa “menghilangkan tanda petik/kutip” dari suatu string (misalnya untuk mengkonversi kembali menjadi angka), dengan eval.\n\nangka_semester = eval(string_semester)\nsemester_atas = 2 + angka_semester\nstring_atas = str(semester_atas)\nprint(\"Dia sudah semester \" + string_atas)\n\nDia sudah semester 4\n\n\nSeandainya tidak digunakan eval,\n\nsemester_atas =  2 + string_semester\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\nLagi-lagi, Python tidak paham penjumlahan antara bilangan dengan string.\nAda cara lain untuk memadukan nilai string dengan variabel yang berisi string, yaitu dengan yang namanya string formatting. Sejak Python 3.6, ada yang namanya f-strings, yang diawali dengan huruf “f” tepat sebelum penulisan string. Pada suatu f-string, kita bisa menggunakan kurung kurawal yaitu { dan } untuk menggantikan isi string dengan suatu variabel, yang nama variabelnya kita masukkan ke dalam kurung kurawal tersebut.\nMisalnya, kita bisa memasukkan nilai variabel mata_kuliah di dalam suatu f-string, seperti berikut:\n\nprint(f\"Saya sedang mengikuti praktikum {mata_kuliah}.\")\n\nSaya sedang mengikuti praktikum Metode Numerik.\n\n\nTentu, kita bisa menyisipkan lebih dari satu variabel.\n\nprint(f\"Saya sedang mengikuti praktikum {mata_kuliah} untuk mendapatkan gelar {gelar}.\")\n\nSaya sedang mengikuti praktikum Metode Numerik untuk mendapatkan gelar S1.\n\n\nSelain menggunakan f-string, kita juga bisa menggunakan .format() pada akhir string (fitur ini sudah ada sejak Python 3.0), dengan syntax sebagai berikut:\n\nprint(\"Saya sedang mengikuti praktikum {0} untuk mendapatkan gelar {1}\".format(mata_kuliah, gelar))\n\nSaya sedang mengikuti praktikum Metode Numerik untuk mendapatkan gelar S1\n\n\nAgar kode lebih mudah dibaca,\n\nkalimat = \"Saya sedang mengikuti praktikum {0} untuk mendapatkan gelar {1}\".format(mata_kuliah, gelar)\nprint(kalimat)\n\nSaya sedang mengikuti praktikum Metode Numerik untuk mendapatkan gelar S1\n\n\nPerhatikan bahwa, dengan cara .format(), kita harus mengisi tempat penyisipan dengan {0}, {1}, {2}, dan seterusnya tergantung banyaknya penyisipan, kemudian variabel-variabel yang ingin disisipkan itu baru ditempel di akhir, yaitu di dalam kurung .format().\nLagi-lagi, kedua cara sama-sama valid, yang penting konsisten. Ketika hendak menggunakan f-string, jangan tiba-tiba mengetik .format() pada akhir f-string.\nSebagai tambahan, kita bisa menyisipkan angka, dan kita juga bisa mempersingkat penulisannya menjadi beberapa angka di belakang koma, misalnya cukup 7 angka di belakang koma:\n\nakar_dua = 2**(1/2)\nprint(\"Akar dua bernilai kurang lebih {0:.7f}\".format(akar_dua))\nprint(\"atau lebih tepatnya {0}\".format(akar_dua))\n\nAkar dua bernilai kurang lebih 1.4142136\natau lebih tepatnya 1.4142135623730951\n\n\nBeberapa link (pengayaan, tidak wajib) untuk mempelajari string formatting lebih lanjut:\n\nhttps://www.w3schools.com/python/ref_string_format.asp\nhttps://realpython.com/python-string-formatting/\n\n\n\n\nSelain mengeluarkan output atau menampilkan nilai, Python juga bisa menerima nilai (yang kemudian dipasangkan ke variabel), menggunakan input(pesan), di mana pesan yang ada di dalam kurung itu bisa berisi pertanyaan yang ingin ditanyakan, atau keterangan yang diminta:\n\nangkatan = input(\"Masukkan angkatan: \")\nprint(\"Anda angkatan \" + angkatan)\n\nMasukkan angkatan: 2022\nAnda angkatan 2022\n\n\nPerhatikan bahwa input telah masuk dalam bentuk string, sehingga bisa langsung digabungkan dengan string lainnya. Karena masih berbentuk string, operasi aritmetika tidak sesuai harapan:\n\nangka = input(\"Masukkan angka: \")\ndobel = angka / 2\nprint(\"Setelah dibagi dua, angka tersebut menjadi \" + str(dobel))\n\nMasukkan angka: 24\n\n\nTypeError: unsupported operand type(s) for /: 'str' and 'int'\n\n\nTerjadi error karena operasi pembagian tidak bisa dilakukan pada string. Oleh karena itu, kita juga perlu eval agar nilai yang masuk itu dihilangkan tanda petik/kutipnya agar tidak lagi berbentuk string.\n\nangka = eval(input(\"Masukkan angka: \"))\ndobel = angka / 2\nprint(\"Setelah dibagi dua, angka tersebut menjadi \" + str(dobel))\n\nMasukkan angka: 24\nSetelah dibagi dua, angka tersebut menjadi 12.0\n\n\nKombinasi eval(input(pesan)) akan sering digunakan selama praktikum Metode Numerik.\n\n\n\nSuatu list bisa menyimpan beberapa nilai sekaligus, yang masing-masing disebut elemen dari list tersebut. Pendefinisiannya menggunakan kurung siku, di mana tiap elemen dituliskan di dalamnya, saling dipisahkan dengan koma:\n\nbuah = [\"apel\", \"pisang\", \"jeruk\"]\nprint(buah)\n\n['apel', 'pisang', 'jeruk']\n\n\nTiap elemen memiliki posisi atau indeks (index). Di Python, indeks dimulai dari 0 (nol). Kita bisa memeriksa elemen pada indeks ke-sekian di list, dengan menuliskan nama list tersebut, diikuti dengan kurung siku yang berisi indeks ke berapa yang ingin dilihat nilainya.\n\nprint(buah[0])\nprint(buah[1])\nprint(buah[2])\n\napel\npisang\njeruk\n\n\nSuatu list bisa berisi beragam tipe data, tidak hanya string tetapi juga angka, atau bahkan keduanya sekaligus.\n\ndata_diri = [\"Guido van Rossum\", 1956, \"Belanda\", \"Pembuat bahasa pemrograman Python\"]\nprint(\"Nama: \" + data_diri[0])\nprint(\"Tahun kelahiran: \" + str(data_diri[1]))\nprint(\"Kewarganegaraan: \" + data_diri[2])\nprint(\"Dikenal sebagai: \" + data_diri[3])\n\nNama: Guido van Rossum\nTahun kelahiran: 1956\nKewarganegaraan: Belanda\nDikenal sebagai: Pembuat bahasa pemrograman Python\n\n\nKita dapat menambahkan elemen baru pada akhir list menggunakan .append()\n\nprima = [2, 3, 5]\nprint(prima)\nprima.append(7)\nprint(prima)\n\n[2, 3, 5]\n[2, 3, 5, 7]\n\n\n\n\n\nSeringkali kita dihadapi oleh beberapa kondisi. Misalkan pada metode Bisection, kalian perlu mengecek apakah nilai fungsi di ujung-ujung intervalnya berbeda tanda atau tidak. Jika tidak, metode tidak bisa berjalan. Maka, kita perlu menggunakan pernyataan kondisional.\nTerdapat tiga pernyataan kondisional: * If…else berguna jika hanya ada satu kondisi yang perlu dicek, dan perlu ada aksi yang dijalankan jika kondisi tidak terpenuhi. * If…elif berguna jika ada lebih dari satu kondisi yang perlu dicek, dan tidak ada aksi yang dijalankan apabila semua kondisi tidak terpenuhi. * If…elif…else berguna jika ada lebih dari satu kondisi yang perlu dicek, dan perlu ada aksi yang dijalankan jika kondisi tidak terpenuhi.\nAdvanced note: Ada pernyataan kondisional lain, yaitu try…except, naum akan dijelaskan pada bagian selanjutnya\n\nx = eval(input('Masukkan bilangan: '))\nif x &lt; 0:\n    print('Haha')\nelif x &gt;= 0 and x &lt;= 4:\n    print('Hehe')\nelse:\n    print('Hoho')\n\nMasukkan bilangan: 2\nHehe\n\n\n\n\n\nKebanyakan metode pada Metnum bersifat iteratif, artinya algoritmanya dijalankan berulang hingga tercapai batas tertentu (biasanya terdapat nilai toleransi antara aproksimasi dengan nilai eksaknya). Looping pada Python biasanya menggunakan for loop dan while loop.\nfor loop digunakan ketika kita mengetahui berapa kali kita harus mengulang perintah. Beberapa cara untuk for loop:\n\nfor i in range(a, b, n) : Loop ini akan membuat for loop berjalan mulai dari a hingga b - 1 dengan step sebesar n. Argumen n bersifat opsional dengan nilai default 1. Jika menggunakan range(b), maka bisa dianggap a = 0.\nfor i in list atau for i in string : Loop ini akan membuat for loop mengiterasikan tiap elemen list atau karakter string yang akan disimpan pada i. while loop digunakan ketika ada syarat tertentu yang harus dipenuhi untuk mengulang perintah tersebut.\nwhile cond : Loop ini akan membuat while loop berjalan selama cond bernilai True . Berhati-hatilah dalam menggunakan while loop. Pastikan kondisi yang dimasukkan akan bisa bernilai False . Jika tidak, maka kode akan stuck di infinite loop.\n\nAdvanced note: range() sejatinya adalah fungsi yang mengoutput list angka dengan aturan seperti di atas.\n\nprint('FOR LOOP EXAMPLE 1')\nfor i in range(3):\n    print('Print 3 kali')\nprint('FOR LOOP EXAMPLE 2')\nfor i in range(1, 4):\n    print(2 * i)\nprint('FOR LOOP EXAMPLE 3')\nfor i in range(1, 10, 3):\n    print('Angka sekarang:', i)\nprint('FOR LOOP EXAMPLE 4')\nfor i in [1, 4, 8, 2]:\n    print(i)\nprint('FOR LOOP EXAMPLE 5')\nfor i in 'mondstad':\n    if i == 'd':\n        print(i)\nprint('WHILE LOOP EXAMPLE')\ni = 0\nwhile i &lt;= 5:\n    print('Hati-hati while')\n    i += 1\nprint('While iteration DONE')\n\nFOR LOOP EXAMPLE 1\nPrint 3 kali\nPrint 3 kali\nPrint 3 kali\nFOR LOOP EXAMPLE 2\n2\n4\n6\nFOR LOOP EXAMPLE 3\nAngka sekarang: 1\nAngka sekarang: 4\nAngka sekarang: 7\nFOR LOOP EXAMPLE 4\n1\n4\n8\n2\nFOR LOOP EXAMPLE 5\nd\nd\nWHILE LOOP EXAMPLE\nHati-hati while\nHati-hati while\nHati-hati while\nHati-hati while\nHati-hati while\nHati-hati while\nWhile iteration DONE"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/modul0.html#error-handling",
    "href": "semuahalaman/modulprak/2024/genap/metnum/modul0.html#error-handling",
    "title": "Modul 0 Metode Numerik: Review Python, NumPy",
    "section": "",
    "text": "Misalkan kalian membuat program tentang menghitung kebalikan dari suatu bilangan bulat. Tentu bilangan selain nol memiliki kebalikan. Namun, apa yang terjadi jika kalian memasukkan 0 sebagai input? Pasti error.\nError pada program mengakibatkan program terhenti di tengah-tengah, sehingga belum semua baris dieksekusi. Mungkin tidak berpengaruh banyak jika programnya digunakan untuk sendiri, namun seandainya kalian membuat program yang digunakan untuk mengatur server perusahaan, entah apa jadinya kalau programnya error.\nUntuk itu, terdapat cara untuk mengatasi error tersebut. Di Python, kalian dapat menggunakan try…except . Ini adalah penyataan kondisional serupa dengan if…else , namun pengecekan dilakukan pada bagian try . Jika pada bagian tersebut tidak ada masalah yang menyebabkab error, maka bagian except tidak dijalankan. Sebaliknya, jika error, maka bagian except akan dijalankan. Ada beberapa macam error di Python:\n\nZeroDivisionError : Error ini keluar jika terdapat pembagian dengan nol.\nValueError : Error ini keluar jika tipe data yang dimasukkan tidak bisa diproses karena tidak sesuai. dll. Silahkan cari di Google :)\n\nAdvanced note: Kalian dapat mengecek tipe data pada python dengan fungsi type() .\n\ntry:\n    x = int(input('Masukkan integer taknol: '))\n    print(1 / x)\nexcept:\n    print('Yhaa programnya error :(')\n\nMasukkan integer taknol: 0\nYhaa programnya error :("
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/modul0.html#numpy",
    "href": "semuahalaman/modulprak/2024/genap/metnum/modul0.html#numpy",
    "title": "Modul 0 Metode Numerik: Review Python, NumPy",
    "section": "",
    "text": "NumPy adalah package Python yng sangat multifungsi. Kita akan menggunakan NumPy untuk membuat array yang elemennya hanya mempunyai satu tipe data. NumPy juga mempunyai fungsi fungsi seperti sin, cos, log, dll.\nMula-mula, kita perlu meng-import package NumPy.\n\nimport numpy as np\n\nJika pada langkah ini kalian menemukan error, kemungkinan besar kalian belum mempunyai package NumPy terinstal. Jika kalian menggunakan Jupyter Notebook atau Spyder melalui Anaconda, kalian bisa mencoba mengikuti langkah ini:\n\nBuka Anaconda Prompt\nKetik conda install numpy (Jika tidak berhasil gunakan pip install numpy )\nTunggu hingga proses mengunduh selesai.\n\nAlternatif yang lebih mudah adalah langsung mengetik pip install numpy (atau !pip install numpy dengan tanda seru) pada Jupyter Notebook (bisa juga pada Google Colaboratory), kemudian menutup dan membuka kembali Jupyter Notebook:\n\npip install numpy\n\nRequirement already satisfied: numpy in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (1.24.2)\nNote: you may need to restart the kernel to use updated packages.\n\n\n\n!pip install numpy\n\nRequirement already satisfied: numpy in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (1.24.2)\n\n\nNumpy Array\nSeperti yang sudah dikatakan sebelumnya, list bukan array karena dapat diisi dengan berbagai tipe data. Kalau begitu, bagaimana array yang benar? Di NumPy, ada fungsi bernama array yang berfungsi mengubah list menjadi array.\n\nA = np.array([True, 4, 7.5, 'Jean'])\nB = np.array([5, 6.2])\nC = np.array([4, 2, -1, -3])\ntype(A)\n\nnumpy.ndarray\n\n\nTerlihat tipe data dari A bukan list, melainkan numpy.ndarray. Perhatikan juga bahwa kita mengisi list yang akan dijadikan array A dan B dengan beragam tipe data…\n\nprint(A)\nprint(B)\nprint(C)\n\n['True' '4' '7.5' 'Jean']\n[5.  6.2]\n[ 4  2 -1 -3]\n\n\n…maka tipe datanya akan berubah menjadi sama. Karena NumPy array hanya bisa menyimpan satu tipe data, maka jika tipenya berbeda akan berubah. Urutan pengecekannya adalah string , float , integer , boolean (tipe data boolean menyimpan nilai 1 jika True dan 0 jika False ).\nKita juga dapat membuat array 2 dimensi seperti matriks, dan jika di-print, maka outputnya juga seperti matriks.\n\nP = np.array([[1, 2],[-1, 0]])\nQ = np.array([[4, -1],[5, 0]])\nR = np.array([[1, 2, 4, 5], [-1, -8, 9, 11], [3, -2, -4, 6]])\n\nDi sini kalian juga bisa melakukan indexing dan slicing seperti halnya pada liat.\n\nprint(A[0])\nprint(B[-1])\nprint(P[0])\nprint(Q[0,1])\nprint()\nprint(A[2:])\nprint(R[1:])\nprint(R[1, 2:])\nprint(R[:, 1])\n\nTrue\n6.2\n[1 2]\n-1\n\n['7.5' 'Jean']\n[[-1 -8  9 11]\n [ 3 -2 -4  6]]\n[ 9 11]\n[ 2 -8 -2]\n\n\nOperasi aritmatika juga dapat diterapkan pada NumPy array. Operasi aritmatika antar dua NumPy array akan dilakukan secara element- wise, artinya operasinya dilakukan tiap elemen (bukan seperti dot product pada aljabar linear).\n\nA = np.array([1, 4, 7, 10])\nB = np.array([1, 2, 3, 4])\n#operasi pada array\nprint(A + B)\nprint(A - B)\nprint(A * B)\nprint(A / B)\nprint(A % B)\nprint(A // B)\nprint(A ** B)\n\n[ 2  6 10 14]\n[0 2 4 6]\n[ 1  8 21 40]\n[1.         2.         2.33333333 2.5       ]\n[0 0 1 2]\n[1 2 2 2]\n[    1    16   343 10000]\n\n\nSelain itu, operasi aritmatika juga bisa dilakukan dengan skalar. Operasi aritmatika antara NumPy array dengan suatu skalar akan dilakukan seolah-olah skalar tersebut adalah NumPy array berukuran sama yang isinya skalar tersebut. Istilahnya biasanya disebut Broadcasting\n\nprint(A + 2)\nprint(C * 3)\nprint(P ** 2)\nprint(1 / R)\n\n[ 3  6  9 12]\n[12  6 -3 -9]\n[[1 4]\n [1 0]]\n[[ 1.          0.5         0.25        0.2       ]\n [-1.         -0.125       0.11111111  0.09090909]\n [ 0.33333333 -0.5        -0.25        0.16666667]]"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html",
    "title": "Modul 2 Kalkulin: Basic LaTeX Part 2",
    "section": "",
    "text": "Kembali ke Kalkulin"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#outline",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#outline",
    "title": "Modul 2 Kalkulin: Basic LaTeX Part 2",
    "section": "Outline",
    "text": "Outline"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#structured-documents",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#structured-documents",
    "title": "Modul 2 Kalkulin: Basic LaTeX Part 2",
    "section": "Structured Documents",
    "text": "Structured Documents\n\nClick here to open the example document in Overleaf\n\n\n\n\nClick to open the paper\nClick to open this exercise in Overleaf\nclick here to see my solution\nhttp://pdos.csail.mit.edu/scigen/"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#figures-and-tables",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#figures-and-tables",
    "title": "Modul 2 Kalkulin: Basic LaTeX Part 2",
    "section": "Figures and Tables",
    "text": "Figures and Tables"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#bibliographies",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#bibliographies",
    "title": "Modul 2 Kalkulin: Basic LaTeX Part 2",
    "section": "Bibliographies",
    "text": "Bibliographies"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#exercise-putting-it-all-together",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#exercise-putting-it-all-together",
    "title": "Modul 2 Kalkulin: Basic LaTeX Part 2",
    "section": "Exercise: Putting it All Together",
    "text": "Exercise: Putting it All Together\n\nClick to download example image\nClick to download example bib file"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#whats-next",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#whats-next",
    "title": "Modul 2 Kalkulin: Basic LaTeX Part 2",
    "section": "What’s Next?",
    "text": "What’s Next?\n\n\n\nhttps://www.overleaf.com/latex/examples\nhttp://texample.net/"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#installing-latex",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#installing-latex",
    "title": "Modul 2 Kalkulin: Basic LaTeX Part 2",
    "section": "Installing LaTeX",
    "text": "Installing LaTeX\n\nhttp://en.wikipedia.org/wiki/Comparison_of_TeX_editors"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#penutup",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul2.html#penutup",
    "title": "Modul 2 Kalkulin: Basic LaTeX Part 2",
    "section": "Penutup",
    "text": "Penutup"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/kalkulin2024genap.html",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/kalkulin2024genap.html",
    "title": "Praktikum Kalkulin (Kalkulus 2 & Aljabar Linier 1) 2024 Genap (Kurikulum 2020)",
    "section": "",
    "text": "Kembali ke Praktikum\n\nTimeline\n\nModul 1: Basic LaTeX Part 1, 23-24 Februari 2024\nModul 2: Basic LaTeX Part 2, 28-30 Februari 2024\nModul 3: LaTeX Beamer, 7-9 Maret 2024"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/eda/modul1.html",
    "href": "semuahalaman/modulprak/2024/genap/eda/modul1.html",
    "title": "Python for Data Analysis (Pertemuan 1)",
    "section": "",
    "text": "Kembali ke EDA"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/eda/modul1.html#series",
    "href": "semuahalaman/modulprak/2024/genap/eda/modul1.html#series",
    "title": "Python for Data Analysis (Pertemuan 1)",
    "section": "Series",
    "text": "Series\n\nSeries adalah suatu object yang menyerupai array 1 dimensi yang memiliki nilai dengan array index yang berkaitan dengan masing-masing nilai.\n\nimport pandas as pd\n\nobj = pd.Series([4, 7, -5, 3])\nobj\n\n0    4\n1    7\n2   -5\n3    3\ndtype: int64\n\n\nkolom kiri adalah index, kolom kanan adalah Values (nilai).\n\nUntuk mengakses values saja :\n\nobj.values\n\narray([ 4,  7, -5,  3])\n\n\n\nUntuk mengakses index saja :\n\nobj.index\n\nRangeIndex(start=0, stop=4, step=1)\n\n\n\n\n\nPerbedaan Series dengan Array\n\nDengan Series kita bisa menggunakan index untuk mengakses value yang berkaitan dengan index tersebut.\n\nobj[0]\n\n4\n\n\n\nobj[1] = 2\nobj[[0, 1, 3]]\n\n0    4\n1    2\n3    3\ndtype: int64\n\n\n\nobj[0:2]\n\n0    4\n1    2\ndtype: int64\n\n\n\n\n\n\nSeries dengan custom index\n\n\nobj2 = pd.Series([0.25, 0.5, 0.75, 1.0], index=['d', 'b', 'a', 'c'])\nobj2\n\nd    0.25\nb    0.50\na    0.75\nc    1.00\ndtype: float64\n\n\n\n\n\n\n\n\nError warning\n\n\n\nPerhatikan jumlah index harus sama dengan jumlah value yang ditetapkan.\n\n\n\nobj2.index\n\nIndex(['d', 'b', 'a', 'c'], dtype='object')\n\n\n\nobj2['b']\n\n0.5\n\n\n\nobj2['d':'a']\n\nd    0.25\nb    0.50\na    0.75\ndtype: float64\n\n\n\nUntuk mengubah index suatu series bisa juga dengan mengubah nilai &lt;series&gt;.index\n\nobj2.index = ['A', 'B', 'C', 'D']\nobj2\n\nA    0.25\nB    0.50\nC    0.75\nD    1.00\ndtype: float64\n\n\n\n\n\n\nSeries as specialized dictionary\n\nDictionary pada python adalah struktur data yang berisi pasangan key-value. Kita dapat melihat series sebagai pasangan key-value dengan index sebagai key. Bahkan kita bisa membuat suatu series dari sebuah dictionary.\n\ndata_dict = {\n  'Jakarta': 400,\n  'Bandung': 200,\n  'Bogor': 300,\n  'Depok': 500\n}\ndata_dict\n\n{'Jakarta': 400, 'Bandung': 200, 'Bogor': 300, 'Depok': 500}\n\n\n\ndata_series = pd.Series(data_dict)\ndata_series\n\nJakarta    400\nBandung    200\nBogor      300\nDepok      500\ndtype: int64\n\n\n\nJika kita ingin index dengan urutan tertentu, maka kita dapat memasukkan argumen index berupa list index sesuai dengan urutan yang kita inginkan.\n\nkota = ['Surabaya', 'Bandung', 'Bogor', 'Jakarta']\ndata_series2 = pd.Series(data_dict, index=kota)\ndata_series2\n\nSurabaya      NaN\nBandung     200.0\nBogor       300.0\nJakarta     400.0\ndtype: float64\n\n\n\n\n\n\n\n\nTip\n\n\n\nPerhatikan bahwa jika kita memasukkan index yang tidak ada pada dictionary awal, index akan dimasukkan dengan nilai NaN (Not a Number)\n\n\n\n\n\n\nOperasi Aritmatika\n\nSeries secara otomatis menyamakan index ketika melakukan operasi aritmatika.\n\ndata_series + data_series2 # Silahkan coba untuk operasi aritmatika lainnya\n\nBandung     400.0\nBogor       600.0\nDepok         NaN\nJakarta     800.0\nSurabaya      NaN\ndtype: float64\n\n\n\n\n\n\n\n\nTip\n\n\n\nPerhatikan bahwa Depok dan Surabaya bernilai NaN. Hal ini dikarenakan kedua index tersebut tidak terdapat pada kedua series yang kita operasikan.\n\n\n\n\n\n\nname attribute\n\nObject series dan index pada pandas memiliki atribut name yaitu nama dari series/index tersebut.\n\ndata_series.name = 'populasi'\ndata_series.index.name = 'kota'\ndata_series\n\nkota\nJakarta    400\nBandung    200\nBogor      300\nDepok      500\nName: populasi, dtype: int64"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/eda/modul1.html#dataframe",
    "href": "semuahalaman/modulprak/2024/genap/eda/modul1.html#dataframe",
    "title": "Python for Data Analysis (Pertemuan 1)",
    "section": "DataFrame",
    "text": "DataFrame\n\nDataFrame adalah struktur data 2 dimensi yang terdiri atas baris dan kolom (disebut juga tabel). Kita dapat melihat dataframe sebagai gabungan dari 2 atau lebih series.\n\n\n\nKarena memiliki 2 dimensi (baris dan kolom), DataFrame memiliki indeks untuk masing-masing baris dan kolom.\n\nAda banyak cara untuk membangun DataFrame, salah satu yang paling umum adalah membuat dictionary dengan\nkey : nama kolom\nvalue : nilai-nilai dalam list atau NumPy Array dengan panjang yang sama untuk setiap kolom.\n\ndata = {'kota': ['Bogor', 'Bogor', 'Bogor', 'Depok', 'Depok', 'Depok'],\n 'tahun': [2000, 2001, 2002, 2001, 2002, 2003],\n 'populasi': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}\n\ndf = pd.DataFrame(data) # `df` adalah singkatan yang umum digunakan oleh komunitas python dalam mendefinisikan suatu `dataframe`\n\ndf\n\n\n\n\n\n\n\n\nkota\ntahun\npopulasi\n\n\n\n\n0\nBogor\n2000\n1.5\n\n\n1\nBogor\n2001\n1.7\n\n\n2\nBogor\n2002\n3.6\n\n\n3\nDepok\n2001\n2.4\n\n\n4\nDepok\n2002\n2.9\n\n\n5\nDepok\n2003\n3.2\n\n\n\n\n\n\n\npd.DataFrame() menerima argumen columns= yang dapat digunakan untuk menentukan urutan kolom dataframe.\n\ndf2 = pd.DataFrame(data, columns=['tahun', 'kota', 'populasi'])\n\ndf2\n\n\n\n\n\n\n\n\ntahun\nkota\npopulasi\n\n\n\n\n0\n2000\nBogor\n1.5\n\n\n1\n2001\nBogor\n1.7\n\n\n2\n2002\nBogor\n3.6\n\n\n3\n2001\nDepok\n2.4\n\n\n4\n2002\nDepok\n2.9\n\n\n5\n2003\nDepok\n3.2\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nmenambahkan kolom baru yang tidak ada pada data akan menghasilkan kolom berisi nilai NaN\npd.DataFrame juga menerima argumen index= untuk mengubah index seperti pada pd.Series\n\n\ndf2 = pd.DataFrame(data, columns=['tahun', 'kota', 'populasi', 'luas_wilayah'], \n                   index=['one', 'two', 'three', 'four', 'five', 'six'])\n\ndf2\n\n\n\n\n\n\n\n\ntahun\nkota\npopulasi\nluas_wilayah\n\n\n\n\none\n2000\nBogor\n1.5\nNaN\n\n\ntwo\n2001\nBogor\n1.7\nNaN\n\n\nthree\n2002\nBogor\n3.6\nNaN\n\n\nfour\n2001\nDepok\n2.4\nNaN\n\n\nfive\n2002\nDepok\n2.9\nNaN\n\n\nsix\n2003\nDepok\n3.2\nNaN\n\n\n\n\n\n\n\n\n\n\n\nImporting datasets\n\nDalam mengolah suatu data, tidaklah mungkin kita harus menulis ulang seluruh data yang sudah tertulis dengan format tertentu (misalnya Spreadsheet/.xlsx, .csv, atau .dat) pastinya kita perlu suatu cara untuk mengimpor data yang memiliki berbagai format. Pandas memiliki beberapa function yang dapat kita gunakan untuk membaca data dengan berbagai format.\n\n.csv (comma separated values)\n\ndf = pd.read_csv('&lt;path-to-csv&gt;')\n\n.xlsx (excel spreadsheet)\n\ndf = pd.read_excel('&lt;path-to-xlsx&gt;')\n\nOthers\n\nUntuk tipe file lainnya, silahkan baca dokumentasi pandas di link berikut : Pandas IO Tools\n\n\n\nDataFrame Attributes/Properties and Methods\n\nSejauh ini kita sudah berkenalan dengan 2 object pandas yaitu Series dan DataFrame. Dalam pemrograman python, sebuah object bisa memiliki suatu method, attribute/property, atau keduanya.\nUntuk materi selanjutnya, kita akan menggunakan dataset pokemon sebagai contoh. Jalankan code block di bawah ini.\n\ndf = pd.read_csv('https://raw.githubusercontent.com/farhanage/dataset-for-study/main/pokemon_data.csv')\n\n\n\n\nhead()\nMemanggil method head akan mengembalikan beberapa baris pertama dari suatu dataframe.\n\ndf.head(3)  # Membaca 3 baris pertama\n\n\n\n\n\n\n\n\n#\nName\nType 1\nType 2\nHP\nAttack\nDefense\nSp. Atk\nSp. Def\nSpeed\nGeneration\nLegendary\n\n\n\n\n0\n1\nBulbasaur\nGrass\nPoison\n45\n49\n49\n65\n65\n45\n1\nFalse\n\n\n1\n2\nIvysaur\nGrass\nPoison\n60\n62\n63\n80\n80\n60\n1\nFalse\n\n\n2\n3\nVenusaur\nGrass\nPoison\n80\n82\n83\n100\n100\n80\n1\nFalse\n\n\n\n\n\n\n\n\n\n\ntail()\nMemanggil method tail akan mengembalikan beberapa baris terakhir dari suatu dataframe.\n\ndf.tail(3)  # Membaca 3 baris terakhir\n\n\n\n\n\n\n\n\n#\nName\nType 1\nType 2\nHP\nAttack\nDefense\nSp. Atk\nSp. Def\nSpeed\nGeneration\nLegendary\n\n\n\n\n797\n720\nHoopaHoopa Confined\nPsychic\nGhost\n80\n110\n60\n150\n130\n70\n6\nTrue\n\n\n798\n720\nHoopaHoopa Unbound\nPsychic\nDark\n80\n160\n60\n170\n130\n80\n6\nTrue\n\n\n799\n721\nVolcanion\nFire\nWater\n80\n110\n120\n130\n90\n70\n6\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nSecara default, method head() dan tail() akan mengembalikan 5 baris pertama/terakhir jika tidak diberikan suatu argumen.\n\n\n\n\n\nshape\nMemanggil attribute shape akan memberikan kita jumlah baris dan kolom dari suatu dataframe.\n\ndf.shape  # Mengembalikan (jumlah_baris, jumlah_kolom)\n\n(800, 12)\n\n\n\n\n\ncolumns\nMemanggil attribute columns akan memberikan kita index object berisi semua nama kolom dari suatu dataframe.\n\ndf.columns  # Mengembalikan index object berisi semua nama kolom dari suatu dataframe\n\nIndex(['#', 'Name', 'Type 1', 'Type 2', 'HP', 'Attack', 'Defense', 'Sp. Atk',\n       'Sp. Def', 'Speed', 'Generation', 'Legendary'],\n      dtype='object')\n\n\n\n\n\nindex\nMemanggil attribute columns akan memberikan kita index object berisi index baris suatu dataframe.\n\ndf.index  # Mengembalikan index object berisi index suatu dataframe\n\nRangeIndex(start=0, stop=800, step=1)\n\n\nPandas dataframe memiliki banyak sekali methods dan attributes/properties. Untuk mempelajari lebih lanjut mengenai dataframe pandas, dokumentasi library pandas bisa diakses pada link berikut : Pandas essential basic functionality"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/eda/modul1.html#index-1",
    "href": "semuahalaman/modulprak/2024/genap/eda/modul1.html#index-1",
    "title": "Python for Data Analysis (Pertemuan 1)",
    "section": "Index",
    "text": "Index\n\nPerhatikan pada atribut columns dan index yang telah dibahas sebelumnya, output kode adalah object index. Apa itu object index? Dalam library Pandas, object index digunakan sebagai object yang menyimpan label suatu object lainnya.\nContoh : dalam object DataFrame, index object digunakan untuk menyimpan label baris (df.index) dan kolom (df.columns).\n\nobj = pd.Series(range(3), index=['a', 'b', 'c'])\nobj.index\n\nIndex(['a', 'b', 'c'], dtype='object')\n\n\n\nobj.index[1]\n\n'b'\n\n\n\nobj.index[1:]\n\nIndex(['b', 'c'], dtype='object')\n\n\n\n\n\n\n\n\nError warning\n\n\n\nIndex object bersifat immutable, artinya nilai dari suatu index tidak dapat diubah.\n\nobj.index[1] = 'd'\n\nTypeError: Index does not support mutable operations\n\n\n\n\nIndex object juga memiliki beberapa attribute dan methods. Beberapa diantaranya :"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/eda/modul1.html#basic-functionality",
    "href": "semuahalaman/modulprak/2024/genap/eda/modul1.html#basic-functionality",
    "title": "Python for Data Analysis (Pertemuan 1)",
    "section": "Basic Functionality",
    "text": "Basic Functionality\n\nIndexing, Selection and Filtering\n\nIndexing and Selection\n\nSeries indexing digunakan untuk mengambil value yang berkaitan dengan suatu index.\n\nimport numpy as np\nobj = pd.Series(np.arange(4.), index=['a', 'b', 'c', 'd'])\nobj\n\na    0.0\nb    1.0\nc    2.0\nd    3.0\ndtype: float64\n\n\n\nobj['b']  # Memanggil nilai dengan index `a`\n\n1.0\n\n\n\nobj['a':'c']  # Memanggil nilai dengan index `a` hingga `c`\n\na    0.0\nb    1.0\nc    2.0\ndtype: float64\n\n\n\n\n\n\n\n\nImportant\n\n\n\nPerhatikan, saat melakukan slicing dengan explicit index (misal, data['a':'c']), final index diikutsertakan dalam outputnya (inklusif), sementara ketika melakukan slicing dengan implicit index (misal, data[0:2]), final index tidak diikutsertakan dalam outputnya (tidak inklusif).\n\n\n\nDataFrame indexing digunakan untuk mengambil 1 atau beberapa kolom dengan memanggil label/nama kolom yang bersesuaian.\n\ndf['Name']\n\n0                  Bulbasaur\n1                    Ivysaur\n2                   Venusaur\n3      VenusaurMega Venusaur\n4                 Charmander\n               ...          \n795                  Diancie\n796      DiancieMega Diancie\n797      HoopaHoopa Confined\n798       HoopaHoopa Unbound\n799                Volcanion\nName: Name, Length: 800, dtype: object\n\n\n\ndf[['Name']]\n\n\n\n\n\n\n\n\nName\n\n\n\n\n0\nBulbasaur\n\n\n1\nIvysaur\n\n\n2\nVenusaur\n\n\n3\nVenusaurMega Venusaur\n\n\n4\nCharmander\n\n\n...\n...\n\n\n795\nDiancie\n\n\n796\nDiancieMega Diancie\n\n\n797\nHoopaHoopa Confined\n\n\n798\nHoopaHoopa Unbound\n\n\n799\nVolcanion\n\n\n\n\n800 rows × 1 columns\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\ndf['&lt;column-name&gt;'] akan mengembalikan kolom yang bersesuaian dalam bentuk Series.\ndf[['&lt;column-name&gt;']] akan mengembalikan kolom yang bersesuaian dalam bentuk dataframe.\n\n\n\ndf[['Name','HP','Defense']]\n\n\n\n\n\n\n\n\nName\nHP\nDefense\n\n\n\n\n0\nBulbasaur\n45\n49\n\n\n1\nIvysaur\n60\n63\n\n\n2\nVenusaur\n80\n83\n\n\n3\nVenusaurMega Venusaur\n80\n123\n\n\n4\nCharmander\n39\n43\n\n\n...\n...\n...\n...\n\n\n795\nDiancie\n50\n150\n\n\n796\nDiancieMega Diancie\n50\n110\n\n\n797\nHoopaHoopa Confined\n80\n60\n\n\n798\nHoopaHoopa Unbound\n80\n60\n\n\n799\nVolcanion\n80\n120\n\n\n\n\n800 rows × 3 columns\n\n\n\n\nKita bisa membuat suatu kolom baru dari kolom-kolom yang sudah ada. Misalkan kita buat suatu variabel bernama Total Attack yang berisi hasil penjumlahan variabel Attack dan Sp. Atk\n\ndf['Total Attack'] = df['Attack'] + df['Sp. Atk']\ndf[['Attack','Sp. Atk','Total Attack']]\n\n\n\n\n\n\n\n\nAttack\nSp. Atk\nTotal Attack\n\n\n\n\n0\n49\n65\n114\n\n\n1\n62\n80\n142\n\n\n2\n82\n100\n182\n\n\n3\n100\n122\n222\n\n\n4\n52\n60\n112\n\n\n...\n...\n...\n...\n\n\n795\n100\n100\n200\n\n\n796\n160\n160\n320\n\n\n797\n110\n150\n260\n\n\n798\n160\n170\n330\n\n\n799\n110\n130\n240\n\n\n\n\n800 rows × 3 columns\n\n\n\n\nUntuk indexing baris suatu dataframe, gunakan index baris\n\ndf[:3] # Mengambil baris dengan index 0 - 2\n\n\n\n\n\n\n\n\n#\nName\nType 1\nType 2\nHP\nAttack\nDefense\nSp. Atk\nSp. Def\nSpeed\nGeneration\nLegendary\nTotal Attack\n\n\n\n\n0\n1\nBulbasaur\nGrass\nPoison\n45\n49\n49\n65\n65\n45\n1\nFalse\n114\n\n\n1\n2\nIvysaur\nGrass\nPoison\n60\n62\n63\n80\n80\n60\n1\nFalse\n142\n\n\n2\n3\nVenusaur\nGrass\nPoison\n80\n82\n83\n100\n100\n80\n1\nFalse\n182\n\n\n\n\n\n\n\n\ndf[0:5:2]  # Mengambil dengan index 0 sampai 4 dengan step 2\n\n\n\n\n\n\n\n\n#\nName\nType 1\nType 2\nHP\nAttack\nDefense\nSp. Atk\nSp. Def\nSpeed\nGeneration\nLegendary\nTotal Attack\n\n\n\n\n0\n1\nBulbasaur\nGrass\nPoison\n45\n49\n49\n65\n65\n45\n1\nFalse\n114\n\n\n2\n3\nVenusaur\nGrass\nPoison\n80\n82\n83\n100\n100\n80\n1\nFalse\n182\n\n\n4\n4\nCharmander\nFire\nNaN\n39\n52\n43\n60\n50\n65\n1\nFalse\n112\n\n\n\n\n\n\n\n\n\n\nFiltering\n\nUntuk melakukan filtering pada suatu dataframe :\n\ndf[df['HP'] == 50]  # Mengambil data pada dataframe df yang memiliki nilai kolom `HP` == 50\n\n\n\n\n\n\n\n\n#\nName\nType 1\nType 2\nHP\nAttack\nDefense\nSp. Atk\nSp. Def\nSpeed\nGeneration\nLegendary\nTotal Attack\n\n\n\n\n14\n11\nMetapod\nBug\nNaN\n50\n20\n55\n25\n25\n30\n1\nFalse\n45\n\n\n32\n27\nSandshrew\nGround\nNaN\n50\n75\n85\n20\n30\n40\n1\nFalse\n95\n\n\n59\n54\nPsyduck\nWater\nNaN\n50\n52\n48\n65\n50\n55\n1\nFalse\n117\n\n\n75\n69\nBellsprout\nGrass\nPoison\n50\n75\n35\n70\n30\n40\n1\nFalse\n145\n\n\n83\n77\nPonyta\nFire\nNaN\n50\n85\n55\n65\n65\n90\n1\nFalse\n150\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n760\n690\nSkrelp\nPoison\nWater\n50\n60\n60\n60\n60\n30\n6\nFalse\n120\n\n\n762\n692\nClauncher\nWater\nNaN\n50\n53\n62\n58\n63\n44\n6\nFalse\n111\n\n\n773\n703\nCarbink\nRock\nFairy\n50\n50\n150\n50\n150\n50\n6\nFalse\n100\n\n\n795\n719\nDiancie\nRock\nFairy\n50\n100\n150\n100\n150\n50\n6\nTrue\n200\n\n\n796\n719\nDiancieMega Diancie\nRock\nFairy\n50\n160\n110\n160\n110\n110\n6\nTrue\n320\n\n\n\n\n63 rows × 13 columns\n\n\n\n\ndf[df['HP'] &gt; 50]  # Mengambil data pada dataframe df yang memiliki nilai kolom `HP` &gt; 50\n\n\n\n\n\n\n\n\n#\nName\nType 1\nType 2\nHP\nAttack\nDefense\nSp. Atk\nSp. Def\nSpeed\nGeneration\nLegendary\nTotal Attack\n\n\n\n\n1\n2\nIvysaur\nGrass\nPoison\n60\n62\n63\n80\n80\n60\n1\nFalse\n142\n\n\n2\n3\nVenusaur\nGrass\nPoison\n80\n82\n83\n100\n100\n80\n1\nFalse\n182\n\n\n3\n3\nVenusaurMega Venusaur\nGrass\nPoison\n80\n100\n123\n122\n120\n80\n1\nFalse\n222\n\n\n5\n5\nCharmeleon\nFire\nNaN\n58\n64\n58\n80\n65\n80\n1\nFalse\n144\n\n\n6\n6\nCharizard\nFire\nFlying\n78\n84\n78\n109\n85\n100\n1\nFalse\n193\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n793\n717\nYveltal\nDark\nFlying\n126\n131\n95\n131\n98\n99\n6\nTrue\n262\n\n\n794\n718\nZygarde50% Forme\nDragon\nGround\n108\n100\n121\n81\n95\n95\n6\nTrue\n181\n\n\n797\n720\nHoopaHoopa Confined\nPsychic\nGhost\n80\n110\n60\n150\n130\n70\n6\nTrue\n260\n\n\n798\n720\nHoopaHoopa Unbound\nPsychic\nDark\n80\n160\n60\n170\n130\n80\n6\nTrue\n330\n\n\n799\n721\nVolcanion\nFire\nWater\n80\n110\n120\n130\n90\n70\n6\nTrue\n240\n\n\n\n\n589 rows × 13 columns\n\n\n\n\ndf[(df['HP'] &gt; 100) & (df['Type 1'] == 'Fire')]  # Mengambil data pada dataframe df yang memiliki nilai kolom `HP` &gt; 100 dan `Type 1` == Fire\n\n\n\n\n\n\n\n\n#\nName\nType 1\nType 2\nHP\nAttack\nDefense\nSp. Atk\nSp. Def\nSpeed\nGeneration\nLegendary\nTotal Attack\n\n\n\n\n263\n244\nEntei\nFire\nNaN\n115\n115\n85\n90\n75\n100\n2\nTrue\n205\n\n\n270\n250\nHo-oh\nFire\nFlying\n106\n130\n90\n110\n154\n90\n2\nTrue\n240\n\n\n559\n500\nEmboar\nFire\nFighting\n110\n123\n65\n100\n65\n65\n5\nFalse\n223\n\n\n615\n555\nDarmanitanStandard Mode\nFire\nNaN\n105\n140\n55\n30\n55\n95\n5\nFalse\n170\n\n\n616\n555\nDarmanitanZen Mode\nFire\nPsychic\n105\n30\n105\n140\n105\n55\n5\nFalse\n170\n\n\n\n\n\n\n\n\ndf[(df['HP'] &gt; 100) | (df['Type 1'] == 'Fire')]  # Mengambil data pada dataframe df yang memiliki nilai kolom `HP` &gt; 100 atau `Type 1` == Fire\n\n\n\n\n\n\n\n\n#\nName\nType 1\nType 2\nHP\nAttack\nDefense\nSp. Atk\nSp. Def\nSpeed\nGeneration\nLegendary\nTotal Attack\n\n\n\n\n4\n4\nCharmander\nFire\nNaN\n39\n52\n43\n60\n50\n65\n1\nFalse\n112\n\n\n5\n5\nCharmeleon\nFire\nNaN\n58\n64\n58\n80\n65\n80\n1\nFalse\n144\n\n\n6\n6\nCharizard\nFire\nFlying\n78\n84\n78\n109\n85\n100\n1\nFalse\n193\n\n\n7\n6\nCharizardMega Charizard X\nFire\nDragon\n78\n130\n111\n130\n85\n100\n1\nFalse\n260\n\n\n8\n6\nCharizardMega Charizard Y\nFire\nFlying\n78\n104\n78\n159\n115\n100\n1\nFalse\n263\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n769\n699\nAurorus\nRock\nIce\n123\n77\n72\n99\n92\n58\n6\nFalse\n176\n\n\n792\n716\nXerneas\nFairy\nNaN\n126\n131\n95\n131\n98\n99\n6\nTrue\n262\n\n\n793\n717\nYveltal\nDark\nFlying\n126\n131\n95\n131\n98\n99\n6\nTrue\n262\n\n\n794\n718\nZygarde50% Forme\nDragon\nGround\n108\n100\n121\n81\n95\n95\n6\nTrue\n181\n\n\n799\n721\nVolcanion\nFire\nWater\n80\n110\n120\n130\n90\n70\n6\nTrue\n240\n\n\n\n\n114 rows × 13 columns\n\n\n\nUntuk filter yang lebih rumit, disarankan untuk mendefinisikan variabel condition agar kode mudah terbaca.\nContoh : Filter (HP &gt;= 150) dan ((Type 1 == Water) atau (Legendary == True))\n\ncondition = (df['HP'] &gt;= 150) & ((df['Type 1'] == 'Water') | (df['Legendary'] == True))\ndf[condition]\n\n\n\n\n\n\n\n\n#\nName\nType 1\nType 2\nHP\nAttack\nDefense\nSp. Atk\nSp. Def\nSpeed\nGeneration\nLegendary\nTotal Attack\n\n\n\n\n351\n321\nWailord\nWater\nNaN\n170\n90\n45\n90\n45\n60\n3\nFalse\n180\n\n\n544\n487\nGiratinaAltered Forme\nGhost\nDragon\n150\n100\n120\n100\n120\n90\n4\nTrue\n200\n\n\n545\n487\nGiratinaOrigin Forme\nGhost\nDragon\n150\n120\n100\n120\n100\n90\n4\nTrue\n240\n\n\n655\n594\nAlomomola\nWater\nNaN\n165\n75\n80\n40\n45\n65\n5\nFalse\n115"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul1.html",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul1.html",
    "title": "Modul 1 Kalkulin: Basic LaTeX Part 1",
    "section": "",
    "text": "Kembali ke Kalkulin\nDalam beberapa pertemuan ke depan, kita akan mempelajari bahasa LaTeX. Untuk itu, ada opsi offline serta opsi online untuk software yang digunakan.\nOpsi offline adalah dengan menginstal Miktex kemudian menginstal TeXStudio:\nOpsi online, yang lebih mudah dan cenderung lebih sering digunakan, adalah dengan membuat akun dan login ke website Overleaf:\nhttps://www.overleaf.com/"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul1.html#pengantar",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul1.html#pengantar",
    "title": "Modul 1 Kalkulin: Basic LaTeX Part 1",
    "section": "Pengantar",
    "text": "Pengantar"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul1.html#getting-started",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul1.html#getting-started",
    "title": "Modul 1 Kalkulin: Basic LaTeX Part 1",
    "section": "Getting started",
    "text": "Getting started\n\n\nClick here to open the example document in Overleaf"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul1.html#typesetting-text",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul1.html#typesetting-text",
    "title": "Modul 1 Kalkulin: Basic LaTeX Part 1",
    "section": "Typesetting Text",
    "text": "Typesetting Text\n\n\n\n\nClick to open this exercise in Overleaf\nclick here to see my solution\nhttp://en.wikipedia.org/wiki/Economy_of_the_United_States"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul1.html#typesetting-mathematics",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul1.html#typesetting-mathematics",
    "title": "Modul 1 Kalkulin: Basic LaTeX Part 1",
    "section": "Typesetting Mathematics",
    "text": "Typesetting Mathematics\n\n\n\n\n\n\n\n\n\nClick to open this exercise in Overleaf\nclick here to see my solution"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul1.html#penutup",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul1.html#penutup",
    "title": "Modul 1 Kalkulin: Basic LaTeX Part 1",
    "section": "Penutup",
    "text": "Penutup"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/metnum2024genap.html",
    "href": "semuahalaman/modulprak/2024/genap/metnum/metnum2024genap.html",
    "title": "Praktikum Metode Numerik 2024 Genap (Kurikulum 2020)",
    "section": "",
    "text": "Kembali ke Praktikum\n\nTimeline\n\nModul 0: Review Python, NumPy, tidak dibahas di sesi praktikum\nModul 1: Tabulate, SymPy, Root-finding, 26-27 Februari 2024 (offline di Lab Komputer D.311)"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/modul1.html",
    "href": "semuahalaman/modulprak/2024/genap/metnum/modul1.html",
    "title": "Modul 1 Metode Numerik: Tabulate, SymPy, Root-finding",
    "section": "",
    "text": "Kembali ke Metode Numerik\nSelamat datang di praktikum Metode Numerik!\nPada praktikum ini, kalian akan diajarkan esensial-esensial yang dibutuhkan dan algoritma dasar untuk metode-metode pada Metnum.\nSemua modul telah diuji menggunakan Jupyter Notebook dengan Python 3.11, serta Google Colaboratory yang menggunakan Python 3.9. Semua kode pada modul masih bisa digunakan untuk semua Python versi 3.6 ke atas.\nKalian juga bisa menggunakan aplikasi/IDE (Integrated Development Environment) lainnya seperti PyCharm, Spyder, atau bahkan IDLE (IDLE adalah IDE bawaan Python yang diinstal dari python.org), namun kalian disarankan menggunakan Jupyter Notebook atau Google Colaboratory karena file tugas menggunakan file format .ipynb.\nOUTLINE\n\nTabulate\nSymPy\nMetode Bisection\nMetode Fixed Point\nMetode Newton biasa (dengan turunan analitik)\nMetode Newton dengan Beda Hingga (Finite-Difference Newton’s Method)\nTambahan\n\nContoh Tabel Faktorial\nMetode Secant\nMetode Regula Falsi (penjelasan tanpa kode)\nApa itu barisan? (penjelasan tanpa kode)\nMetode Aitken\nMetode Steffensen: Penerapan Metode Aitken pada Metode Fixed Point\n\n\n\n\nUntuk menyajikan hasil iterasi, tabel sering digunakan karena akan mudah membacanya. Di Python, terdapat package untuk membuat tabel dengan cara sederhana. Package tersebut bernama tabulate.\nSeperti package umumnya, pertama kita import terlebih dahulu.\n\nfrom tabulate import tabulate\n\nApabila terjadi error (karena tabulate belum terinstall), kalian bisa mengetik pip install tabulate (atau !pip install tabulate dengan tanda seru)\n\npip install tabulate\n\nRequirement already satisfied: tabulate in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (0.9.0)\nNote: you may need to restart the kernel to use updated packages.\n\n\n\n!pip install tabulate\n\ndan seperti biasa, setelah instalasi selesai, mungkin kalian perlu menutup kemudian membuka kembali Jupyter Notebook sebelum bisa menggunakan tabulate.\nSekarang, buat konten tabel. Konten tabel disimpan dalam list/array 2-D dimana setiap array di dalamnya adalah baris.\nHeaders dari tabel dapat kita buat sendiri. Jumlah dari headers harus sama dengan jumlah elemen pada setiap array.\n‘tablefmt’ adalah format bentuk tabel. Format yang biasa digunakan adalah “orgtbl”, dan ada macam-macam format tabel yang bisa dicari di https://pypi.org/project/tabulate/\n\ntable = [[\"Jeruk\", 1], [\"Nanas\", 2]]\nprint(tabulate(table, headers = [\"Buah\", \"Kuantitas\"], tablefmt = \"orgtbl\"))\n\n| Buah   |   Kuantitas |\n|--------+-------------|\n| Jeruk  |           1 |\n| Nanas  |           2 |\n\n\nDalam membuat konten tabel, panjang dari setiap list harus sama dengan banyak headers. Apabila ada baris yang banyak elemennya melebihi banyak headers, maka elemen yang diambil adalah elemen sebanyak headers yang pertama. Kolom paling kiri diisi terlebih dahulu.\nPerhatikan contoh berikut.\n\ntable = [[\"Jeruk\", 1, 4], [\"Nanas\", 2, 3, 5], [\"Mangga\", 3]]\nprint(tabulate(table, headers = [\"Buah\", \"Kuantitas\", \"Harga\"], tablefmt = \"orgtbl\"))\n\n| Buah   |   Kuantitas |   Harga |\n|--------+-------------+---------|\n| Jeruk  |           1 |       4 |\n| Nanas  |           2 |       3 |\n| Mangga |           3 |         |\n\n\nApabila baris pertama digunakan sebagai header, banyak kolom akan sama dengan banyak elemen yang paling banyak di antara semua baris tabel. Penamaan kolom dimulai dari kanan.\nPerhatikan contoh berikut.\n\ntable = [[\"Saya\", 1, 4], [\"Tampan\", 2, 3, 5], [\"Banget\", 3, 5]]\nprint(tabulate(table, headers = \"firstrow\", tablefmt = \"orgtbl\"))\n\n|        |   Saya |   1 |   4 |\n|--------+--------+-----+-----|\n| Tampan |      2 |   3 |   5 |\n| Banget |      3 |   5 |     |\n\n\nTabulate sangat berguna untuk membentuk tabel secara “otomatis” atau secara pemrograman. Misalnya, kita bisa memanfaatkan looping dan pernyataan kondisional untuk membuat beberapa baris yang mengikuti pola dan syarat tertentu.\nSebagai contoh, misalnya kita punya function yang menghitung bilangan kuadrat ke-i\n\ndef kuadrat(i):\n    return i**2\n\n\nprint(kuadrat(5))\n\n25\n\n\nKita bisa membuat tabel, misalnya, yang menjabarkan bilangan kuadrat ke-1 sampai ke-5. Perhatikan struktur tabel apabila dibuat secara manual:\n\ntabel_kuadrat = [\n    [1, 1],\n    [2, 4],\n    [3, 9],\n    [4, 16],\n    [5, 15]\n]\nprint(tabulate(tabel_kuadrat, headers=[\"i\", \"kuadrat\"]))\n\n  i    kuadrat\n---  ---------\n  1          1\n  2          4\n  3          9\n  4         16\n  5         15\n\n\nTerlihat bahwa tabel tersebut memiliki lima baris, dan tiap baris berupa list yang merupakan elemen dari list besar tabel_kuadrat. Kita bisa membuatnya secara “otomatis” atau secara pemrograman:\n\ntabel_mentah = []\nfor i in range(1, 6): # mulai dari 1, lanjut selama kurang dari 6\n    calon_baris = [i, kuadrat(i)] # baris baru\n    tabel_mentah.append(calon_baris) # menambahkan baris baru ke list besar\n\nprint(tabulate(tabel_mentah, headers=[\"i\", \"kuadrat\"]))\n\n  i    kuadrat\n---  ---------\n  1          1\n  2          4\n  3          9\n  4         16\n  5         25\n\n\nTentu saja, calon_baris tidak harus langsung jadi ketika baru didefinisikan. Tiap bagian dari suatu baris bisa saja ditambahkan secara berangsur-angsur:\n\ntabel_mentah = []\nfor i in range(1, 6): # mulai dari 1, lanjut selama kurang dari 6\n    calon_baris = [] # baris baru\n    calon_baris.append(i) # bagian pertama pada baris\n\n    # bagian kedua pada baris\n    nilai_kedua = kuadrat(i)\n    calon_baris.append(nilai_kedua)\n\n    tabel_mentah.append(calon_baris) # menambahkan baris baru ke list besar\n\nprint(tabulate(tabel_mentah, headers=[\"i\", \"kuadrat\"]))\n\n  i    kuadrat\n---  ---------\n  1          1\n  2          4\n  3          9\n  4         16\n  5         25\n\n\nAdanya lebih dari dua kolom juga sangat memungkinkan, tinggal ditambahkan ke calon_baris:\n\ntabel_mentah = []\nfor i in range(1, 6): # mulai dari 1, lanjut selama kurang dari 6\n    calon_baris = [] # baris baru\n\n    # bagian pertama pada baris\n    calon_baris.append(i)\n\n    # bagian kedua pada baris\n    nilai_kedua = kuadrat(i)\n    calon_baris.append(nilai_kedua)\n\n    # bagian ketiga\n    calon_baris.append(i**3)\n\n    # bagian keempat\n    calon_baris.append(i**4)\n\n    tabel_mentah.append(calon_baris) # menambahkan baris baru ke list besar\n\nprint(tabulate(tabel_mentah, headers=[\"i\", \"kuadrat\", \"pangkat tiga\",\"pangkat empat\"]))\n\n  i    kuadrat    pangkat tiga    pangkat empat\n---  ---------  --------------  ---------------\n  1          1               1                1\n  2          4               8               16\n  3          9              27               81\n  4         16              64              256\n  5         25             125              625\n\n\nApabila kita sudah memiliki data tiap kolom dalam bentuk list, kita bisa membentuk calon_baris pada tiap iterasi for loop dengan mengakses elemen ke-i dari tiap list.\n\n# misalnya data ini sudah ada, atau sudah diolah sebelumnya\nkolom_awal = [1, 2, 3, 4, 5]\nkolom_kuadrat = [1, 4, 9, 16, 25]\nkolom_tiga = [1, 8, 27, 64, 125]\nkolom_empat = [1, 16, 81, 256, 625]\n\n# mari kita buat tabel\ntabel_mentah = []\nfor i in range(0, 5): # indeks list dimulai dari nol, lanjut selama i &lt; 5\n    calon_baris = []\n\n    # elemen ke-i dari tiap list kolom\n    calon_baris.append(kolom_awal[i])\n    calon_baris.append(kolom_kuadrat[i])\n    calon_baris.append(kolom_tiga[i])\n    calon_baris.append(kolom_empat[i])\n\n    tabel_mentah.append(calon_baris)\n\nprint(tabulate(tabel_mentah, headers=[\"i\", \"kuadrat\", \"pangkat tiga\",\"pangkat empat\"]))\n\n  i    kuadrat    pangkat tiga    pangkat empat\n---  ---------  --------------  ---------------\n  1          1               1                1\n  2          4               8               16\n  3          9              27               81\n  4         16              64              256\n  5         25             125              625\n\n\nBagaimana kalau misalnya ada data yang tidak lengkap? Kita bisa saja menggunakan try-except, untuk memasukkan “X” ketika ada data yang tidak lengkap, sekaligus menghindari error:\n\n# contoh data\nkolom_awal = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nkolom_kuadrat = [1, 4, 9, 16, 25]\n\ntabel_mentah = []\nfor i in range(0, 10): # indeks list dimulai dari nol, lanjut selama i &lt; 10\n    calon_baris = []\n\n    # elemen ke-i dari tiap list kolom\n    calon_baris.append(kolom_awal[i])\n    \n    try:\n        calon_baris.append(kolom_kuadrat[i])\n    except IndexError:\n        calon_baris.append(\"X\")\n\n    tabel_mentah.append(calon_baris)\n\nprint(tabulate(tabel_mentah, headers=[\"i\", \"kuadrat\"]))\n\n  i  kuadrat\n---  ---------\n  1  1\n  2  4\n  3  9\n  4  16\n  5  25\n  6  X\n  7  X\n  8  X\n  9  X\n 10  X\n\n\nNumPy juga memiliki semacam tipe data atau nilai yang standar untuk menandakan data yang hilang atau tidak tersedia, yaitu NaN (Not a Number), melalui numpy.nan. Sehingga, \"X\" pada kode di atas bisa diganti dengan numpy.nan:\n\n# contoh data\nkolom_awal = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nkolom_kuadrat = [1, 4, 9, 16, 25]\n\ntabel_mentah = []\nfor i in range(0, 10): # indeks list dimulai dari nol, lanjut selama i &lt; 10\n    calon_baris = []\n\n    # elemen ke-i dari tiap list kolom\n    calon_baris.append(kolom_awal[i])\n    \n    try:\n        calon_baris.append(kolom_kuadrat[i])\n    except IndexError:\n        calon_baris.append(np.nan)\n\n    tabel_mentah.append(calon_baris)\n\nprint(tabulate(tabel_mentah, headers=[\"i\", \"kuadrat\"]))\n\n  i    kuadrat\n---  ---------\n  1          1\n  2          4\n  3          9\n  4         16\n  5         25\n  6        nan\n  7        nan\n  8        nan\n  9        nan\n 10        nan\n\n\n\n\n\nDalam pembelajaran metode numerik, seringkali kita perlu membandingkan hasil aproksimasi kita dengan nilai yang sesungguhnya. Seringkali pula, sebenarnya nilai yang sesungguhnya itu dapat kita peroleh (karena kita masih dalam tahap belajar; penerapan metode numerik di dunia nyata adalah pada kasus di mana nilai eksak tidak dapat diperoleh).\nHasil perhitungan eksak (seperti perhitungan menggunakan aljabar biasa atau ilmu kalkulus) juga disebut hasil perhitungan analitik atau simbolik. Istilah “analitik” bisa dianggap antonim dari istilah “numerik”.\nDi Python, ada module/package bernama SymPy (symbolic Python) yang dapat melakukan perhitungan simbolik, seperti menghitung turunan, yang misalnya digunakan di metode Newton.\n(Fun fact: aplikasi/package di komputer yang dapat melakukan perhitungan simbolik disebut Computer Algebra System (CAS). Beberapa contoh CAS adalah SymPy, Wolfram Mathematica, dan Maple.)\nMari kita import sympy:\n\nimport sympy\n\nSeperti untuk NumPy dan tabulate, apabila terjadi error karena sympy tidak ditemukan, artinya package sympy belum terinstall, dan bisa di-install menggunakan pip install sympy (atau dengan tanda seru: !pip install sympy)\n\npip install sympy\n\nRequirement already satisfied: sympy in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (1.11.1)\nRequirement already satisfied: mpmath&gt;=0.19 in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from sympy) (1.2.1)\nNote: you may need to restart the kernel to use updated packages.\n\n\nTentunya, penggunaan SymPy melibatkan variabel. Misalnya, kita ingin melakukan perhitungan simbolik dengan variabel \\(x\\). Kita perlu memberitahu SymPy, dengan syntax seperti berikut:\n\nx = sympy.symbols(\"x\")\n\nArtinya, kita baru saja memberitahu SymPy bahwa, pada string apapun yang dijumpai oleh SymPy, huruf “x” perlu dianggap sebagai simbol, atau lebih tepatnya sebagai variabel.\nPerhatikan pula bahwa kode di atas adalah assignment ke variabel pemrograman yang juga bernama x. Dengan demikian, untuk ke depannya, variabel x yang kita ketik di mana saja pada program kita akan dianggap sebagai variabel “x” oleh SymPy.\nDengan variabel x tersebut, kita dapat mendefinisikan suatu expression (ekspresi atau kalimat matematika), misal \\(5x^4\\), seperti berikut:\n\npolinom = 5 * (x ** 4) / 2\nprint(polinom)\n\n5*x**4/2\n\n\nSymPy memiliki fitur pprint (pretty print), yaitu menampilkan suatu ekspresi secara cantik atau indah, layaknya seperti kita tulis di kertas:\n\nsympy.pprint(polinom)\n\n   4\n5⋅x \n────\n 2  \n\n\nUntuk melakukan diferensiasi atau menghitung turunan (dalam hal ini secara simbolik/analitik), gunakan sympy.diff:\n\nturunan = sympy.diff(polinom, x)\nsympy.pprint(turunan)\n\n    3\n10⋅x \n\n\ndengan begitu, SymPy menghitung turunan dari ekspresi polinom yang kita berikan itu, terhadap variabel x. Sebenarnya, mengetik sympy.diff(polinom) saja sudah cukup, tapi lebih lengkap lebih baik.\nSejauh ini, semua ekspresi yang kita jumpai masih berbentuk simbol/tulisan, sehingga kita belum bisa men-substitusi variabel x dengan sembarang nilai. Misalnya kita ingin menjadikan ekspresi di atas sebagai suatu fungsi func(x), di mana kita bisa memasukkan nilai x apapun dan mendapatkan hasil. Caranya adalah menggunakan sympy.lambdify:\n\nfunc = sympy.lambdify(x, turunan)\nprint(func(5))\n\n1250\n\n\nPada syntax lambdify di atas, kita perlu memberitahu SymPy terlebih dahulu, variabel apa yang digunakan pada ekspresi tersebut; barulah kita tuliskan ekspresinya. Dalam hal ini, kita mengetik sympy.lambdify(x, turunan) karena sedang menggunakan variabel x untuk ekspresi turunan yang ingin kita ubah menjadi fungsi yang bisa di-substitusi nilai x nya.\nFungsi hasil lambdify sudah bisa digunakan seperti fungsi lainnya pada Python. Bahkan, kita bisa mencampur penggunaan SymPy dengan NumPy (maupun package lainnya). Contohnya, setelah tadi memperoleh func(x) dari SymPy:\n\nimport numpy as np\n\n\narr = np.array([2, 3, 5, 10])\nprint(func(arr))\n\n[   80   270  1250 10000]\n\n\nSeperti NumPy, SymPy juga memiliki fungsi sin, cos, log, exp dll, sehingga kita bisa melakukan perhitungan analitik yang melibatkan fungsi-fungsi tersebut.\n\ng = x**2 * sympy.cos(x) + sympy.exp(-5*x)\nprint(\"Fungsinya:\")\nsympy.pprint(g)\n\ngp = sympy.diff(g, x)\nprint(\"Turunannya:\")\nsympy.pprint(gp)\n\nFungsinya:\n 2           -5⋅x\nx ⋅cos(x) + ℯ    \nTurunannya:\n   2                          -5⋅x\n- x ⋅sin(x) + 2⋅x⋅cos(x) - 5⋅ℯ    \n\n\nMeskipun kita bisa saja melakukan, misalnya, from sympy import cos, hal tersebut tidak disarankan, apalagi ketika program kita juga menggunkaan NumPy dengan from numpy import cos atau bahkan from numpy import *. Alasannya, dengan begitu, program bisa menjadi membingungkan, karena tidak ada pembeda antara cos dari NumPy (numerik) dengan cos dari SymPy (analitik/simbolik).\nNamun, kalau Anda berhati-hati dan hanya melakukan hal tersebut untuk salah satu package saja, silakan.\nMenariknya, SymPy bisa jadi lebih unggul daripada NumPy untuk beberapa perhitungan yang melibatkan akurasi tinggi, terutama untuk perhitungan yang sebenarnya bersifat analitik. Misalnya, kita tahu bahwa \\(\\sin(\\pi) = 0\\). Menurut SymPy,\n\nprint(\"Menurut SymPy, sin(pi) = \" + str(sympy.sin(sympy.pi)))\n\nMenurut SymPy, sin(pi) = 0\n\n\nkarena SumPy menghitung nilai sin dari \\(\\pi\\) secara analitik, yaitu tanpa perlu menghitung nilai \\(\\pi\\) (karena nilainya sudah jelas nol berdasarkan sifat fungsi sin). Sedangkan, NumPy mengaproksimasi nilai \\(\\pi\\) terlebih dahulu, barulah hasil aproksimasi tersebut yang masuk ke fungsi sin. Hasil perhitungan fungsi sin tersebut pun juga aproksimasi, sehingga didapatkan hasil seperti berikut, yaitu sangat kecil tetapi bukan nol:\n\nprint(\"Menurut NumPy, sin(pi) = \" + str(np.sin(np.pi)))\n\nMenurut NumPy, sin(pi) = 1.2246467991473532e-16\n\n\ndi mana “e-16” artinya “dikali 10 pangkat -16”.\n\n\n\nMetode Bisection adalah salah satu metode yang dapat kita gunakan dalam masalah pencarian akar (root finding). Akar dari suatu persamaan didefinisikan sebagai nilai \\(x\\) yang memenuhi \\(f(x) = 0\\). Misalkan \\(f\\) adalah suatu fungsi kontinu terdefinisi di \\([a,b]\\), di mana \\(f(a)\\) dan \\(f(b)\\) berlawanan tanda (sehingga pasti ada akar pada interval tersebut, menurut Teorema Nilai Antara / Intermediate Value Theorem).\nInti sari dari metode Bisection adalah\n\nmenebak bahwa akar suatu persamaan ada di dalam interval tertentu \\([a, b]\\);\nmenelusuri nilai fungsi pada nilai tengah atau rata-rata dari interval tersebut;\nmempersempit interval dengan memanfaatkan hasil rata-rata tersebut; dan\nterus mencari nilai tengah dari interval yang baru, yang kemudian dipersempit lalu dicari nilai tengahnya, dan seterusnya hingga akar ditemukan, atau hingga ukuran interval sudah cukup kecil sehingga memuaskan (yaitu sudah lebih kecil dari toleransi).\n\nDidefinisikan nilai tengah dari interval:\n\\[p=\\frac{(a+b)}{2}\\]\nAkan dicari \\(f(p)\\) dengan syarat sebagai berikut:\n\njika \\(f(p) = 0\\), maka \\(p\\) adalah akar dari \\(f\\)\njika \\(f(p)f(a) &gt; 0\\), maka \\(\\text{sign}(f(p)) = \\text{sign}(f(a))\\). Sehingga, kita dapat mempersempit interval dengan memilih batasan baru yaitu a = p dan b tidak berubah.\njika \\(f(p)f(a) &lt; 0\\), maka \\(\\text{sign}(f(p)) \\neq \\text{sign} (f(a))\\), atau \\(\\text{sign}(f(p)) = \\text{sign}(f(b))\\). Sehingga, kita dapat mempersempit interval dengan memilih batasan baru yaitu a tidak berubah dan b = p.\n\nMetode Bisection memiliki order of convergence = 1, atau disebut memiliki kekonvergenan linier (linear convergence). Artinya, dalam proses menemukan akar persamaan (konvergen menuju jawabannya), metode Bisection tidak secepat beberapa metode lainnya yang memiliki order of convergence yang lebih tinggi.\n\ndef Bisection(f, lower, upper, tol):\n    if f(lower)*f(upper)&lt;0:\n        p0=lower\n        p=(lower+upper)/2\n\n        if f(p)==0:\n            return p\n        elif f(p)*f(lower)&gt;0:\n            lower=p\n        elif f(p)*f(lower)&lt;0:\n            upper=p\n \n        abs_error=abs(p0-p)\n        p0=p\n \n        while abs_error &gt; tol:\n            p=(lower+upper)/2\n            \n            if f(p)==0:\n                break\n            elif f(p)*f(lower)&gt;0:\n                lower=p\n            elif f(p)*f(lower)&lt;0:\n                upper=p\n        \n            abs_error=abs(p0-p)\n            p0=p\n \n        return p\n \n    elif f(lower)*f(upper)&gt;0:\n        return \"Metode gagal mengaproksimasi akar. Silakan ubah batas atas atau batas bawah\"\n    elif f(lower)==0:\n        return lower\n    else: #f(upper)==0\n        return upper\n\n\nfrom numpy import sin, cos, tan, log, exp, sqrt, pi\n\nformula = input('Masukkan formula fungsi: ')\n\ndef f(x):\n    return eval(formula)\n\nlow_bound = eval(input(\"Masukkan batas bawah interval: \"))\nup_bound = eval(input(\"Masukkan batas atas interval: \"))\ntoleransi = eval(input(\"Masukkan toleransi aproksimasi: \"))\n\nakar_bisection=Bisection(f, low_bound, up_bound, toleransi)\n\ntry:\n    print(f\"Akar persamaan {formula} = 0 adalah x = {akar_bisection}\")\nexcept ValueError:\n    print(akar_bisection)\n\nMasukkan formula fungsi: 2*x - 3*cos(x) + exp(-5*x) - 9\nMasukkan batas bawah interval: -3\nMasukkan batas atas interval: 2\nMasukkan toleransi aproksimasi: 10**(-7)\nAkar persamaan 2*x - 3*cos(x) + exp(-5*x) - 9 = 0 adalah x = -0.5073225051164627\n\n\n\n\n\nInti sari dari Metode Fixed-Point adalah mencari fixed-point (titik tetap) dari suatu fungsi (misal fungsi \\(g(x)\\)), yaitu suatu nilai \\(p\\) sehingga \\(p = g(p)\\), atau \\(p - g(p) = 0\\). Titik \\(p\\) disebut titik tetap, karena ketika nilai \\(p\\) dimasukkan ke fungsi \\(g(x)\\), hasilnya tetaplah \\(p\\). Untuk nilai \\(x\\) yang dekat dengan \\(p\\), biasanya ada kecenderungan nilai \\(g(x)\\) menjadi semakin mendekati \\(p\\).\nPerhatikan bahwa, sembarang persamaan \\(f(x) = 0\\) bisa diubah bentuknya dengan mendefinisikan fungsi \\(g(x) = x - f(x)\\) (sehingga \\(f(x) = x - g(x)\\)). Dengan demikian, permasalahan mencari akar berubah menjadi permasalahan mencari fixed-point, yaitu mencari nilai \\(p\\) sehingga \\(p = g(p)\\) atau \\(p - g(p) = 0\\) (sehingga nilai \\(p\\) tersebut juga menyebabkan \\(f(p) = 0\\)).\n(Tentu saja, itu bukanlah satu-satunya cara untuk mengubah permasalahan mencari akar menjadi permasalahan mencari fixed-point. Bahkan, tidak semua pilihan \\(g(x)\\) yang memungkinkan itu dijamin memiliki fixed-point.)\nMisalkan \\(g\\) adalah fungsi kontinu dan memiliki fixed-point \\(p\\) pada interval \\([a,b]\\) (dan diasumsikan bahwa \\(g\\) memenuhi persyaratan untuk kekonvergenan metode fixed-point). Artinya, ada \\(p \\in [a,b]\\) sehingga \\(g(x) = x\\). Untuk mengaproksimasi penyelesaian dari persamaan \\(g(x) = x\\), diperlukan suatu tebakan awal \\(p_0\\), kemudian iterasinya adalah:\n\\[p_n = g(p_{n-1})\\]\nNilai tersebut terus dimasukkan ke dalam \\(g\\) sehingga, diharapkan, nilai \\(p_n\\) menjadi semakin mendekati suatu nilai \\(p\\) yang membuat \\(g(p) = p\\).\nPada umumnya, metode fixed-point memiliki kekonvergenan linier. Ketika \\(g(x)\\) dijamin memliki tepat satu fixed-point (atau fixed-point yang unik) pada suatu interval \\([a,b]\\), maka Metode Fixed-Point dengan \\(p_0\\) pada interval tersebut pasti memiliki kekonvergenan linier. Terkadang Metode Fixed-Point lebih cepat daripada Metode Bisection, dan terkadang Metode Bisection lebih cepat daripada Metode Fixed-Point.\nHati-hati, ada kemungkinan bahwa \\(g(p_n)\\) malah menjauhi \\(p\\), contohnya untuk \\(g(x) = x^2\\) dan \\(p_0 &gt; 1\\) (padahal \\(g(1) = 1\\)). Pada kasus seperti itu, metode fixed-point tidak dijamin konvergen (artinya tidak dijamin bisa menemukan fixed-point).\nSebagai contoh penggunaan metode fixed-point, kalian bisa mencoba untuk menyelesaikan persamaan (masalah mencari akar) berikut ini,\n\\[f(x) = x^2 - x - 1 = 0\\]\ndengan sedikit manipulasi aljabar (dibagi \\(x\\), pindah ruas) agar mendapatkan bentuk \\(x = g(x)\\),\n\\[x = 1 + \\frac{1}{x}\\]\nsehingga, dengan \\(g(x) = 1 + \\frac{1}{x}\\) bisa digunakan metode fixed-point, misal dengan tebakan awal \\(x = 2\\) atau \\(x = -3\\).\n(Jelas metode ini akan gagal untuk \\(g(x)\\) tersebut apabila dipilih tebakan awal seperti \\(x=0\\), \\(x=-1\\), atau bahkan \\(x=-\\frac{1}{2}\\) karena akan terjadi pembagian nol. Kemungkinan terjadinya pembagian nol itu bukan hanya dari metodenya seperti metode Newton, tetapi juga dari fungsi \\(f(x)\\) atau \\(g(x)\\) yang digunakan.)\nSilakan coba dengan kode di bawah ini!\nSebagai pembanding, kalian bisa menyelesaikan persamaan kuadrat \\(f(x) = x^2 - x - 1 = 0\\) di atas, dan mendapatkan solusi\n\\[x_1 = \\frac{1+\\sqrt{5}}{2} \\approx 1.618\\]\n\\[x_2 = \\frac{1-\\sqrt{5}}{2} \\approx -0.618\\]\nKebetulan, konstanta berikut ini yang berlambang phi kecil (\\(\\phi\\)),\n\\[\\phi = \\frac{1+\\sqrt{5}}{2}\\]\nadalah konstanta istimewa yang bernama golden ratio.\n\nfrom tabulate import tabulate\n\ndef FixedPoint(g, p0, tol):\n    table = [[\"iterasi\",\"Aproksimasi\"]]\n    iterasi = []\n    \n    i = 1\n    p = g(p0)\n    abs_error = abs(p-p0)\n    p0 = p\n    iterasi.append(i)\n    iterasi.append(p)\n    table.append(iterasi)\n\n    while abs_error &gt; tol:\n        iterasi = []\n        i += 1\n        p = g(p0)\n        abs_error = abs(p-p0)\n        p0 = p\n        iterasi.append(i)\n        iterasi.append(p)\n        table.append(iterasi)\n    \n    tabel_siap_print = tabulate(table,headers = 'firstrow',tablefmt=\"pretty\")\n    return p0, tabel_siap_print\n\n\nfrom numpy import cos, sin, tan, log, exp, sqrt\n\nformula = input(\"Masukkan formula g(x): \")\n\ndef g(x):\n    return eval(formula)\n\ntebakan_awal = eval(input(\"Masukkan titik awal iterasi: \"))\ntoleransi = eval(input(\"Masukkan batas toleransi: \"))\n\nfixed_point, tabel = FixedPoint(g, tebakan_awal, toleransi)\n\nprint(tabel)\nprint(f\"Ditemukan fixed point dari g(x) = {formula} yaitu x = {fixed_point}\")\n\nMasukkan formula g(x): 1 + 1/x\nMasukkan titik awal iterasi: 2\nMasukkan batas toleransi: 10**(-7)\n+---------+--------------------+\n| iterasi |    Aproksimasi     |\n+---------+--------------------+\n|    1    |        1.5         |\n|    2    | 1.6666666666666665 |\n|    3    |        1.6         |\n|    4    |       1.625        |\n|    5    | 1.6153846153846154 |\n|    6    | 1.619047619047619  |\n|    7    | 1.6176470588235294 |\n|    8    | 1.6181818181818182 |\n|    9    | 1.6179775280898876 |\n|   10    | 1.6180555555555556 |\n|   11    | 1.6180257510729614 |\n|   12    | 1.6180371352785146 |\n|   13    | 1.6180327868852458 |\n|   14    | 1.618034447821682  |\n|   15    | 1.618033813400125  |\n|   16    | 1.6180340557275543 |\n|   17    | 1.6180339631667064 |\n+---------+--------------------+\nDitemukan fixed point dari g(x) = 1 + 1/x yaitu x = 1.6180339631667064\n\n\n\n\n\nMisalkan \\(f\\) kontinu dan terturunkan (memiliki turunan) di \\([a,b]\\) dan ada tebakan awal \\(p_0 \\in\\) \\([a,b]\\) sedemikian sehingga \\(f'(p_0) \\neq 0\\). Iterasi pada metode Newton untuk menyelesaian \\(f(x) = 0\\) adalah sebagai berikut:\n\\[p_n = p_{n-1} - \\frac{f(p_{n-1})}{f'(p_{n-1})}\\]\nDiharapkan bahwa, setelah banyak iterasi, nilai \\(p_n\\) yang diperoleh akan membuat \\(f(p) = 0\\) atau setidaknya sangat dekat dengan nol (lebih kecil dari batas toleransi yang kita anggap sudah memuaskan).\nMetode Newton juga dapat dipandang sebagai metode fixed-point dengan \\(g(x) = x - \\frac{f(x)}{f'(x)}\\)\nMetode Newton gagal apabila, pada suatu iterasi, tiba-tiba \\(f'(p_n) = 0\\).\nPada umumnya, Metode Newton memiliki order of convergence = 2, atau juga disebut memiliki kekonvergenan kuadratik (quadratic convergence). Artinya, selama berhasil, Metode Newton lebih cepat daripada Metode Bisection maupun Metode Fixed-Point.\n\ndef NewtonAnalitik(f,fp,p0,tolerance):\n    p = p0 - f(p0)/fp(p0)\n    abs_error = abs(p-p0)\n    p0 = p\n\n    while abs_error &gt; tolerance:\n\n        try:\n            p = p0 - f(p0)/fp(p0)\n        except ZeroDivisionError:\n            return \"Metode gagal mengaproksimasi akar. Silakan pilih tebakan awal lain\"\n        \n        abs_error = abs(p-p0)\n        p0 = p\n    return p\n\n\nimport sympy\nfrom numpy import sin, cos, tan, log, exp, sqrt\n\nformula = input(\"Masukkan fungsi: \")\ndef f(x):\n    return eval(formula)\n\nx = sympy.symbols(\"x\")\n\ndf_string = str(sympy.diff(formula, x))\ndef fp(x): # turunan f\n    return eval(df_string)\n\ntebakan_awal = eval(input(\"Masukkan tebakan awal / titik awal iterasi: \"))\ntolerance = eval(input(\"Masukkan toleransi aproksimasi: \"))\n\nakar_newton = NewtonAnalitik(f, fp, tebakan_awal, tolerance)\n\nprint(f\"Akar dari persamaan f(x) = {formula} adalah x = {akar_newton}\")\n\nMasukkan fungsi: 2*x - 3*cos(x) + exp(-5*x) - 9\nMasukkan tebakan awal / titik awal iterasi: -1\nMasukkan toleransi aproksimasi: 10**(-7)\nAkar dari persamaan f(x) = 2*x - 3*cos(x) + exp(-5*x) - 9 adalah x = -0.5073224866379573\n\n\n\n\n\nSalah satu kekurangan Metode Newton yang biasa adalah harus mengetahui rumus turunannya secara analitik. Sebelum adanya CAS seperti SymPy, turunan analitik harus dihitung secara manual dengan kalkulus. Kalau bentuk rumus untuk \\(f(x)\\) sangat rumit, perhitungan turunan menjadi jauh lebih rumit. Untuk menghindari menghitung turunan secara analitik, kita dapat menggunakan definisi turunan (yang menggunakan limit):\n\\[f'(x) = \\lim_{h \\rightarrow 0} \\frac{f(x+h) - f(x)}{h}\\]\ndengan memilih nilai \\(h\\) yang cukup kecil (sayangnya, kita tidak bisa membuat limit \\(h\\) menuju nol). Nilai \\(h\\) yang cukup kecil itu disebut suatu beda hingga (finite difference).\nSehingga, modifikasi metode Newton ini bisa disebut Metode Newton dengan Beda Hingga (Finite-Difference Newton’s Method). Untuk fungsi \\(f\\) yang kontinu, akar persamaan \\(f(x) = 0\\) bisa ditentukan dengan iterasi sebagai berikut:\n\\[\\begin{align*}\np_n &= p_{n-1} - \\frac{f(p_{n-1})}{\\left(\\frac{f\\left(p_{n-1}+h\\right)-f(p_{n-1})}{h}\\right)} \\\\\n&= p_{n-1} - \\frac{f(p_{n-1})h}{f(p_{n-1}+h)-f(p_{n-1})}\n\\end{align*}\\]\ndengan tebakan awal \\(p_0\\). Perhatikan bahwa \\(f'(p_{n-1})\\) pada metode Newton yang biasa itu telah digantikan dengan\n\\[f'(p_{n-1}) \\approx \\frac{f(p_{n-1}+h) - f(p_{n-1})}{h}\\]\nTujuan modifikasi tersebut adalah agar iterasi dapat dilakukan pada titik di mana turunannya tidak ada, atau ketika turunan analitik sulit diperoleh.\n\ndef FiniteDifferenceNewton(f,fp,p0,tolerance):\n    p = p0 - f(p0)/fp(p0)\n    abs_error = abs(p-p0)\n    p0 = p\n\n    while abs_error &gt; tolerance:\n        p = p0 - f(p0)/fp(p0)\n        abs_error = abs(p-p0)\n        p0 = p\n    return p\n\n\nfrom numpy import sin, cos, tan, log, exp, sqrt\n\nformula = input(\"Masukkan fungsi: \")\ndef f(x):\n    return eval(formula)\n\ndef fp(x, h=10**(-12)):\n    return (f(x+h)-f(x))/h\n\nstarting_point = eval(input(\"Masukkan titik awal iterasi: \"))\ntolerance = eval(input(\"Masukkan toleransi aproksimasi: \"))\n\nakar_fd = FiniteDifferenceNewton(f,fp,starting_point,tolerance)\n\nprint(f\"Akar dari persamaan f(x) = {formula} adalah x = {akar_fd}\")\n\nMasukkan fungsi: 2*x - 3*cos(x) + exp(-5*x) - 9\nMasukkan titik awal iterasi: -1\nMasukkan toleransi aproksimasi: 10**(-7)\nAkar dari persamaan f(x) = 2*x - 3*cos(x) + exp(-5*x) - 9 adalah x = -0.5073224866379543\n\n\n\n\n\n\n\nBagaimana kalau misalnya kita sudah punya suatu fungsi yang melakukan perhitungan secara iteratif dan hanya menampilkan hasil akhirnya, tetapi kita ingin memperoleh tiap hasil iterasi, bukan hasil akhirnya saja? Contohnya, fungsi menghitung faktorial \\(n! = n * (n-1) * \\dots * 3 * 2 * 1\\) berikut ini,\n\ndef faktorial(n):\n    \n    # nilai awal\n    hasil = 1\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n    \n    # mengembalikan hasil akhir setelah semua iterasi selesai\n    return hasil\n\n# peroleh hasil akhir dari fungsi faktorial, kemudian print\nprint(faktorial(5))\n\n120\n\n\nKita bisa saja melakukan print (di dalam fungsinya) tiap kali nilai hasil diperbarui.\n\ndef faktorial(n):\n    \n    # nilai awal\n    hasil = 1\n    print(hasil) # tampilkan hasil\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n        print(hasil) # tampilkan hasil yang baru\n    \n    # tidak perlu return karena sudah menggunakan print\n\n# fungsi cukup dipanggil saja,\n# karena print sudah ada di dalam fungsi\nfaktorial(5)\n\n1\n2\n6\n24\n120\n\n\nAlternatifnya, kita bisa memasukkan tiap hasil baru ke dalam suatu list, yang kemudian dikembalikan oleh fungsi, lalu kita bisa print list tersebut.\n\ndef ListFaktorial(n):\n    list_baru = []\n    \n    # nilai awal\n    hasil = 1\n    list_baru.append(hasil) # tambahkan ke list\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n        list_baru.append(hasil) # tambahkan tiap hasil baru ke list\n    \n    # kembalikan list semua hasil\n    return list_baru\n\n# peroleh list dari fungsi di atas, kemudian print\nprint(ListFaktorial(5))\n\n[1, 2, 6, 24, 120]\n\n\nBahkan, list ini bisa diubah menjadi tabel!\n\ndef ListFaktorial(n):\n    list_baru = []\n    \n    # nilai awal\n    hasil = 1\n    list_baru.append(hasil) # tambahkan ke list\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n        list_baru.append(hasil) # tambahkan tiap hasil baru ke list\n    \n    # kembalikan list semua hasil\n    return list_baru\n\n# kolom nilai i\nkolom_kiri = [1, 2, 3, 4, 5]\n# bisa juga dibuat dengan for loop dengan range(1,6) append i\n\n# peroleh list dari fungsi di atas\nkolom_kanan = ListFaktorial(5)\n\n# \"gabung\" kedua kolom menjadi satu tabel, seperti biasa\ntabel_mentah = []\nfor i in range(0,5):\n    calon_baris = []\n    calon_baris.append(kolom_kiri[i])\n    calon_baris.append(kolom_kanan[i])\n    tabel_mentah.append(calon_baris)\n\ntabel_olahan = tabulate(tabel_mentah, headers=[\"i\", \"faktorial\"])\nprint(tabel_olahan)\n\n  i    faktorial\n---  -----------\n  1            1\n  2            2\n  3            6\n  4           24\n  5          120\n\n\nPerhatikan bahwa kita memerlukan dua list untuk membentuk tabel di atas. Bisa saja, kita membentuk kedua list sepenuhnya di dalam fungsi. Dengan begitu, setelah menggunakan fungsi, kita tinggal membentuk tabel dari kedua list.\n\ndef DuaListFaktorial(n):\n    kolom_kiri = [] # berisi i\n    kolom_kanan = [] # berisi faktorial atau i!\n    \n    # nilai awal\n    hasil = 1\n\n    # tambahkan ke list\n    kolom_kiri.append(1)\n    kolom_kanan.append(hasil)\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n\n        # tambahkan tiap hasil baru ke list\n        kolom_kiri.append(i)\n        kolom_kanan.append(hasil)\n    \n    # kembalikan kedua list\n    return kolom_kiri, kolom_kanan\n\n# peroleh kedua list dari fungsi\nkolom_kiri, kolom_kanan = DuaListFaktorial(5)\n\n# \"gabung\" kedua kolom menjadi satu tabel, seperti biasa\ntabel_mentah = []\nfor i in range(0,5):\n    calon_baris = []\n    calon_baris.append(kolom_kiri[i])\n    calon_baris.append(kolom_kanan[i])\n    tabel_mentah.append(calon_baris)\n\ntabel_olahan = tabulate(tabel_mentah, headers=[\"i\", \"faktorial\"])\nprint(tabel_olahan)\n\n  i    faktorial\n---  -----------\n  1            1\n  2            2\n  3            6\n  4           24\n  5          120\n\n\nKalau mau, bahkan proses pembentukan tabel juga bisa dilakkukan di dalam fungsi, sehingga fungsi memberikan output berupa tabel yang siap diolah tabulate.\n\ndef TabelFaktorial(n):\n    kolom_kiri = [] # berisi i\n    kolom_kanan = [] # berisi faktorial atau i!\n    \n    # nilai awal\n    hasil = 1\n\n    # tambahkan ke list\n    kolom_kiri.append(1)\n    kolom_kanan.append(hasil)\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n\n        # tambahkan tiap hasil baru ke list\n        kolom_kiri.append(i)\n        kolom_kanan.append(hasil)\n    \n    tabel_mentah = []\n    for i in range(0,n):\n        # sampai indeks (n-1)\n        # nilai n tergantung banyaknya iterasi\n\n        calon_baris = []\n        calon_baris.append(kolom_kiri[i])\n        calon_baris.append(kolom_kanan[i])\n        tabel_mentah.append(calon_baris)\n    \n    return tabel_mentah\n\ntabel_mentah = TabelFaktorial(5)\n\ntabel_olahan = tabulate(tabel_mentah, headers=[\"i\", \"faktorial\"])\nprint(tabel_olahan)\n\n  i    faktorial\n---  -----------\n  1            1\n  2            2\n  3            6\n  4           24\n  5          120\n\n\nBahkan, pengolahan tabel bisa dilakukan di dalam fungsi…\n\ndef TabelFaktorial(n):\n    kolom_kiri = [] # berisi i\n    kolom_kanan = [] # berisi faktorial atau i!\n    \n    # nilai awal\n    hasil = 1\n\n    # tambahkan ke list\n    kolom_kiri.append(1)\n    kolom_kanan.append(hasil)\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n\n        # tambahkan tiap hasil baru ke list\n        kolom_kiri.append(i)\n        kolom_kanan.append(hasil)\n    \n    tabel_mentah = []\n    for i in range(0,n):\n        # sampai indeks (n-1)\n        # nilai n tergantung banyaknya iterasi\n\n        calon_baris = []\n        calon_baris.append(kolom_kiri[i])\n        calon_baris.append(kolom_kanan[i])\n        tabel_mentah.append(calon_baris)\n    \n    # mengolah tabel di dalam fungsi\n    tabel_olahan = tabulate(tabel_mentah, headers=[\"i\", \"faktorial\"])\n    return tabel_olahan\n\ntabel_jadi = TabelFaktorial(5)\nprint(tabel_jadi)\n\n  i    faktorial\n---  -----------\n  1            1\n  2            2\n  3            6\n  4           24\n  5          120\n\n\nTentu saja, nilai 5 itu selalu bisa diganti menjadi sembarang bilangan bulat positif, seperti 7, 10, 15, 22, atau bahkan lebih besar lagi, dan banyaknya baris akan menyesuaikan, karena pembentukan tabel dilakukan secara otomatis.\n\ntabel_jadi = TabelFaktorial(22)\nprint(tabel_jadi)\n\n  i               faktorial\n---  ----------------------\n  1                       1\n  2                       2\n  3                       6\n  4                      24\n  5                     120\n  6                     720\n  7                    5040\n  8                   40320\n  9                  362880\n 10                 3628800\n 11                39916800\n 12               479001600\n 13              6227020800\n 14             87178291200\n 15           1307674368000\n 16          20922789888000\n 17         355687428096000\n 18        6402373705728000\n 19      121645100408832000\n 20     2432902008176640000\n 21    51090942171709440000\n 22  1124000727777607680000\n\n\n\n\n\nPada Metode Newton dengan Beda Hingga, nilai \\(h\\) konstan. Kalau kita punya dua tebakan awal yang saling dekat, misal \\(p_0\\) dan \\(p_1\\), kita bisa saja memanfaatkannya dengan memasang \\(h = p_1 - p_0\\). Bahkan, ketika iterasi \\(p_n\\) sudah semakin dekat menuju akar, jarak antara \\(p_{n-1}\\) dan \\(p_{n-2}\\) menjadi semakin kecil. Sehingga, dengan memasang nilai \\(h = p_{n-2} - p_{n-1}\\) atau \\(h = p_{n-1} - p_{n-2}\\), kita berhasil membuat limit \\(h\\) menuju nol.\nModifikasi ini disebut Metode Secant, dengan iterasi sebagai berikut untuk menentukan penyelesaian \\(f(x) = 0\\) dengan fungsi \\(f\\) yang kontinu:\n\\[\\begin{align*}\np_n &= p_{n-1} - \\frac{f(p_{n-1})}{\\left(\\frac{f(p_{n-1})-f(p_{n-2})}{p_{n-1}-p_{n-2}}\\right)} \\\\\n&= p_{n-1} - \\frac{f(p_{n-1})(p_{n-1} - p_{n-2})}{f(p_{n-1}) - f(p_{n-2})}\n\\end{align*}\\]\nDibandingkan Metode Newton yang biasa, Metode Secant menggantikan \\(f'(p_{n-1})\\) dengan\n\\[f'(p_{n-1}) \\approx \\frac{f(p_{n-1}) - f(p_{n-2})}{p_{n-1} - p_{n-2}}\\]\nsehingga, tidak seperti Metode Newton yang hanya memerlukan satu tebakan awal, Metode Secant membutuhkan dua tebakan awal, yaitu \\(p_0\\) dan \\(p_1\\). Namun, dibandingkan dengan Metode Newton dengan Beda Hingga, nilai \\(h\\) atau beda hingga tersebut tidak perlu ditentukan secara manual.\nMenariknya, Metode Secant memiliki order of convergence = \\(\\phi \\approx 1.618\\).\n\ndef Secant(f,p0,p1,tolerance):\n    p = p1 - (f(p1)*(p1-p0))/(f(p1)-f(p0))\n    abs_error = abs(p-p1)\n    p0 = p1\n    p1 = p\n\n    while abs_error &gt; tolerance:\n        p = p1 - (f(p1)*(p1-p0))/(f(p1)-f(p0))\n        abs_error = abs(p-p1)\n        p0 = p1\n        p1 = p\n    return p\n\n\nfrom numpy import sin, cos, tan, log, exp, sqrt\nformula = input(\"Masukkan formula fungsi: \")\n\ndef f(x):\n    return eval(formula)\n\ntitik_1 = eval(input(\"Masukkan titik awal pertama: \"))\ntitik_2 = eval(input(\"Masukkan titik awal kedua: \"))\ntolerance = eval(input(\"Masukkan toleransi aproksimasi: \"))\n\nakar_secant = Secant(f,titik_1,titik_2,tolerance)\n\nprint(f\"Akar dari persamaan f(x) = {formula} adalah x = {akar_secant}\")\n\nMasukkan formula fungsi: 2*x - 3*cos(x) + exp(-5*x) - 9\nMasukkan titik awal pertama: -1\nMasukkan titik awal kedua: -2\nMasukkan toleransi aproksimasi: 10**(-7)\nAkar dari persamaan f(x) = 2*x - 3*cos(x) + exp(-5*x) - 9 adalah x = -0.5073224866425831\n\n\n\n\n\nSejauh ini, kita sudah membahas beberapa metode root-finding atau aproksimasi akar, yaitu:\n\nMetode Bisection\nMetode Fixed-Point\nMetode Newton biasa (dengan turunan analitik)\nMetode Newton dengan Beda Hingga (finite-difference Newton’s method)\nMetode Secant\n\nDi antara semua metode tersebut, hanya Metode Bisection yang dijamin konvergen menuju akar di interval yang diberikan; semua metode lain ada kemungkinan divergen (menjauh dari akar, seperti metode fixed-point) atau gagal karena terjadi pembagian nol. Sayangnya, Metode Bisection termasuk metode yang pelan di antara metode numerik lainnya.\nUntuk menjaga jaminan kekonvergenan oleh Metode Bisection tetapi memperbaiki kecepatan kekonvergenannya, kita bisa memodifikasi Metode Bisection, yaitu memodifikasi cara menentukan \\(p\\) yang baru yang akan mempersempit interval. Perhatikan bahwa Metode Bisection membutuhkan dua “tebakan awal” (lebih tepatnya dua batasan interval), sedangkan metode di atas yang juga membutuhkan dua tebakan awal hanyalah Metode Secant.\nApakah kita bisa menggunakan Metode Bisection, tetapi dengan modifikasi menentukan \\(p\\) seperti Metode Secant, agar mendapatkan order of convergence seperti Metode Secant?\nJawabannya adalah bisa, dan modifikasi tersebut dinamakan Metode Regula Falsi. Sehingga, Metode Regula Falsi bisa disebut perpaduan antara Metode Bisection dan Metode Secant.\nSebenarnya, perbedaan algoritma Metode Bisection dan Metode Regula Falsi hanya di satu baris saja, yaitu mengubah baris\n\\[p=\\frac{a+b}{2}\\]\nmenjadi\n\\[p = b - \\frac{f(b)(b-a)}{f(b) - f(a)}\\]\nsesuai Metode Secant. Perhatikan bahwa Metode Secant biasanya membutuhkan dua tebakan awal yang tidak harus sama dengan batasan interval, sedangkan Metode Regula Falsi secara otomatis menggunakan kedua batasan interval \\([a,b]\\) sebagai dua tebakan awal.\nUntuk pembuatan kode Metode Regula Falsi, kami serahkan ke kalian. Gampang, kok! Tinggal mengubah beberapa baris saja (baris yang menentukan nilai \\(p\\) yang baru) pada kode Metode Bisection, yaitu mengambil baris tersebut dari kode Metode Secant, kemudian menyesuaikan kedua tebakan awal menjadi kedua batasan interval.\nSeperti Metode Secant, Metode Regula Falsi juga memiliki order of convergence = \\(\\phi \\approx 1.618\\).\n\n\n\nSuatu “barisan” (sequence) adalah sekumpulan angka yang berurut. Artinya, pada suatu barisan, ada yang bisa disebut angka pertama (atau suku pertama), angka kedua (suku kedua), angka ketiga (suku ketiga), dan sebagainya. Banyaknya suku bisa berhingga maupun tak terhingga.\nSuku-suku pada suatu barisan itu bisa saja ditentukan secara manual atau sesuka hati, atau bisa juga menggunakan rumus. Intinya, suku-suku suatu barisan itu bisa diperoleh dari manapun, bahkan dari hasil iterasi metode numerik (\\(p_0\\), \\(p_1\\), \\(p_2\\), \\(p_3\\), …) juga bisa.\nOleh karena itu, contoh barisan berhingga adalah hasil iterasi fixed-point, misalnya dengan \\(g(x) = 1 + \\frac{1}{x}\\), tebakan awal \\(p_0 = 2\\), dan batas toleransi \\(10^{-7}\\):\n\\[\\begin{align*}\n(& 1.5, 1.6666666666666665, 1.6, \\\\\n& 1.625, 1.6153846153846154, \\\\\n& 1.619047619047619, \\dots, \\\\\n& 1.6180339631667064)\n\\end{align*}\\]\nProses tersebut berakhir setelah 17 iterasi, sehingga barisan tersebut memiliki 17 suku.\nBarisan tersebut bisa diberi nama, seperti \\(p_n\\) dengan \\(n = 1, 2, 3, \\dots, 17\\), yang bisa dituliskan \\(\\left\\{p_n\\right\\}_{n=1}^{17}\\) dengan kurung kurawal.\nContoh barisan tak berhingga adalah barisan aritmetika dan barisan geometri, seperti:\n\\[(-5, -2, 1, 4, 7, 10, 13, 16, 19, \\dots)\\]\n\\[\\left(16, 8, 4, 2, 1, \\frac{1}{2}, \\frac{1}{4}, \\frac{1}{8}, \\dots\\right)\\]\nBarisan tak berhingga dengan nama \\(p_n\\) yang mulai dari suku \\(n=1\\) bisa ditulis \\(\\left\\{p_n\\right\\}_{n=1}^{\\infty}\\) dengan kurung kurawal, atau singkatnya \\((p_n)\\) saja dengan kurung biasa (dengan begitu, biasanya ada asumsi bahwa barisan tersebut tak berhingga).\n\n\n\nAlexander Aitken menemukan bahwa, untuk sembarang barisan (termasuk sembarang metode numerik) yang memiliki kekonvergenan linier, untuk nilai \\(n\\) yang besar, berlaku\n\\[\\frac{p_{n+1} - p}{p_n - p} \\approx \\frac{p_{n+2} - p}{p_{n+1} - p}\\]\ndi mana \\(p\\) adalah nilai yang ingin dicari, sedangkan \\(p_n\\), \\(p_{n+1}\\), dan \\(p_{n+2}\\) adalah tiga suku barisan (atau tiga hasil aproksimasi) berturut-turut. Artinya, perbandingan error (error ratio) antar dua pasang hasil iterasi (diperoleh dari tiga hasil iterasi berturut-turut) menjadi kurang lebih sama. Dengan manipulasi aljabar, diperoleh\n\\[p \\approx p_n - \\frac{\\left(p_{n+1} - p_n\\right)^2}{p_{n+2} - 2p_{n+1} + p_n}\\]\nseolah-olah ada jalur pintas untuk langsung mendapatkan nilai yang ingin dicari.\nTentu saja, sebelum menggunakan rumus ini, kita perlu menemukan tiga hasil aproksimasi pertama, yaitu \\(p_0\\), \\(p_1\\), dan \\(p_2\\). Kemudian, barulah kita tentukan \\(p_3\\) menggunakan rumus Aitken (hasil rumus Aitken biasa disebut \\(\\hat{p}_n\\), sehingga bisa ditulis \\(p_3 = \\hat{p}_0\\), karena perhitungan \\(p_3\\) memanfaatkan \\(p_0\\), \\(p_1\\) dan \\(p_2\\)).\nVariabel \\(\\hat{p}\\) biasa disebut p-hat atau p-cap (kata “hat” atau “cap” artinya topi).\nApabila kita definisikan \\(\\Delta p_n = p_{n+1} - p_n\\) dan \\(\\Delta^2 p_n = p_{n+2} - 2p_{n+1} + p_n\\), rumus Aitken bisa ditulis\n\\[\\hat{p}_n = p_n - \\frac{(\\Delta p_n)^2}{\\Delta^2 p_n}\\]\nsehingga teknik ini biasa disebut Aitken’s delta-squared (\\(\\Delta^2\\)) method.\nCatatan: dalam pembahasan metode Aitken/Steffensen, penulisan \\(\\Delta^2\\) BUKAN berarti \\((\\Delta)^2\\). Itu hanya penulisan saja.\nSecara umum, apabila kita punya suku-suku suatu barisan yang berturut-turut yaitu \\(p_1, p_2, p_3, \\dots, p_{k-3}, p_{k-2}, p_{k-1}, p_{k}\\), maka rumus Aitken bisa digunakan untuk menentukan \\(\\hat{p}_1, \\hat{p}_2, \\hat{p}_3, \\dots, \\hat{p}_{k-3}, \\hat{p}_{k-2}\\), yang semuanya merupakan aproksimasi nilai yang lebih akurat untuk hasil konvergen dari barisan tersebut (dengan asumsi kekonvergenan linier).\nPerhatikan: - Kita hanya bisa berhenti sampai \\(\\hat{p}_{k-2}\\), karena perhitungannya membutuhkan \\(p_{k-2}\\), \\(p_{k-1}\\) dan \\(p_k\\). - Harus ada minimal 3 suku yang diketahui, artinya \\(k \\ge 3\\).\n\ndef Aitken(p):\n    k = len(p)\n    if k &lt; 3:\n        return \"Maaf, dibutuhkan minimal 3 suku yang diketahui.\"\n    \n    # kalau lanjut ke sini, artinya k &gt;= 3\n    list_phat = []\n    for i in range(k-2):\n        Delta = p[i+1] - p[i]\n        DeltaSquared = p[i+2] - 2 * p[i+1] + p[i]\n        phat = p[i] - (Delta)**2 / DeltaSquared\n        list_phat.append(phat)\n    return list_phat\n\n\ntry:\n    # input suatu list\n    p = eval(input(\"Masukkan list suku-suku yang diketahui: \"))\nexcept:\n    print(\"Maaf, terjadi error. Harap masukkan list dengan benar.\")\nelse: # kalau tidak terjadi error \n    print(\"Berikut hasil metode Aitken:\") \n    print(Aitken(p))\n\nMasukkan list suku-suku yang diketahui: [2, 1.5, 1.6666666666666665, 1.6, 1.625]\nBerikut hasil metode Aitken:\n[1.625, 1.619047619047619, 1.6181818181818182]\n\n\n\n\n\nAitken hanya menemukan rumus. Johan Frederik Steffensen menemukan bahwa, karena Metode Fixed-Point memiliki kekonvergen linier, metode Aitken bisa digunakan untuk mempercepat Metode Fixed-Point.\nSecara umum, apabila kita berselang-seling antara menggunakan suatu metode dan rumus Aitken (misalnya setelah memperoleh tiga hasil aproksimasi), kita dapat mempercepat kekonvergenan (accelerating convergence), seolah-olah order of convergence menjadi lebih besar dari 1. Namun, bagaimana cara selang-selingnya?\nMenurut Steffensen, rumus Aitken bisa digunakan tiap tiga iterasi fixed-point, yaitu untuk \\(p_3\\), \\(p_6\\), \\(p_9\\), dan seterusnya.\nKita bisa memodifikasi rumus Aitken dengan menggeser indeks \\(n\\), yaitu menukar \\(n\\) dengan \\(n-3\\), untuk mendapatkan rumus iterasi:\n\\[\\hat{p} = p_{n-3} - \\frac{\\left(p_{n-2} - p_{n-3}\\right)^2}{p_{n-1} - 2p_{n-2} + p_{n-3}}\\]\ndan dalam hal ini, kita juga bisa mendefinisikan \\(\\Delta_1 = p_{n-2} - p_{n-3}\\) dan \\(\\Delta_2 = p_{n-1} - 2p_{n-2} + p_{n-3}\\) untuk mendapatkan bentuk:\n\\[\\hat{p} = p_{n-3} - \\frac{(\\Delta_1)^2}{(\\Delta_2)}\\]\n\ndef Steffensen(g, p0, tolerance):\n    # list semua nilai p agar mudah diakses\n    list_p = [p0]\n\n    # nilai sementara\n    abs_error = tolerance + 1 \n\n    iterasi = 1 # penghitung banyaknya iterasi\n    while abs_error &gt;= tolerance:\n        if iterasi % 3 == 0: # untuk kelipatan tiga, gunakan rumus Aitken\n            pn_3 = list_p[iterasi - 3] # p_(n-3)\n            pn_2 = list_p[iterasi - 2] # p_(n-2)\n            pn_1 = list_p[iterasi - 1] # p_(n-1)\n            Delta1 = pn_2 - pn_3\n            Delta2 = pn_1 - 2 * pn_2 + pn_3\n            pn = pn_3 - (Delta1)**2 / Delta2\n        else: # selain kelipatan 3, gunakan fixed point\n            pn_1 = list_p[iterasi - 1]\n            pn = g(pn_1)\n        \n        list_p.append(pn)\n        abs_error = abs( pn - pn_1 )\n        iterasi += 1\n    \n    # return bukan hanya p, tetapi juga banyaknya iterasi\n    return pn, iterasi\n\n\nfrom numpy import sin, cos, tan, log, exp, sqrt\n\nformula = input(\"Masukkan formula g(x): \")\n\ndef g(x):\n    return eval(formula)\n\nstarting_point = eval(input(\"Masukkan titik awal iterasi: \"))\ntolerance = eval(input(\"Masukkan batas toleransi: \"))\n\np_steffensen, i_steffensen = Steffensen(g, starting_point, tolerance)\n\nprint(\"Metode Steffensen\")\nprint(\"Hasil: \" + str(p_steffensen))\nprint(\"setelah banyaknya iterasi: \" + str(i_steffensen))\n\nprint(\"Bandingkan banyaknya iterasi dengan Metode Fixed-Point biasa:\")\n\nfixpoint_hasil, fixpoint_tabel = FixedPoint(g, starting_point, tolerance)\nprint(fixpoint_tabel)\n\nMasukkan formula g(x): 1 + 1/x\nMasukkan titik awal iterasi: 2\nMasukkan batas toleransi: 10**(-7)\nMetode Steffensen\nHasil: 1.618033988749648\nsetelah banyaknya iterasi: 11\nBandingkan banyaknya iterasi dengan Metode Fixed-Point biasa:\n+---------+--------------------+\n| iterasi |    Aproksimasi     |\n+---------+--------------------+\n|    1    |        1.5         |\n|    2    | 1.6666666666666665 |\n|    3    |        1.6         |\n|    4    |       1.625        |\n|    5    | 1.6153846153846154 |\n|    6    | 1.619047619047619  |\n|    7    | 1.6176470588235294 |\n|    8    | 1.6181818181818182 |\n|    9    | 1.6179775280898876 |\n|   10    | 1.6180555555555556 |\n|   11    | 1.6180257510729614 |\n|   12    | 1.6180371352785146 |\n|   13    | 1.6180327868852458 |\n|   14    | 1.618034447821682  |\n|   15    | 1.618033813400125  |\n|   16    | 1.6180340557275543 |\n|   17    | 1.6180339631667064 |\n+---------+--------------------+"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#tabulate",
    "href": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#tabulate",
    "title": "Modul 1 Metode Numerik: Tabulate, SymPy, Root-finding",
    "section": "",
    "text": "Untuk menyajikan hasil iterasi, tabel sering digunakan karena akan mudah membacanya. Di Python, terdapat package untuk membuat tabel dengan cara sederhana. Package tersebut bernama tabulate.\nSeperti package umumnya, pertama kita import terlebih dahulu.\n\nfrom tabulate import tabulate\n\nApabila terjadi error (karena tabulate belum terinstall), kalian bisa mengetik pip install tabulate (atau !pip install tabulate dengan tanda seru)\n\npip install tabulate\n\nRequirement already satisfied: tabulate in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (0.9.0)\nNote: you may need to restart the kernel to use updated packages.\n\n\n\n!pip install tabulate\n\ndan seperti biasa, setelah instalasi selesai, mungkin kalian perlu menutup kemudian membuka kembali Jupyter Notebook sebelum bisa menggunakan tabulate.\nSekarang, buat konten tabel. Konten tabel disimpan dalam list/array 2-D dimana setiap array di dalamnya adalah baris.\nHeaders dari tabel dapat kita buat sendiri. Jumlah dari headers harus sama dengan jumlah elemen pada setiap array.\n‘tablefmt’ adalah format bentuk tabel. Format yang biasa digunakan adalah “orgtbl”, dan ada macam-macam format tabel yang bisa dicari di https://pypi.org/project/tabulate/\n\ntable = [[\"Jeruk\", 1], [\"Nanas\", 2]]\nprint(tabulate(table, headers = [\"Buah\", \"Kuantitas\"], tablefmt = \"orgtbl\"))\n\n| Buah   |   Kuantitas |\n|--------+-------------|\n| Jeruk  |           1 |\n| Nanas  |           2 |\n\n\nDalam membuat konten tabel, panjang dari setiap list harus sama dengan banyak headers. Apabila ada baris yang banyak elemennya melebihi banyak headers, maka elemen yang diambil adalah elemen sebanyak headers yang pertama. Kolom paling kiri diisi terlebih dahulu.\nPerhatikan contoh berikut.\n\ntable = [[\"Jeruk\", 1, 4], [\"Nanas\", 2, 3, 5], [\"Mangga\", 3]]\nprint(tabulate(table, headers = [\"Buah\", \"Kuantitas\", \"Harga\"], tablefmt = \"orgtbl\"))\n\n| Buah   |   Kuantitas |   Harga |\n|--------+-------------+---------|\n| Jeruk  |           1 |       4 |\n| Nanas  |           2 |       3 |\n| Mangga |           3 |         |\n\n\nApabila baris pertama digunakan sebagai header, banyak kolom akan sama dengan banyak elemen yang paling banyak di antara semua baris tabel. Penamaan kolom dimulai dari kanan.\nPerhatikan contoh berikut.\n\ntable = [[\"Saya\", 1, 4], [\"Tampan\", 2, 3, 5], [\"Banget\", 3, 5]]\nprint(tabulate(table, headers = \"firstrow\", tablefmt = \"orgtbl\"))\n\n|        |   Saya |   1 |   4 |\n|--------+--------+-----+-----|\n| Tampan |      2 |   3 |   5 |\n| Banget |      3 |   5 |     |\n\n\nTabulate sangat berguna untuk membentuk tabel secara “otomatis” atau secara pemrograman. Misalnya, kita bisa memanfaatkan looping dan pernyataan kondisional untuk membuat beberapa baris yang mengikuti pola dan syarat tertentu.\nSebagai contoh, misalnya kita punya function yang menghitung bilangan kuadrat ke-i\n\ndef kuadrat(i):\n    return i**2\n\n\nprint(kuadrat(5))\n\n25\n\n\nKita bisa membuat tabel, misalnya, yang menjabarkan bilangan kuadrat ke-1 sampai ke-5. Perhatikan struktur tabel apabila dibuat secara manual:\n\ntabel_kuadrat = [\n    [1, 1],\n    [2, 4],\n    [3, 9],\n    [4, 16],\n    [5, 15]\n]\nprint(tabulate(tabel_kuadrat, headers=[\"i\", \"kuadrat\"]))\n\n  i    kuadrat\n---  ---------\n  1          1\n  2          4\n  3          9\n  4         16\n  5         15\n\n\nTerlihat bahwa tabel tersebut memiliki lima baris, dan tiap baris berupa list yang merupakan elemen dari list besar tabel_kuadrat. Kita bisa membuatnya secara “otomatis” atau secara pemrograman:\n\ntabel_mentah = []\nfor i in range(1, 6): # mulai dari 1, lanjut selama kurang dari 6\n    calon_baris = [i, kuadrat(i)] # baris baru\n    tabel_mentah.append(calon_baris) # menambahkan baris baru ke list besar\n\nprint(tabulate(tabel_mentah, headers=[\"i\", \"kuadrat\"]))\n\n  i    kuadrat\n---  ---------\n  1          1\n  2          4\n  3          9\n  4         16\n  5         25\n\n\nTentu saja, calon_baris tidak harus langsung jadi ketika baru didefinisikan. Tiap bagian dari suatu baris bisa saja ditambahkan secara berangsur-angsur:\n\ntabel_mentah = []\nfor i in range(1, 6): # mulai dari 1, lanjut selama kurang dari 6\n    calon_baris = [] # baris baru\n    calon_baris.append(i) # bagian pertama pada baris\n\n    # bagian kedua pada baris\n    nilai_kedua = kuadrat(i)\n    calon_baris.append(nilai_kedua)\n\n    tabel_mentah.append(calon_baris) # menambahkan baris baru ke list besar\n\nprint(tabulate(tabel_mentah, headers=[\"i\", \"kuadrat\"]))\n\n  i    kuadrat\n---  ---------\n  1          1\n  2          4\n  3          9\n  4         16\n  5         25\n\n\nAdanya lebih dari dua kolom juga sangat memungkinkan, tinggal ditambahkan ke calon_baris:\n\ntabel_mentah = []\nfor i in range(1, 6): # mulai dari 1, lanjut selama kurang dari 6\n    calon_baris = [] # baris baru\n\n    # bagian pertama pada baris\n    calon_baris.append(i)\n\n    # bagian kedua pada baris\n    nilai_kedua = kuadrat(i)\n    calon_baris.append(nilai_kedua)\n\n    # bagian ketiga\n    calon_baris.append(i**3)\n\n    # bagian keempat\n    calon_baris.append(i**4)\n\n    tabel_mentah.append(calon_baris) # menambahkan baris baru ke list besar\n\nprint(tabulate(tabel_mentah, headers=[\"i\", \"kuadrat\", \"pangkat tiga\",\"pangkat empat\"]))\n\n  i    kuadrat    pangkat tiga    pangkat empat\n---  ---------  --------------  ---------------\n  1          1               1                1\n  2          4               8               16\n  3          9              27               81\n  4         16              64              256\n  5         25             125              625\n\n\nApabila kita sudah memiliki data tiap kolom dalam bentuk list, kita bisa membentuk calon_baris pada tiap iterasi for loop dengan mengakses elemen ke-i dari tiap list.\n\n# misalnya data ini sudah ada, atau sudah diolah sebelumnya\nkolom_awal = [1, 2, 3, 4, 5]\nkolom_kuadrat = [1, 4, 9, 16, 25]\nkolom_tiga = [1, 8, 27, 64, 125]\nkolom_empat = [1, 16, 81, 256, 625]\n\n# mari kita buat tabel\ntabel_mentah = []\nfor i in range(0, 5): # indeks list dimulai dari nol, lanjut selama i &lt; 5\n    calon_baris = []\n\n    # elemen ke-i dari tiap list kolom\n    calon_baris.append(kolom_awal[i])\n    calon_baris.append(kolom_kuadrat[i])\n    calon_baris.append(kolom_tiga[i])\n    calon_baris.append(kolom_empat[i])\n\n    tabel_mentah.append(calon_baris)\n\nprint(tabulate(tabel_mentah, headers=[\"i\", \"kuadrat\", \"pangkat tiga\",\"pangkat empat\"]))\n\n  i    kuadrat    pangkat tiga    pangkat empat\n---  ---------  --------------  ---------------\n  1          1               1                1\n  2          4               8               16\n  3          9              27               81\n  4         16              64              256\n  5         25             125              625\n\n\nBagaimana kalau misalnya ada data yang tidak lengkap? Kita bisa saja menggunakan try-except, untuk memasukkan “X” ketika ada data yang tidak lengkap, sekaligus menghindari error:\n\n# contoh data\nkolom_awal = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nkolom_kuadrat = [1, 4, 9, 16, 25]\n\ntabel_mentah = []\nfor i in range(0, 10): # indeks list dimulai dari nol, lanjut selama i &lt; 10\n    calon_baris = []\n\n    # elemen ke-i dari tiap list kolom\n    calon_baris.append(kolom_awal[i])\n    \n    try:\n        calon_baris.append(kolom_kuadrat[i])\n    except IndexError:\n        calon_baris.append(\"X\")\n\n    tabel_mentah.append(calon_baris)\n\nprint(tabulate(tabel_mentah, headers=[\"i\", \"kuadrat\"]))\n\n  i  kuadrat\n---  ---------\n  1  1\n  2  4\n  3  9\n  4  16\n  5  25\n  6  X\n  7  X\n  8  X\n  9  X\n 10  X\n\n\nNumPy juga memiliki semacam tipe data atau nilai yang standar untuk menandakan data yang hilang atau tidak tersedia, yaitu NaN (Not a Number), melalui numpy.nan. Sehingga, \"X\" pada kode di atas bisa diganti dengan numpy.nan:\n\n# contoh data\nkolom_awal = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nkolom_kuadrat = [1, 4, 9, 16, 25]\n\ntabel_mentah = []\nfor i in range(0, 10): # indeks list dimulai dari nol, lanjut selama i &lt; 10\n    calon_baris = []\n\n    # elemen ke-i dari tiap list kolom\n    calon_baris.append(kolom_awal[i])\n    \n    try:\n        calon_baris.append(kolom_kuadrat[i])\n    except IndexError:\n        calon_baris.append(np.nan)\n\n    tabel_mentah.append(calon_baris)\n\nprint(tabulate(tabel_mentah, headers=[\"i\", \"kuadrat\"]))\n\n  i    kuadrat\n---  ---------\n  1          1\n  2          4\n  3          9\n  4         16\n  5         25\n  6        nan\n  7        nan\n  8        nan\n  9        nan\n 10        nan"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#sympy",
    "href": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#sympy",
    "title": "Modul 1 Metode Numerik: Tabulate, SymPy, Root-finding",
    "section": "",
    "text": "Dalam pembelajaran metode numerik, seringkali kita perlu membandingkan hasil aproksimasi kita dengan nilai yang sesungguhnya. Seringkali pula, sebenarnya nilai yang sesungguhnya itu dapat kita peroleh (karena kita masih dalam tahap belajar; penerapan metode numerik di dunia nyata adalah pada kasus di mana nilai eksak tidak dapat diperoleh).\nHasil perhitungan eksak (seperti perhitungan menggunakan aljabar biasa atau ilmu kalkulus) juga disebut hasil perhitungan analitik atau simbolik. Istilah “analitik” bisa dianggap antonim dari istilah “numerik”.\nDi Python, ada module/package bernama SymPy (symbolic Python) yang dapat melakukan perhitungan simbolik, seperti menghitung turunan, yang misalnya digunakan di metode Newton.\n(Fun fact: aplikasi/package di komputer yang dapat melakukan perhitungan simbolik disebut Computer Algebra System (CAS). Beberapa contoh CAS adalah SymPy, Wolfram Mathematica, dan Maple.)\nMari kita import sympy:\n\nimport sympy\n\nSeperti untuk NumPy dan tabulate, apabila terjadi error karena sympy tidak ditemukan, artinya package sympy belum terinstall, dan bisa di-install menggunakan pip install sympy (atau dengan tanda seru: !pip install sympy)\n\npip install sympy\n\nRequirement already satisfied: sympy in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (1.11.1)\nRequirement already satisfied: mpmath&gt;=0.19 in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from sympy) (1.2.1)\nNote: you may need to restart the kernel to use updated packages.\n\n\nTentunya, penggunaan SymPy melibatkan variabel. Misalnya, kita ingin melakukan perhitungan simbolik dengan variabel \\(x\\). Kita perlu memberitahu SymPy, dengan syntax seperti berikut:\n\nx = sympy.symbols(\"x\")\n\nArtinya, kita baru saja memberitahu SymPy bahwa, pada string apapun yang dijumpai oleh SymPy, huruf “x” perlu dianggap sebagai simbol, atau lebih tepatnya sebagai variabel.\nPerhatikan pula bahwa kode di atas adalah assignment ke variabel pemrograman yang juga bernama x. Dengan demikian, untuk ke depannya, variabel x yang kita ketik di mana saja pada program kita akan dianggap sebagai variabel “x” oleh SymPy.\nDengan variabel x tersebut, kita dapat mendefinisikan suatu expression (ekspresi atau kalimat matematika), misal \\(5x^4\\), seperti berikut:\n\npolinom = 5 * (x ** 4) / 2\nprint(polinom)\n\n5*x**4/2\n\n\nSymPy memiliki fitur pprint (pretty print), yaitu menampilkan suatu ekspresi secara cantik atau indah, layaknya seperti kita tulis di kertas:\n\nsympy.pprint(polinom)\n\n   4\n5⋅x \n────\n 2  \n\n\nUntuk melakukan diferensiasi atau menghitung turunan (dalam hal ini secara simbolik/analitik), gunakan sympy.diff:\n\nturunan = sympy.diff(polinom, x)\nsympy.pprint(turunan)\n\n    3\n10⋅x \n\n\ndengan begitu, SymPy menghitung turunan dari ekspresi polinom yang kita berikan itu, terhadap variabel x. Sebenarnya, mengetik sympy.diff(polinom) saja sudah cukup, tapi lebih lengkap lebih baik.\nSejauh ini, semua ekspresi yang kita jumpai masih berbentuk simbol/tulisan, sehingga kita belum bisa men-substitusi variabel x dengan sembarang nilai. Misalnya kita ingin menjadikan ekspresi di atas sebagai suatu fungsi func(x), di mana kita bisa memasukkan nilai x apapun dan mendapatkan hasil. Caranya adalah menggunakan sympy.lambdify:\n\nfunc = sympy.lambdify(x, turunan)\nprint(func(5))\n\n1250\n\n\nPada syntax lambdify di atas, kita perlu memberitahu SymPy terlebih dahulu, variabel apa yang digunakan pada ekspresi tersebut; barulah kita tuliskan ekspresinya. Dalam hal ini, kita mengetik sympy.lambdify(x, turunan) karena sedang menggunakan variabel x untuk ekspresi turunan yang ingin kita ubah menjadi fungsi yang bisa di-substitusi nilai x nya.\nFungsi hasil lambdify sudah bisa digunakan seperti fungsi lainnya pada Python. Bahkan, kita bisa mencampur penggunaan SymPy dengan NumPy (maupun package lainnya). Contohnya, setelah tadi memperoleh func(x) dari SymPy:\n\nimport numpy as np\n\n\narr = np.array([2, 3, 5, 10])\nprint(func(arr))\n\n[   80   270  1250 10000]\n\n\nSeperti NumPy, SymPy juga memiliki fungsi sin, cos, log, exp dll, sehingga kita bisa melakukan perhitungan analitik yang melibatkan fungsi-fungsi tersebut.\n\ng = x**2 * sympy.cos(x) + sympy.exp(-5*x)\nprint(\"Fungsinya:\")\nsympy.pprint(g)\n\ngp = sympy.diff(g, x)\nprint(\"Turunannya:\")\nsympy.pprint(gp)\n\nFungsinya:\n 2           -5⋅x\nx ⋅cos(x) + ℯ    \nTurunannya:\n   2                          -5⋅x\n- x ⋅sin(x) + 2⋅x⋅cos(x) - 5⋅ℯ    \n\n\nMeskipun kita bisa saja melakukan, misalnya, from sympy import cos, hal tersebut tidak disarankan, apalagi ketika program kita juga menggunkaan NumPy dengan from numpy import cos atau bahkan from numpy import *. Alasannya, dengan begitu, program bisa menjadi membingungkan, karena tidak ada pembeda antara cos dari NumPy (numerik) dengan cos dari SymPy (analitik/simbolik).\nNamun, kalau Anda berhati-hati dan hanya melakukan hal tersebut untuk salah satu package saja, silakan.\nMenariknya, SymPy bisa jadi lebih unggul daripada NumPy untuk beberapa perhitungan yang melibatkan akurasi tinggi, terutama untuk perhitungan yang sebenarnya bersifat analitik. Misalnya, kita tahu bahwa \\(\\sin(\\pi) = 0\\). Menurut SymPy,\n\nprint(\"Menurut SymPy, sin(pi) = \" + str(sympy.sin(sympy.pi)))\n\nMenurut SymPy, sin(pi) = 0\n\n\nkarena SumPy menghitung nilai sin dari \\(\\pi\\) secara analitik, yaitu tanpa perlu menghitung nilai \\(\\pi\\) (karena nilainya sudah jelas nol berdasarkan sifat fungsi sin). Sedangkan, NumPy mengaproksimasi nilai \\(\\pi\\) terlebih dahulu, barulah hasil aproksimasi tersebut yang masuk ke fungsi sin. Hasil perhitungan fungsi sin tersebut pun juga aproksimasi, sehingga didapatkan hasil seperti berikut, yaitu sangat kecil tetapi bukan nol:\n\nprint(\"Menurut NumPy, sin(pi) = \" + str(np.sin(np.pi)))\n\nMenurut NumPy, sin(pi) = 1.2246467991473532e-16\n\n\ndi mana “e-16” artinya “dikali 10 pangkat -16”."
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#metode-bisection",
    "href": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#metode-bisection",
    "title": "Modul 1 Metode Numerik: Tabulate, SymPy, Root-finding",
    "section": "",
    "text": "Metode Bisection adalah salah satu metode yang dapat kita gunakan dalam masalah pencarian akar (root finding). Akar dari suatu persamaan didefinisikan sebagai nilai \\(x\\) yang memenuhi \\(f(x) = 0\\). Misalkan \\(f\\) adalah suatu fungsi kontinu terdefinisi di \\([a,b]\\), di mana \\(f(a)\\) dan \\(f(b)\\) berlawanan tanda (sehingga pasti ada akar pada interval tersebut, menurut Teorema Nilai Antara / Intermediate Value Theorem).\nInti sari dari metode Bisection adalah\n\nmenebak bahwa akar suatu persamaan ada di dalam interval tertentu \\([a, b]\\);\nmenelusuri nilai fungsi pada nilai tengah atau rata-rata dari interval tersebut;\nmempersempit interval dengan memanfaatkan hasil rata-rata tersebut; dan\nterus mencari nilai tengah dari interval yang baru, yang kemudian dipersempit lalu dicari nilai tengahnya, dan seterusnya hingga akar ditemukan, atau hingga ukuran interval sudah cukup kecil sehingga memuaskan (yaitu sudah lebih kecil dari toleransi).\n\nDidefinisikan nilai tengah dari interval:\n\\[p=\\frac{(a+b)}{2}\\]\nAkan dicari \\(f(p)\\) dengan syarat sebagai berikut:\n\njika \\(f(p) = 0\\), maka \\(p\\) adalah akar dari \\(f\\)\njika \\(f(p)f(a) &gt; 0\\), maka \\(\\text{sign}(f(p)) = \\text{sign}(f(a))\\). Sehingga, kita dapat mempersempit interval dengan memilih batasan baru yaitu a = p dan b tidak berubah.\njika \\(f(p)f(a) &lt; 0\\), maka \\(\\text{sign}(f(p)) \\neq \\text{sign} (f(a))\\), atau \\(\\text{sign}(f(p)) = \\text{sign}(f(b))\\). Sehingga, kita dapat mempersempit interval dengan memilih batasan baru yaitu a tidak berubah dan b = p.\n\nMetode Bisection memiliki order of convergence = 1, atau disebut memiliki kekonvergenan linier (linear convergence). Artinya, dalam proses menemukan akar persamaan (konvergen menuju jawabannya), metode Bisection tidak secepat beberapa metode lainnya yang memiliki order of convergence yang lebih tinggi.\n\ndef Bisection(f, lower, upper, tol):\n    if f(lower)*f(upper)&lt;0:\n        p0=lower\n        p=(lower+upper)/2\n\n        if f(p)==0:\n            return p\n        elif f(p)*f(lower)&gt;0:\n            lower=p\n        elif f(p)*f(lower)&lt;0:\n            upper=p\n \n        abs_error=abs(p0-p)\n        p0=p\n \n        while abs_error &gt; tol:\n            p=(lower+upper)/2\n            \n            if f(p)==0:\n                break\n            elif f(p)*f(lower)&gt;0:\n                lower=p\n            elif f(p)*f(lower)&lt;0:\n                upper=p\n        \n            abs_error=abs(p0-p)\n            p0=p\n \n        return p\n \n    elif f(lower)*f(upper)&gt;0:\n        return \"Metode gagal mengaproksimasi akar. Silakan ubah batas atas atau batas bawah\"\n    elif f(lower)==0:\n        return lower\n    else: #f(upper)==0\n        return upper\n\n\nfrom numpy import sin, cos, tan, log, exp, sqrt, pi\n\nformula = input('Masukkan formula fungsi: ')\n\ndef f(x):\n    return eval(formula)\n\nlow_bound = eval(input(\"Masukkan batas bawah interval: \"))\nup_bound = eval(input(\"Masukkan batas atas interval: \"))\ntoleransi = eval(input(\"Masukkan toleransi aproksimasi: \"))\n\nakar_bisection=Bisection(f, low_bound, up_bound, toleransi)\n\ntry:\n    print(f\"Akar persamaan {formula} = 0 adalah x = {akar_bisection}\")\nexcept ValueError:\n    print(akar_bisection)\n\nMasukkan formula fungsi: 2*x - 3*cos(x) + exp(-5*x) - 9\nMasukkan batas bawah interval: -3\nMasukkan batas atas interval: 2\nMasukkan toleransi aproksimasi: 10**(-7)\nAkar persamaan 2*x - 3*cos(x) + exp(-5*x) - 9 = 0 adalah x = -0.5073225051164627"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#metode-fixed-point",
    "href": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#metode-fixed-point",
    "title": "Modul 1 Metode Numerik: Tabulate, SymPy, Root-finding",
    "section": "",
    "text": "Inti sari dari Metode Fixed-Point adalah mencari fixed-point (titik tetap) dari suatu fungsi (misal fungsi \\(g(x)\\)), yaitu suatu nilai \\(p\\) sehingga \\(p = g(p)\\), atau \\(p - g(p) = 0\\). Titik \\(p\\) disebut titik tetap, karena ketika nilai \\(p\\) dimasukkan ke fungsi \\(g(x)\\), hasilnya tetaplah \\(p\\). Untuk nilai \\(x\\) yang dekat dengan \\(p\\), biasanya ada kecenderungan nilai \\(g(x)\\) menjadi semakin mendekati \\(p\\).\nPerhatikan bahwa, sembarang persamaan \\(f(x) = 0\\) bisa diubah bentuknya dengan mendefinisikan fungsi \\(g(x) = x - f(x)\\) (sehingga \\(f(x) = x - g(x)\\)). Dengan demikian, permasalahan mencari akar berubah menjadi permasalahan mencari fixed-point, yaitu mencari nilai \\(p\\) sehingga \\(p = g(p)\\) atau \\(p - g(p) = 0\\) (sehingga nilai \\(p\\) tersebut juga menyebabkan \\(f(p) = 0\\)).\n(Tentu saja, itu bukanlah satu-satunya cara untuk mengubah permasalahan mencari akar menjadi permasalahan mencari fixed-point. Bahkan, tidak semua pilihan \\(g(x)\\) yang memungkinkan itu dijamin memiliki fixed-point.)\nMisalkan \\(g\\) adalah fungsi kontinu dan memiliki fixed-point \\(p\\) pada interval \\([a,b]\\) (dan diasumsikan bahwa \\(g\\) memenuhi persyaratan untuk kekonvergenan metode fixed-point). Artinya, ada \\(p \\in [a,b]\\) sehingga \\(g(x) = x\\). Untuk mengaproksimasi penyelesaian dari persamaan \\(g(x) = x\\), diperlukan suatu tebakan awal \\(p_0\\), kemudian iterasinya adalah:\n\\[p_n = g(p_{n-1})\\]\nNilai tersebut terus dimasukkan ke dalam \\(g\\) sehingga, diharapkan, nilai \\(p_n\\) menjadi semakin mendekati suatu nilai \\(p\\) yang membuat \\(g(p) = p\\).\nPada umumnya, metode fixed-point memiliki kekonvergenan linier. Ketika \\(g(x)\\) dijamin memliki tepat satu fixed-point (atau fixed-point yang unik) pada suatu interval \\([a,b]\\), maka Metode Fixed-Point dengan \\(p_0\\) pada interval tersebut pasti memiliki kekonvergenan linier. Terkadang Metode Fixed-Point lebih cepat daripada Metode Bisection, dan terkadang Metode Bisection lebih cepat daripada Metode Fixed-Point.\nHati-hati, ada kemungkinan bahwa \\(g(p_n)\\) malah menjauhi \\(p\\), contohnya untuk \\(g(x) = x^2\\) dan \\(p_0 &gt; 1\\) (padahal \\(g(1) = 1\\)). Pada kasus seperti itu, metode fixed-point tidak dijamin konvergen (artinya tidak dijamin bisa menemukan fixed-point).\nSebagai contoh penggunaan metode fixed-point, kalian bisa mencoba untuk menyelesaikan persamaan (masalah mencari akar) berikut ini,\n\\[f(x) = x^2 - x - 1 = 0\\]\ndengan sedikit manipulasi aljabar (dibagi \\(x\\), pindah ruas) agar mendapatkan bentuk \\(x = g(x)\\),\n\\[x = 1 + \\frac{1}{x}\\]\nsehingga, dengan \\(g(x) = 1 + \\frac{1}{x}\\) bisa digunakan metode fixed-point, misal dengan tebakan awal \\(x = 2\\) atau \\(x = -3\\).\n(Jelas metode ini akan gagal untuk \\(g(x)\\) tersebut apabila dipilih tebakan awal seperti \\(x=0\\), \\(x=-1\\), atau bahkan \\(x=-\\frac{1}{2}\\) karena akan terjadi pembagian nol. Kemungkinan terjadinya pembagian nol itu bukan hanya dari metodenya seperti metode Newton, tetapi juga dari fungsi \\(f(x)\\) atau \\(g(x)\\) yang digunakan.)\nSilakan coba dengan kode di bawah ini!\nSebagai pembanding, kalian bisa menyelesaikan persamaan kuadrat \\(f(x) = x^2 - x - 1 = 0\\) di atas, dan mendapatkan solusi\n\\[x_1 = \\frac{1+\\sqrt{5}}{2} \\approx 1.618\\]\n\\[x_2 = \\frac{1-\\sqrt{5}}{2} \\approx -0.618\\]\nKebetulan, konstanta berikut ini yang berlambang phi kecil (\\(\\phi\\)),\n\\[\\phi = \\frac{1+\\sqrt{5}}{2}\\]\nadalah konstanta istimewa yang bernama golden ratio.\n\nfrom tabulate import tabulate\n\ndef FixedPoint(g, p0, tol):\n    table = [[\"iterasi\",\"Aproksimasi\"]]\n    iterasi = []\n    \n    i = 1\n    p = g(p0)\n    abs_error = abs(p-p0)\n    p0 = p\n    iterasi.append(i)\n    iterasi.append(p)\n    table.append(iterasi)\n\n    while abs_error &gt; tol:\n        iterasi = []\n        i += 1\n        p = g(p0)\n        abs_error = abs(p-p0)\n        p0 = p\n        iterasi.append(i)\n        iterasi.append(p)\n        table.append(iterasi)\n    \n    tabel_siap_print = tabulate(table,headers = 'firstrow',tablefmt=\"pretty\")\n    return p0, tabel_siap_print\n\n\nfrom numpy import cos, sin, tan, log, exp, sqrt\n\nformula = input(\"Masukkan formula g(x): \")\n\ndef g(x):\n    return eval(formula)\n\ntebakan_awal = eval(input(\"Masukkan titik awal iterasi: \"))\ntoleransi = eval(input(\"Masukkan batas toleransi: \"))\n\nfixed_point, tabel = FixedPoint(g, tebakan_awal, toleransi)\n\nprint(tabel)\nprint(f\"Ditemukan fixed point dari g(x) = {formula} yaitu x = {fixed_point}\")\n\nMasukkan formula g(x): 1 + 1/x\nMasukkan titik awal iterasi: 2\nMasukkan batas toleransi: 10**(-7)\n+---------+--------------------+\n| iterasi |    Aproksimasi     |\n+---------+--------------------+\n|    1    |        1.5         |\n|    2    | 1.6666666666666665 |\n|    3    |        1.6         |\n|    4    |       1.625        |\n|    5    | 1.6153846153846154 |\n|    6    | 1.619047619047619  |\n|    7    | 1.6176470588235294 |\n|    8    | 1.6181818181818182 |\n|    9    | 1.6179775280898876 |\n|   10    | 1.6180555555555556 |\n|   11    | 1.6180257510729614 |\n|   12    | 1.6180371352785146 |\n|   13    | 1.6180327868852458 |\n|   14    | 1.618034447821682  |\n|   15    | 1.618033813400125  |\n|   16    | 1.6180340557275543 |\n|   17    | 1.6180339631667064 |\n+---------+--------------------+\nDitemukan fixed point dari g(x) = 1 + 1/x yaitu x = 1.6180339631667064"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#metode-newton-biasa-dengan-turunan-analitik",
    "href": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#metode-newton-biasa-dengan-turunan-analitik",
    "title": "Modul 1 Metode Numerik: Tabulate, SymPy, Root-finding",
    "section": "",
    "text": "Misalkan \\(f\\) kontinu dan terturunkan (memiliki turunan) di \\([a,b]\\) dan ada tebakan awal \\(p_0 \\in\\) \\([a,b]\\) sedemikian sehingga \\(f'(p_0) \\neq 0\\). Iterasi pada metode Newton untuk menyelesaian \\(f(x) = 0\\) adalah sebagai berikut:\n\\[p_n = p_{n-1} - \\frac{f(p_{n-1})}{f'(p_{n-1})}\\]\nDiharapkan bahwa, setelah banyak iterasi, nilai \\(p_n\\) yang diperoleh akan membuat \\(f(p) = 0\\) atau setidaknya sangat dekat dengan nol (lebih kecil dari batas toleransi yang kita anggap sudah memuaskan).\nMetode Newton juga dapat dipandang sebagai metode fixed-point dengan \\(g(x) = x - \\frac{f(x)}{f'(x)}\\)\nMetode Newton gagal apabila, pada suatu iterasi, tiba-tiba \\(f'(p_n) = 0\\).\nPada umumnya, Metode Newton memiliki order of convergence = 2, atau juga disebut memiliki kekonvergenan kuadratik (quadratic convergence). Artinya, selama berhasil, Metode Newton lebih cepat daripada Metode Bisection maupun Metode Fixed-Point.\n\ndef NewtonAnalitik(f,fp,p0,tolerance):\n    p = p0 - f(p0)/fp(p0)\n    abs_error = abs(p-p0)\n    p0 = p\n\n    while abs_error &gt; tolerance:\n\n        try:\n            p = p0 - f(p0)/fp(p0)\n        except ZeroDivisionError:\n            return \"Metode gagal mengaproksimasi akar. Silakan pilih tebakan awal lain\"\n        \n        abs_error = abs(p-p0)\n        p0 = p\n    return p\n\n\nimport sympy\nfrom numpy import sin, cos, tan, log, exp, sqrt\n\nformula = input(\"Masukkan fungsi: \")\ndef f(x):\n    return eval(formula)\n\nx = sympy.symbols(\"x\")\n\ndf_string = str(sympy.diff(formula, x))\ndef fp(x): # turunan f\n    return eval(df_string)\n\ntebakan_awal = eval(input(\"Masukkan tebakan awal / titik awal iterasi: \"))\ntolerance = eval(input(\"Masukkan toleransi aproksimasi: \"))\n\nakar_newton = NewtonAnalitik(f, fp, tebakan_awal, tolerance)\n\nprint(f\"Akar dari persamaan f(x) = {formula} adalah x = {akar_newton}\")\n\nMasukkan fungsi: 2*x - 3*cos(x) + exp(-5*x) - 9\nMasukkan tebakan awal / titik awal iterasi: -1\nMasukkan toleransi aproksimasi: 10**(-7)\nAkar dari persamaan f(x) = 2*x - 3*cos(x) + exp(-5*x) - 9 adalah x = -0.5073224866379573"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#metode-newton-dengan-beda-hingga-finite-difference-newtons-method",
    "href": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#metode-newton-dengan-beda-hingga-finite-difference-newtons-method",
    "title": "Modul 1 Metode Numerik: Tabulate, SymPy, Root-finding",
    "section": "",
    "text": "Salah satu kekurangan Metode Newton yang biasa adalah harus mengetahui rumus turunannya secara analitik. Sebelum adanya CAS seperti SymPy, turunan analitik harus dihitung secara manual dengan kalkulus. Kalau bentuk rumus untuk \\(f(x)\\) sangat rumit, perhitungan turunan menjadi jauh lebih rumit. Untuk menghindari menghitung turunan secara analitik, kita dapat menggunakan definisi turunan (yang menggunakan limit):\n\\[f'(x) = \\lim_{h \\rightarrow 0} \\frac{f(x+h) - f(x)}{h}\\]\ndengan memilih nilai \\(h\\) yang cukup kecil (sayangnya, kita tidak bisa membuat limit \\(h\\) menuju nol). Nilai \\(h\\) yang cukup kecil itu disebut suatu beda hingga (finite difference).\nSehingga, modifikasi metode Newton ini bisa disebut Metode Newton dengan Beda Hingga (Finite-Difference Newton’s Method). Untuk fungsi \\(f\\) yang kontinu, akar persamaan \\(f(x) = 0\\) bisa ditentukan dengan iterasi sebagai berikut:\n\\[\\begin{align*}\np_n &= p_{n-1} - \\frac{f(p_{n-1})}{\\left(\\frac{f\\left(p_{n-1}+h\\right)-f(p_{n-1})}{h}\\right)} \\\\\n&= p_{n-1} - \\frac{f(p_{n-1})h}{f(p_{n-1}+h)-f(p_{n-1})}\n\\end{align*}\\]\ndengan tebakan awal \\(p_0\\). Perhatikan bahwa \\(f'(p_{n-1})\\) pada metode Newton yang biasa itu telah digantikan dengan\n\\[f'(p_{n-1}) \\approx \\frac{f(p_{n-1}+h) - f(p_{n-1})}{h}\\]\nTujuan modifikasi tersebut adalah agar iterasi dapat dilakukan pada titik di mana turunannya tidak ada, atau ketika turunan analitik sulit diperoleh.\n\ndef FiniteDifferenceNewton(f,fp,p0,tolerance):\n    p = p0 - f(p0)/fp(p0)\n    abs_error = abs(p-p0)\n    p0 = p\n\n    while abs_error &gt; tolerance:\n        p = p0 - f(p0)/fp(p0)\n        abs_error = abs(p-p0)\n        p0 = p\n    return p\n\n\nfrom numpy import sin, cos, tan, log, exp, sqrt\n\nformula = input(\"Masukkan fungsi: \")\ndef f(x):\n    return eval(formula)\n\ndef fp(x, h=10**(-12)):\n    return (f(x+h)-f(x))/h\n\nstarting_point = eval(input(\"Masukkan titik awal iterasi: \"))\ntolerance = eval(input(\"Masukkan toleransi aproksimasi: \"))\n\nakar_fd = FiniteDifferenceNewton(f,fp,starting_point,tolerance)\n\nprint(f\"Akar dari persamaan f(x) = {formula} adalah x = {akar_fd}\")\n\nMasukkan fungsi: 2*x - 3*cos(x) + exp(-5*x) - 9\nMasukkan titik awal iterasi: -1\nMasukkan toleransi aproksimasi: 10**(-7)\nAkar dari persamaan f(x) = 2*x - 3*cos(x) + exp(-5*x) - 9 adalah x = -0.5073224866379543"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#tambahan",
    "href": "semuahalaman/modulprak/2024/genap/metnum/modul1.html#tambahan",
    "title": "Modul 1 Metode Numerik: Tabulate, SymPy, Root-finding",
    "section": "",
    "text": "Bagaimana kalau misalnya kita sudah punya suatu fungsi yang melakukan perhitungan secara iteratif dan hanya menampilkan hasil akhirnya, tetapi kita ingin memperoleh tiap hasil iterasi, bukan hasil akhirnya saja? Contohnya, fungsi menghitung faktorial \\(n! = n * (n-1) * \\dots * 3 * 2 * 1\\) berikut ini,\n\ndef faktorial(n):\n    \n    # nilai awal\n    hasil = 1\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n    \n    # mengembalikan hasil akhir setelah semua iterasi selesai\n    return hasil\n\n# peroleh hasil akhir dari fungsi faktorial, kemudian print\nprint(faktorial(5))\n\n120\n\n\nKita bisa saja melakukan print (di dalam fungsinya) tiap kali nilai hasil diperbarui.\n\ndef faktorial(n):\n    \n    # nilai awal\n    hasil = 1\n    print(hasil) # tampilkan hasil\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n        print(hasil) # tampilkan hasil yang baru\n    \n    # tidak perlu return karena sudah menggunakan print\n\n# fungsi cukup dipanggil saja,\n# karena print sudah ada di dalam fungsi\nfaktorial(5)\n\n1\n2\n6\n24\n120\n\n\nAlternatifnya, kita bisa memasukkan tiap hasil baru ke dalam suatu list, yang kemudian dikembalikan oleh fungsi, lalu kita bisa print list tersebut.\n\ndef ListFaktorial(n):\n    list_baru = []\n    \n    # nilai awal\n    hasil = 1\n    list_baru.append(hasil) # tambahkan ke list\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n        list_baru.append(hasil) # tambahkan tiap hasil baru ke list\n    \n    # kembalikan list semua hasil\n    return list_baru\n\n# peroleh list dari fungsi di atas, kemudian print\nprint(ListFaktorial(5))\n\n[1, 2, 6, 24, 120]\n\n\nBahkan, list ini bisa diubah menjadi tabel!\n\ndef ListFaktorial(n):\n    list_baru = []\n    \n    # nilai awal\n    hasil = 1\n    list_baru.append(hasil) # tambahkan ke list\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n        list_baru.append(hasil) # tambahkan tiap hasil baru ke list\n    \n    # kembalikan list semua hasil\n    return list_baru\n\n# kolom nilai i\nkolom_kiri = [1, 2, 3, 4, 5]\n# bisa juga dibuat dengan for loop dengan range(1,6) append i\n\n# peroleh list dari fungsi di atas\nkolom_kanan = ListFaktorial(5)\n\n# \"gabung\" kedua kolom menjadi satu tabel, seperti biasa\ntabel_mentah = []\nfor i in range(0,5):\n    calon_baris = []\n    calon_baris.append(kolom_kiri[i])\n    calon_baris.append(kolom_kanan[i])\n    tabel_mentah.append(calon_baris)\n\ntabel_olahan = tabulate(tabel_mentah, headers=[\"i\", \"faktorial\"])\nprint(tabel_olahan)\n\n  i    faktorial\n---  -----------\n  1            1\n  2            2\n  3            6\n  4           24\n  5          120\n\n\nPerhatikan bahwa kita memerlukan dua list untuk membentuk tabel di atas. Bisa saja, kita membentuk kedua list sepenuhnya di dalam fungsi. Dengan begitu, setelah menggunakan fungsi, kita tinggal membentuk tabel dari kedua list.\n\ndef DuaListFaktorial(n):\n    kolom_kiri = [] # berisi i\n    kolom_kanan = [] # berisi faktorial atau i!\n    \n    # nilai awal\n    hasil = 1\n\n    # tambahkan ke list\n    kolom_kiri.append(1)\n    kolom_kanan.append(hasil)\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n\n        # tambahkan tiap hasil baru ke list\n        kolom_kiri.append(i)\n        kolom_kanan.append(hasil)\n    \n    # kembalikan kedua list\n    return kolom_kiri, kolom_kanan\n\n# peroleh kedua list dari fungsi\nkolom_kiri, kolom_kanan = DuaListFaktorial(5)\n\n# \"gabung\" kedua kolom menjadi satu tabel, seperti biasa\ntabel_mentah = []\nfor i in range(0,5):\n    calon_baris = []\n    calon_baris.append(kolom_kiri[i])\n    calon_baris.append(kolom_kanan[i])\n    tabel_mentah.append(calon_baris)\n\ntabel_olahan = tabulate(tabel_mentah, headers=[\"i\", \"faktorial\"])\nprint(tabel_olahan)\n\n  i    faktorial\n---  -----------\n  1            1\n  2            2\n  3            6\n  4           24\n  5          120\n\n\nKalau mau, bahkan proses pembentukan tabel juga bisa dilakkukan di dalam fungsi, sehingga fungsi memberikan output berupa tabel yang siap diolah tabulate.\n\ndef TabelFaktorial(n):\n    kolom_kiri = [] # berisi i\n    kolom_kanan = [] # berisi faktorial atau i!\n    \n    # nilai awal\n    hasil = 1\n\n    # tambahkan ke list\n    kolom_kiri.append(1)\n    kolom_kanan.append(hasil)\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n\n        # tambahkan tiap hasil baru ke list\n        kolom_kiri.append(i)\n        kolom_kanan.append(hasil)\n    \n    tabel_mentah = []\n    for i in range(0,n):\n        # sampai indeks (n-1)\n        # nilai n tergantung banyaknya iterasi\n\n        calon_baris = []\n        calon_baris.append(kolom_kiri[i])\n        calon_baris.append(kolom_kanan[i])\n        tabel_mentah.append(calon_baris)\n    \n    return tabel_mentah\n\ntabel_mentah = TabelFaktorial(5)\n\ntabel_olahan = tabulate(tabel_mentah, headers=[\"i\", \"faktorial\"])\nprint(tabel_olahan)\n\n  i    faktorial\n---  -----------\n  1            1\n  2            2\n  3            6\n  4           24\n  5          120\n\n\nBahkan, pengolahan tabel bisa dilakukan di dalam fungsi…\n\ndef TabelFaktorial(n):\n    kolom_kiri = [] # berisi i\n    kolom_kanan = [] # berisi faktorial atau i!\n    \n    # nilai awal\n    hasil = 1\n\n    # tambahkan ke list\n    kolom_kiri.append(1)\n    kolom_kanan.append(hasil)\n\n    # iterasi\n    for i in range(2, n+1):\n        # mulai dari 2, lanjut selama i &lt; n + 1\n        # sehingga iterasi terakhir adalah untuk i = n\n\n        hasil = hasil * i\n\n        # tambahkan tiap hasil baru ke list\n        kolom_kiri.append(i)\n        kolom_kanan.append(hasil)\n    \n    tabel_mentah = []\n    for i in range(0,n):\n        # sampai indeks (n-1)\n        # nilai n tergantung banyaknya iterasi\n\n        calon_baris = []\n        calon_baris.append(kolom_kiri[i])\n        calon_baris.append(kolom_kanan[i])\n        tabel_mentah.append(calon_baris)\n    \n    # mengolah tabel di dalam fungsi\n    tabel_olahan = tabulate(tabel_mentah, headers=[\"i\", \"faktorial\"])\n    return tabel_olahan\n\ntabel_jadi = TabelFaktorial(5)\nprint(tabel_jadi)\n\n  i    faktorial\n---  -----------\n  1            1\n  2            2\n  3            6\n  4           24\n  5          120\n\n\nTentu saja, nilai 5 itu selalu bisa diganti menjadi sembarang bilangan bulat positif, seperti 7, 10, 15, 22, atau bahkan lebih besar lagi, dan banyaknya baris akan menyesuaikan, karena pembentukan tabel dilakukan secara otomatis.\n\ntabel_jadi = TabelFaktorial(22)\nprint(tabel_jadi)\n\n  i               faktorial\n---  ----------------------\n  1                       1\n  2                       2\n  3                       6\n  4                      24\n  5                     120\n  6                     720\n  7                    5040\n  8                   40320\n  9                  362880\n 10                 3628800\n 11                39916800\n 12               479001600\n 13              6227020800\n 14             87178291200\n 15           1307674368000\n 16          20922789888000\n 17         355687428096000\n 18        6402373705728000\n 19      121645100408832000\n 20     2432902008176640000\n 21    51090942171709440000\n 22  1124000727777607680000\n\n\n\n\n\nPada Metode Newton dengan Beda Hingga, nilai \\(h\\) konstan. Kalau kita punya dua tebakan awal yang saling dekat, misal \\(p_0\\) dan \\(p_1\\), kita bisa saja memanfaatkannya dengan memasang \\(h = p_1 - p_0\\). Bahkan, ketika iterasi \\(p_n\\) sudah semakin dekat menuju akar, jarak antara \\(p_{n-1}\\) dan \\(p_{n-2}\\) menjadi semakin kecil. Sehingga, dengan memasang nilai \\(h = p_{n-2} - p_{n-1}\\) atau \\(h = p_{n-1} - p_{n-2}\\), kita berhasil membuat limit \\(h\\) menuju nol.\nModifikasi ini disebut Metode Secant, dengan iterasi sebagai berikut untuk menentukan penyelesaian \\(f(x) = 0\\) dengan fungsi \\(f\\) yang kontinu:\n\\[\\begin{align*}\np_n &= p_{n-1} - \\frac{f(p_{n-1})}{\\left(\\frac{f(p_{n-1})-f(p_{n-2})}{p_{n-1}-p_{n-2}}\\right)} \\\\\n&= p_{n-1} - \\frac{f(p_{n-1})(p_{n-1} - p_{n-2})}{f(p_{n-1}) - f(p_{n-2})}\n\\end{align*}\\]\nDibandingkan Metode Newton yang biasa, Metode Secant menggantikan \\(f'(p_{n-1})\\) dengan\n\\[f'(p_{n-1}) \\approx \\frac{f(p_{n-1}) - f(p_{n-2})}{p_{n-1} - p_{n-2}}\\]\nsehingga, tidak seperti Metode Newton yang hanya memerlukan satu tebakan awal, Metode Secant membutuhkan dua tebakan awal, yaitu \\(p_0\\) dan \\(p_1\\). Namun, dibandingkan dengan Metode Newton dengan Beda Hingga, nilai \\(h\\) atau beda hingga tersebut tidak perlu ditentukan secara manual.\nMenariknya, Metode Secant memiliki order of convergence = \\(\\phi \\approx 1.618\\).\n\ndef Secant(f,p0,p1,tolerance):\n    p = p1 - (f(p1)*(p1-p0))/(f(p1)-f(p0))\n    abs_error = abs(p-p1)\n    p0 = p1\n    p1 = p\n\n    while abs_error &gt; tolerance:\n        p = p1 - (f(p1)*(p1-p0))/(f(p1)-f(p0))\n        abs_error = abs(p-p1)\n        p0 = p1\n        p1 = p\n    return p\n\n\nfrom numpy import sin, cos, tan, log, exp, sqrt\nformula = input(\"Masukkan formula fungsi: \")\n\ndef f(x):\n    return eval(formula)\n\ntitik_1 = eval(input(\"Masukkan titik awal pertama: \"))\ntitik_2 = eval(input(\"Masukkan titik awal kedua: \"))\ntolerance = eval(input(\"Masukkan toleransi aproksimasi: \"))\n\nakar_secant = Secant(f,titik_1,titik_2,tolerance)\n\nprint(f\"Akar dari persamaan f(x) = {formula} adalah x = {akar_secant}\")\n\nMasukkan formula fungsi: 2*x - 3*cos(x) + exp(-5*x) - 9\nMasukkan titik awal pertama: -1\nMasukkan titik awal kedua: -2\nMasukkan toleransi aproksimasi: 10**(-7)\nAkar dari persamaan f(x) = 2*x - 3*cos(x) + exp(-5*x) - 9 adalah x = -0.5073224866425831\n\n\n\n\n\nSejauh ini, kita sudah membahas beberapa metode root-finding atau aproksimasi akar, yaitu:\n\nMetode Bisection\nMetode Fixed-Point\nMetode Newton biasa (dengan turunan analitik)\nMetode Newton dengan Beda Hingga (finite-difference Newton’s method)\nMetode Secant\n\nDi antara semua metode tersebut, hanya Metode Bisection yang dijamin konvergen menuju akar di interval yang diberikan; semua metode lain ada kemungkinan divergen (menjauh dari akar, seperti metode fixed-point) atau gagal karena terjadi pembagian nol. Sayangnya, Metode Bisection termasuk metode yang pelan di antara metode numerik lainnya.\nUntuk menjaga jaminan kekonvergenan oleh Metode Bisection tetapi memperbaiki kecepatan kekonvergenannya, kita bisa memodifikasi Metode Bisection, yaitu memodifikasi cara menentukan \\(p\\) yang baru yang akan mempersempit interval. Perhatikan bahwa Metode Bisection membutuhkan dua “tebakan awal” (lebih tepatnya dua batasan interval), sedangkan metode di atas yang juga membutuhkan dua tebakan awal hanyalah Metode Secant.\nApakah kita bisa menggunakan Metode Bisection, tetapi dengan modifikasi menentukan \\(p\\) seperti Metode Secant, agar mendapatkan order of convergence seperti Metode Secant?\nJawabannya adalah bisa, dan modifikasi tersebut dinamakan Metode Regula Falsi. Sehingga, Metode Regula Falsi bisa disebut perpaduan antara Metode Bisection dan Metode Secant.\nSebenarnya, perbedaan algoritma Metode Bisection dan Metode Regula Falsi hanya di satu baris saja, yaitu mengubah baris\n\\[p=\\frac{a+b}{2}\\]\nmenjadi\n\\[p = b - \\frac{f(b)(b-a)}{f(b) - f(a)}\\]\nsesuai Metode Secant. Perhatikan bahwa Metode Secant biasanya membutuhkan dua tebakan awal yang tidak harus sama dengan batasan interval, sedangkan Metode Regula Falsi secara otomatis menggunakan kedua batasan interval \\([a,b]\\) sebagai dua tebakan awal.\nUntuk pembuatan kode Metode Regula Falsi, kami serahkan ke kalian. Gampang, kok! Tinggal mengubah beberapa baris saja (baris yang menentukan nilai \\(p\\) yang baru) pada kode Metode Bisection, yaitu mengambil baris tersebut dari kode Metode Secant, kemudian menyesuaikan kedua tebakan awal menjadi kedua batasan interval.\nSeperti Metode Secant, Metode Regula Falsi juga memiliki order of convergence = \\(\\phi \\approx 1.618\\).\n\n\n\nSuatu “barisan” (sequence) adalah sekumpulan angka yang berurut. Artinya, pada suatu barisan, ada yang bisa disebut angka pertama (atau suku pertama), angka kedua (suku kedua), angka ketiga (suku ketiga), dan sebagainya. Banyaknya suku bisa berhingga maupun tak terhingga.\nSuku-suku pada suatu barisan itu bisa saja ditentukan secara manual atau sesuka hati, atau bisa juga menggunakan rumus. Intinya, suku-suku suatu barisan itu bisa diperoleh dari manapun, bahkan dari hasil iterasi metode numerik (\\(p_0\\), \\(p_1\\), \\(p_2\\), \\(p_3\\), …) juga bisa.\nOleh karena itu, contoh barisan berhingga adalah hasil iterasi fixed-point, misalnya dengan \\(g(x) = 1 + \\frac{1}{x}\\), tebakan awal \\(p_0 = 2\\), dan batas toleransi \\(10^{-7}\\):\n\\[\\begin{align*}\n(& 1.5, 1.6666666666666665, 1.6, \\\\\n& 1.625, 1.6153846153846154, \\\\\n& 1.619047619047619, \\dots, \\\\\n& 1.6180339631667064)\n\\end{align*}\\]\nProses tersebut berakhir setelah 17 iterasi, sehingga barisan tersebut memiliki 17 suku.\nBarisan tersebut bisa diberi nama, seperti \\(p_n\\) dengan \\(n = 1, 2, 3, \\dots, 17\\), yang bisa dituliskan \\(\\left\\{p_n\\right\\}_{n=1}^{17}\\) dengan kurung kurawal.\nContoh barisan tak berhingga adalah barisan aritmetika dan barisan geometri, seperti:\n\\[(-5, -2, 1, 4, 7, 10, 13, 16, 19, \\dots)\\]\n\\[\\left(16, 8, 4, 2, 1, \\frac{1}{2}, \\frac{1}{4}, \\frac{1}{8}, \\dots\\right)\\]\nBarisan tak berhingga dengan nama \\(p_n\\) yang mulai dari suku \\(n=1\\) bisa ditulis \\(\\left\\{p_n\\right\\}_{n=1}^{\\infty}\\) dengan kurung kurawal, atau singkatnya \\((p_n)\\) saja dengan kurung biasa (dengan begitu, biasanya ada asumsi bahwa barisan tersebut tak berhingga).\n\n\n\nAlexander Aitken menemukan bahwa, untuk sembarang barisan (termasuk sembarang metode numerik) yang memiliki kekonvergenan linier, untuk nilai \\(n\\) yang besar, berlaku\n\\[\\frac{p_{n+1} - p}{p_n - p} \\approx \\frac{p_{n+2} - p}{p_{n+1} - p}\\]\ndi mana \\(p\\) adalah nilai yang ingin dicari, sedangkan \\(p_n\\), \\(p_{n+1}\\), dan \\(p_{n+2}\\) adalah tiga suku barisan (atau tiga hasil aproksimasi) berturut-turut. Artinya, perbandingan error (error ratio) antar dua pasang hasil iterasi (diperoleh dari tiga hasil iterasi berturut-turut) menjadi kurang lebih sama. Dengan manipulasi aljabar, diperoleh\n\\[p \\approx p_n - \\frac{\\left(p_{n+1} - p_n\\right)^2}{p_{n+2} - 2p_{n+1} + p_n}\\]\nseolah-olah ada jalur pintas untuk langsung mendapatkan nilai yang ingin dicari.\nTentu saja, sebelum menggunakan rumus ini, kita perlu menemukan tiga hasil aproksimasi pertama, yaitu \\(p_0\\), \\(p_1\\), dan \\(p_2\\). Kemudian, barulah kita tentukan \\(p_3\\) menggunakan rumus Aitken (hasil rumus Aitken biasa disebut \\(\\hat{p}_n\\), sehingga bisa ditulis \\(p_3 = \\hat{p}_0\\), karena perhitungan \\(p_3\\) memanfaatkan \\(p_0\\), \\(p_1\\) dan \\(p_2\\)).\nVariabel \\(\\hat{p}\\) biasa disebut p-hat atau p-cap (kata “hat” atau “cap” artinya topi).\nApabila kita definisikan \\(\\Delta p_n = p_{n+1} - p_n\\) dan \\(\\Delta^2 p_n = p_{n+2} - 2p_{n+1} + p_n\\), rumus Aitken bisa ditulis\n\\[\\hat{p}_n = p_n - \\frac{(\\Delta p_n)^2}{\\Delta^2 p_n}\\]\nsehingga teknik ini biasa disebut Aitken’s delta-squared (\\(\\Delta^2\\)) method.\nCatatan: dalam pembahasan metode Aitken/Steffensen, penulisan \\(\\Delta^2\\) BUKAN berarti \\((\\Delta)^2\\). Itu hanya penulisan saja.\nSecara umum, apabila kita punya suku-suku suatu barisan yang berturut-turut yaitu \\(p_1, p_2, p_3, \\dots, p_{k-3}, p_{k-2}, p_{k-1}, p_{k}\\), maka rumus Aitken bisa digunakan untuk menentukan \\(\\hat{p}_1, \\hat{p}_2, \\hat{p}_3, \\dots, \\hat{p}_{k-3}, \\hat{p}_{k-2}\\), yang semuanya merupakan aproksimasi nilai yang lebih akurat untuk hasil konvergen dari barisan tersebut (dengan asumsi kekonvergenan linier).\nPerhatikan: - Kita hanya bisa berhenti sampai \\(\\hat{p}_{k-2}\\), karena perhitungannya membutuhkan \\(p_{k-2}\\), \\(p_{k-1}\\) dan \\(p_k\\). - Harus ada minimal 3 suku yang diketahui, artinya \\(k \\ge 3\\).\n\ndef Aitken(p):\n    k = len(p)\n    if k &lt; 3:\n        return \"Maaf, dibutuhkan minimal 3 suku yang diketahui.\"\n    \n    # kalau lanjut ke sini, artinya k &gt;= 3\n    list_phat = []\n    for i in range(k-2):\n        Delta = p[i+1] - p[i]\n        DeltaSquared = p[i+2] - 2 * p[i+1] + p[i]\n        phat = p[i] - (Delta)**2 / DeltaSquared\n        list_phat.append(phat)\n    return list_phat\n\n\ntry:\n    # input suatu list\n    p = eval(input(\"Masukkan list suku-suku yang diketahui: \"))\nexcept:\n    print(\"Maaf, terjadi error. Harap masukkan list dengan benar.\")\nelse: # kalau tidak terjadi error \n    print(\"Berikut hasil metode Aitken:\") \n    print(Aitken(p))\n\nMasukkan list suku-suku yang diketahui: [2, 1.5, 1.6666666666666665, 1.6, 1.625]\nBerikut hasil metode Aitken:\n[1.625, 1.619047619047619, 1.6181818181818182]\n\n\n\n\n\nAitken hanya menemukan rumus. Johan Frederik Steffensen menemukan bahwa, karena Metode Fixed-Point memiliki kekonvergen linier, metode Aitken bisa digunakan untuk mempercepat Metode Fixed-Point.\nSecara umum, apabila kita berselang-seling antara menggunakan suatu metode dan rumus Aitken (misalnya setelah memperoleh tiga hasil aproksimasi), kita dapat mempercepat kekonvergenan (accelerating convergence), seolah-olah order of convergence menjadi lebih besar dari 1. Namun, bagaimana cara selang-selingnya?\nMenurut Steffensen, rumus Aitken bisa digunakan tiap tiga iterasi fixed-point, yaitu untuk \\(p_3\\), \\(p_6\\), \\(p_9\\), dan seterusnya.\nKita bisa memodifikasi rumus Aitken dengan menggeser indeks \\(n\\), yaitu menukar \\(n\\) dengan \\(n-3\\), untuk mendapatkan rumus iterasi:\n\\[\\hat{p} = p_{n-3} - \\frac{\\left(p_{n-2} - p_{n-3}\\right)^2}{p_{n-1} - 2p_{n-2} + p_{n-3}}\\]\ndan dalam hal ini, kita juga bisa mendefinisikan \\(\\Delta_1 = p_{n-2} - p_{n-3}\\) dan \\(\\Delta_2 = p_{n-1} - 2p_{n-2} + p_{n-3}\\) untuk mendapatkan bentuk:\n\\[\\hat{p} = p_{n-3} - \\frac{(\\Delta_1)^2}{(\\Delta_2)}\\]\n\ndef Steffensen(g, p0, tolerance):\n    # list semua nilai p agar mudah diakses\n    list_p = [p0]\n\n    # nilai sementara\n    abs_error = tolerance + 1 \n\n    iterasi = 1 # penghitung banyaknya iterasi\n    while abs_error &gt;= tolerance:\n        if iterasi % 3 == 0: # untuk kelipatan tiga, gunakan rumus Aitken\n            pn_3 = list_p[iterasi - 3] # p_(n-3)\n            pn_2 = list_p[iterasi - 2] # p_(n-2)\n            pn_1 = list_p[iterasi - 1] # p_(n-1)\n            Delta1 = pn_2 - pn_3\n            Delta2 = pn_1 - 2 * pn_2 + pn_3\n            pn = pn_3 - (Delta1)**2 / Delta2\n        else: # selain kelipatan 3, gunakan fixed point\n            pn_1 = list_p[iterasi - 1]\n            pn = g(pn_1)\n        \n        list_p.append(pn)\n        abs_error = abs( pn - pn_1 )\n        iterasi += 1\n    \n    # return bukan hanya p, tetapi juga banyaknya iterasi\n    return pn, iterasi\n\n\nfrom numpy import sin, cos, tan, log, exp, sqrt\n\nformula = input(\"Masukkan formula g(x): \")\n\ndef g(x):\n    return eval(formula)\n\nstarting_point = eval(input(\"Masukkan titik awal iterasi: \"))\ntolerance = eval(input(\"Masukkan batas toleransi: \"))\n\np_steffensen, i_steffensen = Steffensen(g, starting_point, tolerance)\n\nprint(\"Metode Steffensen\")\nprint(\"Hasil: \" + str(p_steffensen))\nprint(\"setelah banyaknya iterasi: \" + str(i_steffensen))\n\nprint(\"Bandingkan banyaknya iterasi dengan Metode Fixed-Point biasa:\")\n\nfixpoint_hasil, fixpoint_tabel = FixedPoint(g, starting_point, tolerance)\nprint(fixpoint_tabel)\n\nMasukkan formula g(x): 1 + 1/x\nMasukkan titik awal iterasi: 2\nMasukkan batas toleransi: 10**(-7)\nMetode Steffensen\nHasil: 1.618033988749648\nsetelah banyaknya iterasi: 11\nBandingkan banyaknya iterasi dengan Metode Fixed-Point biasa:\n+---------+--------------------+\n| iterasi |    Aproksimasi     |\n+---------+--------------------+\n|    1    |        1.5         |\n|    2    | 1.6666666666666665 |\n|    3    |        1.6         |\n|    4    |       1.625        |\n|    5    | 1.6153846153846154 |\n|    6    | 1.619047619047619  |\n|    7    | 1.6176470588235294 |\n|    8    | 1.6181818181818182 |\n|    9    | 1.6179775280898876 |\n|   10    | 1.6180555555555556 |\n|   11    | 1.6180257510729614 |\n|   12    | 1.6180371352785146 |\n|   13    | 1.6180327868852458 |\n|   14    | 1.618034447821682  |\n|   15    | 1.618033813400125  |\n|   16    | 1.6180340557275543 |\n|   17    | 1.6180339631667064 |\n+---------+--------------------+"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/pdnum2024genap.html",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/pdnum2024genap.html",
    "title": "Praktikum PDNum (Persamaan Diferensial Numerik) 2024 Genap (Kurikulum 2020)",
    "section": "",
    "text": "Kembali ke Praktikum\n\nTimeline\n\nModul 1, 21-22 Februari 2024 (offline di Lab Komputer D.311 untuk sesi 1 dan sesi 2, dan di Lab Statistika D.406 untuk sesi 3)\nModul 2, 28-29 Februari 2024 (offline di Lab Komputer D.311 untuk sesi 1 dan sesi 2, dan di Lab Statistika D.406 untuk sesi 3)\nModul 3"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul2.html",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul2.html",
    "title": "Modul 2 Sains Data: Visualisasi Data",
    "section": "",
    "text": "Kembali ke Sains Data\nPada modul ini kita akan mempelajari beberapa cara untuk membuat visualisasi data menggunakan package Matplotlib dan Seaborn. Seaborn merupakan salah satu package visualisasi data yang sangat sering digunakan karena fleksibilitas dan banyaknya jenis plot yang disediakan."
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul2.html#prerequisites",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul2.html#prerequisites",
    "title": "Modul 2 Sains Data: Visualisasi Data",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nImport Module\nSebelum memulai, mari kita import terlebih dahulu module - module yang diperlukan.\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\n\nImport Data\nPada module kali ini, akan digunakan tiga data csv yang berbeda untuk mempermudah kebutuhan visualisasi, yaitu:\n\nSpotify Dataset (spotify.csv), bisa di-download dari\n\nDirect link (langsung dari GitHub Pages ini)\nKaggle\nGoogle Drive: https://bit.ly/DataWeek2 atau langsung\n\nFlight Delays Dataset (flight_delays.csv), bisa di-download dari\n\nDirect link (langsung dari GitHub Pages ini)\nKaggle\nGoogle Drive: https://bit.ly/DataWeek2 atau langsung\n\nInsurance Dataset (insurance.csv), bisa di-download dari\n\nDirect link (langsung dari GitHub Pages ini)\nKaggle\nGoogle Drive: https://bit.ly/DataWeek2 atau langsung\n\n\natau langsung download ketiganya sekaligus, bisa dari:\n\nGoogle Drive: https://bit.ly/DataWeek2 atau langsung\n\nKemudian, baca tiap CSV sebagai dataframe:\n\nspotify_df = pd.read_csv(\"./spotify.csv\",\n                         index_col='Date',\n                         parse_dates=['Date'])\nflight_df = pd.read_csv(\"./flight_delays.csv\")\ninsurance_df = pd.read_csv(\"./insurance.csv\")"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul2.html#review-matplotlib",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul2.html#review-matplotlib",
    "title": "Modul 2 Sains Data: Visualisasi Data",
    "section": "Review Matplotlib",
    "text": "Review Matplotlib\nSeperti yang sudah dipelajari pada Algoritma dan Pemrograman, visualisasi data dapat dilakukan dengan module matplotlib, antara lain untuk membuat line plot dan scatter plot.\nPertama, kita akan menggunakan data Spotify, yaitu data total daily streams 5 lagu hits pada masanya.\n\nspotify_df\n\n\n\n\n\n\n\n\nShape of You\nDespacito\nSomething Just Like This\nHUMBLE.\nUnforgettable\n\n\nDate\n\n\n\n\n\n\n\n\n\n2017-01-06\n12287078\nNaN\nNaN\nNaN\nNaN\n\n\n2017-01-07\n13190270\nNaN\nNaN\nNaN\nNaN\n\n\n2017-01-08\n13099919\nNaN\nNaN\nNaN\nNaN\n\n\n2017-01-09\n14506351\nNaN\nNaN\nNaN\nNaN\n\n\n2017-01-10\n14275628\nNaN\nNaN\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n\n\n2018-01-05\n4492978\n3450315.0\n2408365.0\n2685857.0\n2869783.0\n\n\n2018-01-06\n4416476\n3394284.0\n2188035.0\n2559044.0\n2743748.0\n\n\n2018-01-07\n4009104\n3020789.0\n1908129.0\n2350985.0\n2441045.0\n\n\n2018-01-08\n4135505\n2755266.0\n2023251.0\n2523265.0\n2622693.0\n\n\n2018-01-09\n4168506\n2791601.0\n2058016.0\n2727678.0\n2627334.0\n\n\n\n\n366 rows × 5 columns\n\n\n\nCatatan:\n\nShape of You dirilis tanggal 6 Januari 2017.\nDespacito dirilis tanggal 13 Januari 2017.\nSomething Just Like This dirilis tanggal 22 Februari 2017.\nHUMBLE. dirilis tanggal 30 Maret 2017.\nUnforgettable dirilis tanggal 7 April 2017.\n\nPerhatikan bahwa ada beberapa data NaN (not a number), artinya tidak ada data (missing data).\n\nspotify_df.isna()\n\n\n\n\n\n\n\n\nShape of You\nDespacito\nSomething Just Like This\nHUMBLE.\nUnforgettable\n\n\nDate\n\n\n\n\n\n\n\n\n\n2017-01-06\nFalse\nTrue\nTrue\nTrue\nTrue\n\n\n2017-01-07\nFalse\nTrue\nTrue\nTrue\nTrue\n\n\n2017-01-08\nFalse\nTrue\nTrue\nTrue\nTrue\n\n\n2017-01-09\nFalse\nTrue\nTrue\nTrue\nTrue\n\n\n2017-01-10\nFalse\nTrue\nTrue\nTrue\nTrue\n\n\n...\n...\n...\n...\n...\n...\n\n\n2018-01-05\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n2018-01-06\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n2018-01-07\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n2018-01-08\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n2018-01-09\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n\n\n366 rows × 5 columns\n\n\n\n\nspotify_df.isna().sum()\n\nShape of You                 0\nDespacito                    7\nSomething Just Like This    47\nHUMBLE.                     84\nUnforgettable               91\ndtype: int64\n\n\nCara menangani missing values tergantung konteks. Di sini, lagu-lagu dengan data NaN pada tanggal tertentu memang belum dirilis.\n\nUntuk analisis trend tiap lagu sejak dirilis, sebaiknya data NaN dibiarkan saja.\nUntuk analisis frekuensi streaming, data NaN bisa diganti jadi nol. (Hati-hati, jangan sampai nantinya lupa dan malah terpikir “kok bisa ya lagu ini ga didengerin sama sekali”)\nApabila semua lagu ingin dibandingkan datanya di masa sudah rilis semua, sebaiknya baris-baris dengan data NaN itu dihapus.\n\nKali ini, kita akan memperhatikan trend tiap lagu, sehingga data NaN kita biarkan saja.\nBerikut adalah cara untuk membuat line plot pada satu fitur di dataframe menggunakan matplotlib\n\n\"\"\"\nMembuat line plot untuk lagu Shape of You menggunakan matplotlib\n\"\"\"\n\n# Mengatur besar figur plot\nplt.subplots(figsize=(8,6))\n\n# Membuat line plot\nplt.plot(spotify_df['Shape of You'], 'b')\n# Membuat label sumbu-x dan sumbu-y\nplt.xlabel('Date')\nplt.ylabel('Shape of You Total Daily Streams')\n# Menampilkan plot\nplt.show()\n\n\n\n\nApabila kita ingin menampilkan fitur-fitur lain dalam figur yang sama, kita dapat memanfaatkan loop\n\n\"\"\"\nMembuat line plot untuk semua lagu dalam spotify_df menggunakan loop\n\"\"\"\n\nplt.subplots(figsize=(8,6))\n\n# Loop setiap nama kolom pada dataframe, lalu plot\nfor column in spotify_df.columns:\n    plt.plot(spotify_df[column])\n\nplt.legend(spotify_df.columns)\nplt.show()\n\n\n\n\nNamun, terdapat cara yang lebih mudah selain menggunakan looping. pandas dataframe memiliki method yang dapat secara langsung memvisualisasikan keseluruhan fiturnya, yaitu .plot().\nPada .plot() kita memiliki beberapa parameter yang dapat diatur, antara lain kind dan figsize. kind berfungsi untuk mengatur jenis plot yang ingin kita buat, sedangkan figsize berfungsi untuk mengatur besar figur yang dihasilkan.\nParameter lainnya dapat dilihat pada:\nhttps://pandas.pydata.org/docs/reference/api/pandas.DataFrame.plot.html\n\n\"\"\"\nMembuat line plot untuk semua lagu dalam spotify_df menggunakan pandas .plot()\n\"\"\"\n\nspotify_df.plot(kind='line', figsize=(8,6))\nplt.xlabel('Date')\nplt.ylabel('Total Daily Streams')\nplt.show()\n\n\n\n\nSelain line plot, terdapat banyak macam kind yang bisa digunakan. Pada code cell dibawah terlihat bahwa pandas .plot() dapat menghasilkan histogram (perlu diperhatikan bahwa jenis plot perlu menyesuaikan tipe data yang dimiliki, terlihat bahwa menggunakan data spotify, histogram tidak menghasilkan insight yang cukup berguna).\n\nspotify_df.plot(kind='hist', figsize=(8,6), alpha=.7)\n\nplt.show()\n\n\n\n\nPada praktikum Algoritma dan Pemrograman kita juga telah mempelajari cara untuk membuat scatter plot. Berikut code untuk membuat scatter plot menggunakan matplotlib, untuk melihat korelasi antara daily streams lagu Shape of You dengan Something Just Like This.\n\n\"\"\"\nMembuat scatter plot untuk melihat korelasi antara lagu\nShape of You dengan Something Just Like This menggunakan\nmatplotlib\n\"\"\"\n\nplt.subplots(figsize=(8,6))\n\nplt.scatter(x=spotify_df['Shape of You'], \n            y=spotify_df['Something Just Like This'],\n            alpha=.5)\nplt.xlabel('\"Shape of You\" Total Daily Streams')\nplt.ylabel('\"Something Just Like This\" Total Daily Streams')\nplt.show()"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul2.html#pengenalan-seaborn",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul2.html#pengenalan-seaborn",
    "title": "Modul 2 Sains Data: Visualisasi Data",
    "section": "Pengenalan Seaborn",
    "text": "Pengenalan Seaborn\nWalaupun matplotlib cukup fleksibel dalam menghasilkan plot, tetapi tipe plot yang disediakan cenderung terbatas. Oleh karena itu, kita dapat menggunakan Seaborn karena tipe plot yang disediakan sangat banyak sesuai kebutuhan kita, antara lain line, bar, heatmap, scatter, box, swarm, histogram, density, dan masih banyak lagi.\n\nLine Plot\nLine plot biasa digunakan untuk melihat trend data dalam jangka waktu tertentu.\nUntuk membuat line plot pada seaborn, kita dapat menggunakan sns.lineplot(). Jika data yang ingin kita visualisasikan adalah dataframe, kita dapat memasukkan variabel dataframe tersebut pada parameter data, seperti code di bawah ini.\n\n\"\"\"\nMembuat line plot dengan module seaborn\n\"\"\"\n\nplt.subplots(figsize=(8,6))\nsns.lineplot(data=spotify_df)\nplt.show()\n\n\n\n\nFleksibilitas Seaborn membuat kita dapat memilih color palette yang sesuai dengan keinginan kita. Kita dapat memilih palette yang sudah disediakan oleh seaborn (antara lain: bright, deep, pastel, dan masih banyak lagi) atau kita dapat mengatur sendiri palette yang ingin kita gunakan.\nUntuk memilih palette yang akan digunakan untuk plot selanjutnya pada seaborn, kita dapat menggunakan sns.set_palette().\nJenis palette yang disediakan seaborn serta cara membuat color palette secara mandiri dapat dilihat pada:\nhttps://seaborn.pydata.org/tutorial/color_palettes.html#tools-for-choosing-color-palettes\n\n# Mengganti color palette menjadi \"bright\"\nsns.set_palette('bright')\n\n\n\"\"\"\nMembuat line plot setelah color palette diubah menjadi \"bright\"\n\"\"\"\n\n# Mengatur besar figur yang ingin ditampilkan\nplt.figure(figsize=(14,6))\n\n# Membuat line plot\nsns.lineplot(data=spotify_df)\n# Membuat judul figur\nplt.title(\"Daily Global Streams of Popular Songs in 2017-2018\")\n# Menampilkan plot\nplt.show()\n\n\n\n\nApabila tidak semua fitur pada data ingin kita visualisasikan, kita dapat menggunakan sns.lineplot() beberapa kali, sesuai dengan banyaknya fitur yang ingin kita tampilkan, seperti pada code di bawah.\n\nplt.figure(figsize=(14,6))\n\n# Membuat line plot hanya dengan lagu Shape of You\nsns.lineplot(data=spotify_df['Shape of You'], label=\"Shape of You\")\n# Menambahkan line plot pada figur dengan lagu Despacito\nsns.lineplot(data=spotify_df['Despacito'], label=\"Despacito\")\n\nplt.title(\"Daily Global Streams of Popular Songs in 2017-2018\")\nplt.xlabel(\"Date\")\nplt.ylabel('')\nplt.show()\n\n\n\n\n\n\nBar Plot\nBar plot biasa digunakan untuk membandingkan kuantitas/nilai pada data bertipe kategori.\nSelanjutnya, kita akan menggunakan data flight_delays.csv, yaitu data rata-rata keterlambatan beberapa maskapai pesawat pada setiap bulannya.\n\nflight_df\n\n\n\n\n\n\n\n\nMonth\nAA\nAS\nB6\nDL\nEV\nF9\nHA\nMQ\nNK\nOO\nUA\nUS\nVX\nWN\n\n\n\n\n0\n1\n6.955843\n-0.320888\n7.347281\n-2.043847\n8.537497\n18.357238\n3.512640\n18.164974\n11.398054\n10.889894\n6.352729\n3.107457\n1.420702\n3.389466\n\n\n1\n2\n7.530204\n-0.782923\n18.657673\n5.614745\n10.417236\n27.424179\n6.029967\n21.301627\n16.474466\n9.588895\n7.260662\n7.114455\n7.784410\n3.501363\n\n\n2\n3\n6.693587\n-0.544731\n10.741317\n2.077965\n6.730101\n20.074855\n3.468383\n11.018418\n10.039118\n3.181693\n4.892212\n3.330787\n5.348207\n3.263341\n\n\n3\n4\n4.931778\n-3.009003\n2.780105\n0.083343\n4.821253\n12.640440\n0.011022\n5.131228\n8.766224\n3.223796\n4.376092\n2.660290\n0.995507\n2.996399\n\n\n4\n5\n5.173878\n-1.716398\n-0.709019\n0.149333\n7.724290\n13.007554\n0.826426\n5.466790\n22.397347\n4.141162\n6.827695\n0.681605\n7.102021\n5.680777\n\n\n5\n6\n8.191017\n-0.220621\n5.047155\n4.419594\n13.952793\n19.712951\n0.882786\n9.639323\n35.561501\n8.338477\n16.932663\n5.766296\n5.779415\n10.743462\n\n\n6\n7\n3.870440\n0.377408\n5.841454\n1.204862\n6.926421\n14.464543\n2.001586\n3.980289\n14.352382\n6.790333\n10.262551\nNaN\n7.135773\n10.504942\n\n\n7\n8\n3.193907\n2.503899\n9.280950\n0.653114\n5.154422\n9.175737\n7.448029\n1.896565\n20.519018\n5.606689\n5.014041\nNaN\n5.106221\n5.532108\n\n\n8\n9\n-1.432732\n-1.813800\n3.539154\n-3.703377\n0.851062\n0.978460\n3.696915\n-2.167268\n8.000101\n1.530896\n-1.794265\nNaN\n0.070998\n-1.336260\n\n\n9\n10\n-0.580930\n-2.993617\n3.676787\n-5.011516\n2.303760\n0.082127\n0.467074\n-3.735054\n6.810736\n1.750897\n-2.456542\nNaN\n2.254278\n-0.688851\n\n\n10\n11\n0.772630\n-1.916516\n1.418299\n-3.175414\n4.415930\n11.164527\n-2.719894\n0.220061\n7.543881\n4.925548\n0.281064\nNaN\n0.116370\n0.995684\n\n\n11\n12\n4.149684\n-1.846681\n13.839290\n2.504595\n6.685176\n9.346221\n-1.706475\n0.662486\n12.733123\n10.947612\n7.012079\nNaN\n13.498720\n6.720893\n\n\n\n\n\n\n\nUntuk membuat bar plot pada seaborn dengan dataframe, kita dapat menggunakan sns.barplot() dengan tiga parameter yang wajib kita set, yaitu:\n\ndata: dataframe yang ingin kita visualisasikan\nx: nama fitur pada dataframe yang ingin kita jadikan sumbu-x\ny: nama fitur pada dataframe yang ingin kita jadikan sumbu-y\n\nPada kode di bawah, juga digunakan satu parameter opsional, yaitu palette yang merupakan cara lain untuk mengatur color palette yang ingin kita gunakan\n\n\"\"\"\nMembuat bar plot keterlambatan maskapai EV setiap \nbulannya menggunakan seaborn\n\"\"\"\n\nplt.figure(figsize=(14,6))\n\nsns.barplot(data=flight_df, x='Month', y='EV',\n            palette=sns.color_palette('deep'))\nplt.ylabel('EV Flight Delays (minute)')\nplt.title('Average EV Flight Delays per Month')\nplt.show()\n\n\n\n\nBerdasarkan hasil plot di atas, terlihat bahwa maskapai EV memiliki rata-rata keterlambatan terlama pada bulan Juni, serta tercepat pada bulan September.\nSelanjutnya, mari kita coba lihat urutan rata-rata keterlambatan semua maskapai dalam satu tahun (maskapai mana yang memiliki rata-rata keterlambatan terlama, serta maskapai mana yang tercepat).\nHal pertama yang perlu kita lakukan adalah, jadikan fitur Month sebagai index dataframe.\n\n# Set fitur \"Month\" menjadi index dataframe\nflight_df = flight_df.set_index('Month')\nflight_df.head(2)\n\n\n\n\n\n\n\n\nAA\nAS\nB6\nDL\nEV\nF9\nHA\nMQ\nNK\nOO\nUA\nUS\nVX\nWN\n\n\nMonth\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n6.955843\n-0.320888\n7.347281\n-2.043847\n8.537497\n18.357238\n3.512640\n18.164974\n11.398054\n10.889894\n6.352729\n3.107457\n1.420702\n3.389466\n\n\n2\n7.530204\n-0.782923\n18.657673\n5.614745\n10.417236\n27.424179\n6.029967\n21.301627\n16.474466\n9.588895\n7.260662\n7.114455\n7.784410\n3.501363\n\n\n\n\n\n\n\nSelanjutnya, kita perlu hitung rata-rata keterlambatan tiap maskapai dalam satu tahun, yaitu hitung rata-rata tiap kolom pada dataframe menggunakan .mean() (Tambahan: apabila kita ingin menghitung rata-rata tiap barisnya, kita dapat menggunakan parameter axis=1 pada .mean()). .mean() akan menghasilkan pandas Series.\nLalu, agar mempermudah kita dalam melihat visualisasi bar plotnya, kita dapat menggunakan .sort_values().\n\n# Simpan rata-rata keterlambatan semua maskapai dalam satu tahun pada variabel flight_mean_inyear\nflight_mean_inyear = flight_df.mean()\n# Urutkan flight_mean_inyear secara ascending\nflight_mean_inyear = flight_mean_inyear.sort_values()\n\nflight_mean_inyear\n\nAS    -1.023656\nDL     0.231116\nHA     1.993205\nUS     3.776815\nAA     4.120776\nWN     4.275277\nVX     4.717718\nUA     5.413415\nOO     5.909658\nMQ     5.964953\nEV     6.543328\nB6     6.788370\nF9    13.035736\nNK    14.549663\ndtype: float64\n\n\nTerakhir, visualisasikan bar plot menggunakan cara seperti sebelumnya.\nKita dapat lihat pada code dibawah bahwa tidak digunakan parameter data, karena flight_mean_inyear merupakan pandas Series (bukan dataframe) sehingga lebih mudah jika kita langsung menggunakan parameter x dan y saja.\n\nplt.subplots(figsize=(14,6))\nsns.barplot(x=flight_mean_inyear.index, \n            y=flight_mean_inyear.values,\n            palette=sns.color_palette('deep'))\nplt.title('Average Delay per Flight in a Year')\nplt.show()\n\n\n\n\nBerdasarkan plot diatas, NK merupakan maskapai dengan rata-rata keterlambatan terlama dalam satu tahun, sedangkan AS adalah yang tercepat (AS bernilai negatif yang berarti rata-rata kedatangan pesawat lebih cepat dari yang dijadwalkan dalam satu tahun.\n\n\nHeatmap\nHeatmap biasa digunakan untuk mempermudah melihat pola pada data berdasarkan warna yang dihasilkan.\nPada seaborn, kita dapat menggunakan heatmap dengan sns.heatmap() seperti pada kode dibawah. Parameter annot berfungsi untuk menampilkan nilai data (jika True) atau tidak (jika False).\nBar sebelah kanan heatmap menunjukkan bahwa, semakin lama keterlambatan pesawat, maka warna yang dihasilkan semakin terang. Sebaliknya, semakin gelap warna yang dihasilkan berarti semakin cepat pesawat datang tersebut.\n\n\"\"\"\nMembuat heatmap menggunakan Seaborn\n\"\"\"\nplt.figure(figsize=(14,10))\n\nsns.heatmap(data=flight_df, annot=True)\nplt.title(\"Average Arrival Delay for Each Airline, by Month\")\nplt.xlabel(\"Airline\")\nplt.show()\n\n\n\n\nBerdasarkan heatmap di atas, kita dapat melihat dengan mudah pada bulan apa suatu maskapai sangat terlambat (contoh: maskapai NK pada bulan Juni).\nHeatmap sangat sering digunakan untuk melihat korelasi antarfitur pada dataset agar kita dapat mengerti lebih jauh tentang fitur-fitur pada data, atau juga dapat dimanfaatkan untuk melakukan feature selection sebelum membuat sebuat model Machine Learning.\nUntuk melakukan hal tersebut, kita perlu menghitung dahulu korelasi antar fitur menggunakan pandas .corr(), yaitu fungsi yang akan menghitung korelasi antar dua fitur menggunakan korelasi Pearson.\nNotes: Metode korelasi dapat diubah dengan menggunakan parameter method pada .corr(), contoh: .corr(method='spearman'). Metode lainnya dapat dilihat pada:\nhttps://pandas.pydata.org/docs/reference/api/pandas.DataFrame.corr.html\n\n# Hitung korelasi antar dua fitur pada flight_df\nflight_corr = flight_df.corr()\n\nflight_corr\n\n\n\n\n\n\n\n\nAA\nAS\nB6\nDL\nEV\nF9\nHA\nMQ\nNK\nOO\nUA\nUS\nVX\nWN\n\n\n\n\nAA\n1.000000\n0.334980\n0.429854\n0.805229\n0.896523\n0.903986\n0.220065\n0.842701\n0.573716\n0.620477\n0.809874\n0.823713\n0.425237\n0.615664\n\n\nAS\n0.334980\n1.000000\n0.340359\n0.394359\n0.356608\n0.336791\n0.684979\n0.283977\n0.480863\n0.350657\n0.457414\n0.489025\n0.229571\n0.519228\n\n\nB6\n0.429854\n0.340359\n1.000000\n0.643313\n0.342627\n0.510718\n0.467905\n0.529724\n0.032038\n0.591115\n0.233021\n0.788345\n0.579750\n0.151750\n\n\nDL\n0.805229\n0.394359\n0.643313\n1.000000\n0.796951\n0.783265\n0.262251\n0.598765\n0.625277\n0.569073\n0.797339\n0.821757\n0.700605\n0.691805\n\n\nEV\n0.896523\n0.356608\n0.342627\n0.796951\n1.000000\n0.828515\n0.099369\n0.721468\n0.784026\n0.692697\n0.911499\n0.669736\n0.462638\n0.730115\n\n\nF9\n0.903986\n0.336791\n0.510718\n0.783265\n0.828515\n1.000000\n0.273878\n0.912984\n0.414064\n0.582509\n0.671986\n0.878874\n0.308397\n0.465765\n\n\nHA\n0.220065\n0.684979\n0.467905\n0.262251\n0.099369\n0.273878\n1.000000\n0.436015\n0.176485\n0.056941\n0.066821\n0.586160\n-0.008439\n-0.007296\n\n\nMQ\n0.842701\n0.283977\n0.529724\n0.598765\n0.721468\n0.912984\n0.436015\n1.000000\n0.281890\n0.586963\n0.503575\n0.660181\n0.150111\n0.239744\n\n\nNK\n0.573716\n0.480863\n0.032038\n0.625277\n0.784026\n0.414064\n0.176485\n0.281890\n1.000000\n0.365273\n0.827455\n0.293515\n0.395419\n0.742869\n\n\nOO\n0.620477\n0.350657\n0.591115\n0.569073\n0.692697\n0.582509\n0.056941\n0.586963\n0.365273\n1.000000\n0.626051\n0.590313\n0.561515\n0.548304\n\n\nUA\n0.809874\n0.457414\n0.233021\n0.797339\n0.911499\n0.671986\n0.066821\n0.503575\n0.827455\n0.626051\n1.000000\n0.477816\n0.536968\n0.926800\n\n\nUS\n0.823713\n0.489025\n0.788345\n0.821757\n0.669736\n0.878874\n0.586160\n0.660181\n0.293515\n0.590313\n0.477816\n1.000000\n0.333396\n0.242344\n\n\nVX\n0.425237\n0.229571\n0.579750\n0.700605\n0.462638\n0.308397\n-0.008439\n0.150111\n0.395419\n0.561515\n0.536968\n0.333396\n1.000000\n0.630278\n\n\nWN\n0.615664\n0.519228\n0.151750\n0.691805\n0.730115\n0.465765\n-0.007296\n0.239744\n0.742869\n0.548304\n0.926800\n0.242344\n0.630278\n1.000000\n\n\n\n\n\n\n\nPandas .corr() menghasilkan dataframe dengan nama baris dan kolom yang sama, serta berisi nilai korelasi antara baris dan kolom yang ditinjau (contoh: korelasi antara maskapai AA dan AS adalah 0,334980). Serta, dataframe yang dihasilkan adalah sebuat matriks simetris.\nTentu dengan hanya melihat dataframe di atas, tidak terlihat begitu jelas mana fitur yang memiliki korelasi tinggi dan mana yang yang memiliki korelasi rendah. Oleh karena itu, kita dapat memanfaatkan heatmap.\nPada code di bawah, untuk mempermudah pembacaan heatmap, kita menggunakan parameter vmin, vmax, dan center pada sns.heatmap(). vmin berfungsi untuk mengatur nilai terendah, vmax berfungsi untuk mengatur nilai tertinggi, dan center berfungsi untuk mengatur nilai tengah pada heatmap. Korelasi Pearson menghasilkan nilai antara -1 hingga 1, sehingga kita dapat set ketiga parameter tersebut seperti pada code di bawah.\n\nplt.figure(figsize=(14,10))\n\nsns.heatmap(data=flight_corr, vmin=-1, vmax=1, center=0, annot=True)\nplt.title(\"Pearson Correlation of Each Airline Flight Delays\")\nplt.xlabel(\"Airline\")\nplt.show()\n\n\n\n\nDengan menggunakan heatmap, sekarang terlihat bahwa mana maskapai yang keterlambatannya berkorelasi tinggi dan mana yang rendah. Misal, AA dan EV menghasilkan korelasi yang cukup tinggi positif, yaitu 0.9, yang artinya jika keterlambatan maskapai AA tinggi, begitu juga maskapai EV, dan sebaliknya jika keterlambatan maskapai AA rendah, begitu juga maskapai EV.\nUntuk meyakinkan kita dengan hal tersebut, kita dapat lihat pada materi selanjutnya, yaitu Scatter Plot.\n\n\nScatter Plot\nScatter plot biasa digunakan untuk melihat korelasi antara dua fitur bertipe numerik.\nUntuk menggunakan scatter plot pada seaborn, kita dapat menggunakan sns.scatterplot(), dengan parameter yang sama seperti kita membuat bar plot.\n\n\"\"\"\nMembuat scatter plot untuk melihat \nketerkaitan pada keterlambatan pesawat\nmaskapai EV dan AA\n\"\"\"\n\nsns.scatterplot(data=flight_df, x='EV', y='AA')\nplt.show()\n\n\n\n\nMelalui scatter plot di atas, kita dapat semakin yakin bahwa kesimpulan yang kita ambil dengan melihat heatmap sebelumnya benar.\n\n\"\"\"\nTambahan scatter plot pada maskapai lain yang\nmemiliki korelasi tinggi\n\"\"\"\n\nsns.scatterplot(data=flight_df, x='EV', y='UA')\nplt.show()\n\n\n\n\n\n\"\"\"\nScatter plot pada maskapai yang memiliki\nkorelasi rendah (mendekati 0)\n\"\"\"\n\nsns.scatterplot(data=flight_df, x='UA', y='HA')\nplt.show()\n\n\n\n\nPada heatmap, terlihat bahwa maskapai UA dan HA memiliki korelasi yang rendah, yaitu 0.067. Sehingga, jika kita buat scatter plotnya, menghasilkan plot seperti di atas.\nSekarang kita akan menggunakan dataset lainnya, yaitu insurance.csv yang merupakan data berisi biaya asuransi (charges) beberapa orang.\n\ninsurance_df.head()\n\n\n\n\n\n\n\n\nage\nsex\nbmi\nchildren\nsmoker\nregion\ncharges\n\n\n\n\n0\n19\nfemale\n27.900\n0\nyes\nsouthwest\n16884.92400\n\n\n1\n18\nmale\n33.770\n1\nno\nsoutheast\n1725.55230\n\n\n2\n28\nmale\n33.000\n3\nno\nsoutheast\n4449.46200\n\n\n3\n33\nmale\n22.705\n0\nno\nnorthwest\n21984.47061\n\n\n4\n32\nmale\n28.880\n0\nno\nnorthwest\n3866.85520\n\n\n\n\n\n\n\nMisal, kita ingin melihat keterkaitan indeks massa tubuh (bmi) seseorang dengan biaya asuransi (charges) orang tersebut. Sama seperti sebelumnya, kita dapat melakukannya seperti pada code di bawah.\n\n# Mengubah palette menjadi default\nsns.set_palette('tab10')\n# Membuat scatter plot antara fitur bmi dan charges\nsns.scatterplot(data=insurance_df, x='bmi', y='charges')\n\nplt.show()\n\n\n\n\nScatter plot di atas menunjukkan bahwa korelasi antara bmi dan charges adalah cenderung positif, tetapi tidak terlalu tinggi. Yang artinya, orang dengan BMI tinggi, cenderung akan membayar biaya asuransi lebih tinggi.\nAgar kita semakin yakin dengan kesimpulan tersebut, kita dapat menambahakn garis regresi pada scatter plot tersebut dengan menggunakan sns.regplot().\n\nsns.regplot(data=insurance_df, x='bmi', y='charges')\nplt.show()\n\n\n\n\nBerdasarkan scatter plot dan garis regresi dihasilkan, terlihat bahwa kesimpulan yang kita ambil benar. Agar semakin yakin lagi, kita juga dapat menghitung langsung korelasi Pearsonnya menggunakan cara sebelumnya, yaitu pandas .corr().\n\ninsurance_df[['bmi', 'charges']].corr()\n\n\n\n\n\n\n\n\nbmi\ncharges\n\n\n\n\nbmi\n1.000000\n0.198341\n\n\ncharges\n0.198341\n1.000000\n\n\n\n\n\n\n\nDengan menggunakan seaborn, kita juga dapat memvisualisasikan scatter plot berdasarkan dengan pewarnaan yang berbeda berdasarkan fitur lainnya yang bertipe kategorik.\nMisal, kita ingin membuat scatter plot antara fitur bmi dan charges dengan pewarnaannya berdasarkan nilai dari fitur smoker, yaitu yes atau no. Kita dapat set parameter hue='smoker' pada sns.scatterplot() seperti pada code di bawah.\n\nsns.scatterplot(data=insurance_df, x='bmi', y='charges', hue='smoker')\nplt.show()\n\n\n\n\nSehingga dihasilkan pewarnaan yang berbeda untuk seseorang yang merupakan perokok (biru) dan yang tidak (orange). Berdasarkan scatter plot di atas, terlihat bahwa korelasi antara bmi dan charges untuk perokok cendering tinggi positif (semakin besar bmi, semakin besar juga charges). Sedangkan, untuk bukan perokok, korelasinya cenderung rendah (semakin besar bmi, tidak terlalu berpengaruh terhadap charges).\nSeperti cara sebelumnya, kita dapat menambahkan garis regresi. Namun, karena kita disini menggunakan hue, terdapat dua cara untuk menambahkan garis regresi, yaitu yang pertama adalah menggunakan sns.regplot() seperti di bawah ini.\n\nsns.regplot(data=insurance_df.query('smoker == \"yes\"'), x='bmi', y='charges') # axes 1\nsns.regplot(data=insurance_df.query('smoker == \"no\"'), x='bmi', y='charges') # axes 2\nplt.show()\n\n\n\n\nPerhatikan bahwa sns.regplot() dipanggil dua kali karena fungsi tersebut tidak memiliki parameter hue.\nUntuk mempermudah, kita dapat menggunakan cara kedua, yaitu menggunakan sns.lmplot(). Cara kerja sns.lmplot() yaitu menggabungkan dua (atau lebih) sns.regplot() dalam satu figur.\n\nsns.lmplot(data=insurance_df, x='bmi', y='charges', hue='smoker')\nplt.show()\n\n\n\n\n\n\nBox Plot dan Swarm Plot\nBox plot dan swarm plot biasa digunakan untuk melihat keterkaitan antara data kategorik dan data numerik. Swarm plot biasa disebut sebagai “categorical scatter plot”, karena plot yang dihasilkan mirip seperti scatter plot, tetapi untuk data kategorik.\nUntuk menggunakan box plot pada seaborn kita dapat menggunakan sns.boxplot().\nUntuk menggunakan swarm plot pada seaborn kita dapat menggunakan sns.swarmplot().\nMisal, kita ingin melihat keterkaitan antara fitur smoker dan charges menggunakan swarm plot. Maka, kita dapat menggunakan code seperti di bawah ini.\n\nplt.subplots(figsize=(10,6))\n\nsns.swarmplot(data=insurance_df, x='smoker', y='charges', size=3)\nplt.show()\n\n\n\n\nBerdasarkan swarm plot di atas, terlihat bahwa perokok cenderung memiliki biaya asuransi yang lebih tinggi dibandingkan yang bukan perokok. Selain itu, semakin lebar “swarm” pada suatu kategori berarti semakin banyak seseorang dengan nilai charges tersebut.\nApabila kita ingin menggunakan box plot, maka dapat digunakan code seperti di bawah ini.\n\nsns.boxplot(data=insurance_df, x='smoker', y='charges')\nplt.show()\n\n\n\n\nPada box plot, terdapat dua istilah yang umum digunakan, yaitu “box” dan “whiskers”. Pada box plot di atas, “box” merupakan persegi panjang berwarna biru dan orange. Garis di tengah box merupakan nilai mediannya, serta garis bawah dan garis atas box merupakan kuartil bawah (Q1) dan kuartil atas (Q3) secara berurutan. “Whiskers” adalah garis yang merupakan perpanjangan dari box. Ujung dari whiskers atas adalah Q3 + (1.5 x IQR) data, sedangkan ujung whiskers bawah adalah Q1 - (1.5 x IQR) data.\nTitik di luar box dan whiskers tersebut adalah titik yang biasa dijadikan sebagai outlier (penentuan outlier diserahkan ke diri masing-masing, apakah hanya dengan melihat box plot atau dengan menggunakan metode lain, tetapi untuk mempermudah dapat menggunakan box plot).\n\n\nHistogram dan Density Plot\nSelain box plot dan swarm plot, kita juga dapat melihat persebaran data menggunakan histogram dan density plot. Histogram biasa digunakan untuk melihat persebaran data secara diskrit, sedangkan density plot untuk melihat persebaran data secara kontinu.\nUntuk membuat histogram pada seaborn, kita dapat menggunakan sns.histplot().\nUntuk membuat density plot pada seaborn, kita dapat menggunakan sns.kdeplot().\nMisal, kita ingin melihat persebaran dari fitur charges pada insurance_df. Maka dapat digunakan code seperti di bawah.\n\nplt.subplots(figsize=(12,6))\n\nsns.histplot(data=insurance_df, x='charges')\nplt.show()\n\n\n\n\nBerdasarkan histogram di atas, terlihat bahwa distribusi charges cenderung “skew” atau miring ke kanan. “Skewness” atau tingkat kecondongan merupakan aspek yang penting untuk diperhatikan ketika kita ingin membuat model Machine Learning.\nSeperti scatter plot, kita juga dapat menentukan pewarnaan histogram berdasarkan fitur lainnya dengan menggunakan parameter hue seperti di bawah ini/\n\nplt.subplots(figsize=(12,6))\nsns.histplot(data=insurance_df, x='charges', hue='smoker')\nplt.show()\n\n\n\n\nJika ingin membuat density plot dari fitur charges, kita dapat menggunakan kode seperti di bawah ini. Parameter shade berfungsi untuk memberikan warna di bawah kurva.\n\nplt.subplots(figsize=(12,6))\nsns.kdeplot(data=insurance_df, x='charges', shade=True)\nplt.show()\n\n\n\n\nsns.kdeplot() juga dapat menggunakan parameter hue.\n\nplt.subplots(figsize=(12,6))\nsns.kdeplot(data=insurance_df, x='charges',\n            hue='smoker', shade=True)\nplt.show()\n\n\n\n\nApabila kita ingin menggabungkan histogram dan density plot dalam satu figur, kita dapat menggunakan sns.histplot() dengan parameter kde=True.\n\nplt.subplots(figsize=(12,6))\nsns.histplot(data=insurance_df, x='charges', hue='smoker', kde=True)\nplt.show()\n\n\n\n\n\n\nJoint Plot\nPada seaborn, kita juga dapat membuat dua plot yang berbeda dari dua fitur dalam satu figur yang sama menggunakan sns.jointplot().\nJenis plot yang dihasilkan dapat diatur pada parameter kind. Pilihan jenis kind yang disediakan dapat dilihat pada:\nhttps://seaborn.pydata.org/generated/seaborn.jointplot.html\n\nsns.jointplot(data=insurance_df, x='charges', y='bmi', hue='smoker', kind=\"scatter\")\n\nplt.show()\n\n\n\n\n\nsns.jointplot(data=insurance_df, x='charges', y='bmi', hue='smoker', kind=\"hist\")\n\nplt.show()\n\n\n\n\n\nsns.jointplot(data=insurance_df, x='charges', y='bmi', hue='smoker', kind=\"kde\")\n\nplt.show()"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul2.html#supplementary-panduan-pemilihan-plot",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul2.html#supplementary-panduan-pemilihan-plot",
    "title": "Modul 2 Sains Data: Visualisasi Data",
    "section": "Supplementary: Panduan Pemilihan Plot",
    "text": "Supplementary: Panduan Pemilihan Plot\n\n\n\nimage.png\n\n\nsource: https://www.kaggle.com/code/alexisbcook/choosing-plot-types-and-custom-styles"
  },
  {
    "objectID": "semuahalaman/praktikum.html",
    "href": "semuahalaman/praktikum.html",
    "title": "Praktikum",
    "section": "",
    "text": "Eksplorasi/EDA dan Visualisasi Data (Kurikulum 2020)\nKalkulus 2 & Aljabar Linier 1 (Kurikulum 2020)\nMetode Numerik (Kurikulum 2020)\nPersamaan Diferensial Numerik (Kurikulum 2020)\nSains Data (Kurikulum 2020)"
  },
  {
    "objectID": "semuahalaman/praktikum.html#semester-genap-februari-juni",
    "href": "semuahalaman/praktikum.html#semester-genap-februari-juni",
    "title": "Praktikum",
    "section": "",
    "text": "Eksplorasi/EDA dan Visualisasi Data (Kurikulum 2020)\nKalkulus 2 & Aljabar Linier 1 (Kurikulum 2020)\nMetode Numerik (Kurikulum 2020)\nPersamaan Diferensial Numerik (Kurikulum 2020)\nSains Data (Kurikulum 2020)"
  },
  {
    "objectID": "semuahalaman/praktikum.html#semester-ganjil-september-desember",
    "href": "semuahalaman/praktikum.html#semester-ganjil-september-desember",
    "title": "Praktikum",
    "section": "Semester Ganjil (September-Desember)",
    "text": "Semester Ganjil (September-Desember)\n\nStruktur Data, dengan Python (Kurikulum 2020)"
  },
  {
    "objectID": "semuahalaman/praktikum.html#semester-genap-februari-juni-1",
    "href": "semuahalaman/praktikum.html#semester-genap-februari-juni-1",
    "title": "Praktikum",
    "section": "Semester Genap (Februari-Juni)",
    "text": "Semester Genap (Februari-Juni)\n\nEksplorasi/EDA dan Visualisasi Data (Kurikulum 2020)\nMetode Numerik (Kurikulum 2020)\nPersamaan Diferensial Numerik (Kurikulum 2020)\nSains Data (Kurikulum 2020)"
  },
  {
    "objectID": "semuahalaman/praktikum.html#semester-ganjil-september-desember-1",
    "href": "semuahalaman/praktikum.html#semester-ganjil-september-desember-1",
    "title": "Praktikum",
    "section": "Semester Ganjil (September-Desember)",
    "text": "Semester Ganjil (September-Desember)\n\nStruktur Data (Kurikulum 2020) (modul belum tersedia)"
  },
  {
    "objectID": "semuahalaman/praktikum.html#semester-genap-februari-juni-2",
    "href": "semuahalaman/praktikum.html#semester-genap-februari-juni-2",
    "title": "Praktikum",
    "section": "Semester Genap (Februari-Juni)",
    "text": "Semester Genap (Februari-Juni)\n\nSains Data (Kurikulum 2020)"
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/saindat2022genap.html",
    "href": "semuahalaman/modulprak/2022/genap/saindat/saindat2022genap.html",
    "title": "Praktikum Saindat (Sains Data) 2022 Genap (Kurikulum 2020)",
    "section": "",
    "text": "Kembali ke Praktikum\nIni adalah versi website (yang baru dibuat setelah semester ini berakhir) dari modul yang ada di link berikut: https://drive.google.com/open?id=1x2SR_L3pWH0W8Z0IUbL1ifBOcMSkWVYe\n\nTimeline\n\nModul 1 (belum tersedia)\nModul 2\nModul 3 (belum tersedia)\nModul 4 (belum tersedia)\nModul 5 (belum tersedia)\nModul 6 (belum tersedia)\nModul 7 (belum tersedia)\nModul 8 (belum tersedia)\nModul 9 (belum tersedia)"
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/modul2.html",
    "href": "semuahalaman/modulprak/2022/genap/saindat/modul2.html",
    "title": "MODUL 2 PRAKTIKUM SAINS DATA",
    "section": "",
    "text": "Kembali ke Sains Data\n\n\n\nRegresi Linier Sederhana\nRegresi Linier Berganda"
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#import-module",
    "href": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#import-module",
    "title": "MODUL 2 PRAKTIKUM SAINS DATA",
    "section": "Import Module",
    "text": "Import Module\n\n#import module dan package yang diperlukan\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport pylab as pl\nimport numpy as np\n%matplotlib inline\n\nPada module kali ini, akan digunakan data csv Fuel Consumption of CO2 (FuelConsumptionCo2.csv) yang bisa didownload dari:\n\nKaggle"
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#import-data",
    "href": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#import-data",
    "title": "MODUL 2 PRAKTIKUM SAINS DATA",
    "section": "Import Data",
    "text": "Import Data\n\ndf = pd.read_csv('/content/FuelConsumptionCo2.csv')\n\n\n#lihat cuplikan data dari dataframe\ndf.head()\n\n\n  \n    \n\n\n\n\n\n\nMODELYEAR\nMAKE\nMODEL\nVEHICLECLASS\nENGINESIZE\nCYLINDERS\nTRANSMISSION\nFUELTYPE\nFUELCONSUMPTION_CITY\nFUELCONSUMPTION_HWY\nFUELCONSUMPTION_COMB\nFUELCONSUMPTION_COMB_MPG\nCO2EMISSIONS\n\n\n\n\n0\n2014\nACURA\nILX\nCOMPACT\n2.0\n4\nAS5\nZ\n9.9\n6.7\n8.5\n33\n196\n\n\n1\n2014\nACURA\nILX\nCOMPACT\n2.4\n4\nM6\nZ\n11.2\n7.7\n9.6\n29\n221\n\n\n2\n2014\nACURA\nILX HYBRID\nCOMPACT\n1.5\n4\nAV7\nZ\n6.0\n5.8\n5.9\n48\n136\n\n\n3\n2014\nACURA\nMDX 4WD\nSUV - SMALL\n3.5\n6\nAS6\nZ\n12.7\n9.1\n11.1\n25\n255\n\n\n4\n2014\nACURA\nRDX AWD\nSUV - SMALL\n3.5\n6\nAS6\nZ\n12.1\n8.7\n10.6\n27\n244\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nKali ini kita akan membuat model regresi linear untuk memprediksi nilai dari CO2EMISSION"
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#eksplorasi-data",
    "href": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#eksplorasi-data",
    "title": "MODUL 2 PRAKTIKUM SAINS DATA",
    "section": "Eksplorasi Data",
    "text": "Eksplorasi Data\nStatistik deskriptif dari data frame\n\ndf.describe()\n\n\n  \n    \n\n\n\n\n\n\nMODELYEAR\nENGINESIZE\nCYLINDERS\nFUELCONSUMPTION_CITY\nFUELCONSUMPTION_HWY\nFUELCONSUMPTION_COMB\nFUELCONSUMPTION_COMB_MPG\nCO2EMISSIONS\n\n\n\n\ncount\n1067.0\n1067.000000\n1067.000000\n1067.000000\n1067.000000\n1067.000000\n1067.000000\n1067.000000\n\n\nmean\n2014.0\n3.346298\n5.794752\n13.296532\n9.474602\n11.580881\n26.441425\n256.228679\n\n\nstd\n0.0\n1.415895\n1.797447\n4.101253\n2.794510\n3.485595\n7.468702\n63.372304\n\n\nmin\n2014.0\n1.000000\n3.000000\n4.600000\n4.900000\n4.700000\n11.000000\n108.000000\n\n\n25%\n2014.0\n2.000000\n4.000000\n10.250000\n7.500000\n9.000000\n21.000000\n207.000000\n\n\n50%\n2014.0\n3.400000\n6.000000\n12.600000\n8.800000\n10.900000\n26.000000\n251.000000\n\n\n75%\n2014.0\n4.300000\n8.000000\n15.550000\n10.850000\n13.350000\n31.000000\n294.000000\n\n\nmax\n2014.0\n8.400000\n12.000000\n30.200000\n20.500000\n25.800000\n60.000000\n488.000000\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nKita dapat memilih beberapa feature/kolom yang kita duga berpengaruh terhadap nilai dari CO2EMISSION\n\n #definisikan dataframe baru bernama cdf\ncdf = df[['ENGINESIZE', 'CYLINDERS', 'FUELCONSUMPTION_COMB', 'CO2EMISSIONS']]\ncdf.head(9)\n\n\n  \n    \n\n\n\n\n\n\nENGINESIZE\nCYLINDERS\nFUELCONSUMPTION_COMB\nCO2EMISSIONS\n\n\n\n\n0\n2.0\n4\n8.5\n196\n\n\n1\n2.4\n4\n9.6\n221\n\n\n2\n1.5\n4\n5.9\n136\n\n\n3\n3.5\n6\n11.1\n255\n\n\n4\n3.5\n6\n10.6\n244\n\n\n5\n3.5\n6\n10.0\n230\n\n\n6\n3.5\n6\n10.1\n232\n\n\n7\n3.7\n6\n11.1\n255\n\n\n8\n3.7\n6\n11.6\n267\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nMari visualisasikan sebaran datanya menggunakan histogram\n\n#membuat histogram\nviz = cdf[['CYLINDERS', 'ENGINESIZE', 'CO2EMISSIONS', 'FUELCONSUMPTION_COMB']]\nviz.hist()\nplt.show()\n\n\n\n\n\n\n\n\nSelanjutnya, kita akan melihat hubungan antara ketiga kolom/feature dengan CO2Emission menggunakan scatter plot.\n\n#scatter plot untuk fuelconsumption_comb\nplt.scatter(cdf.FUELCONSUMPTION_COMB, cdf.CO2EMISSIONS, color = 'blue')\nplt.xlabel(\"FUELCONSUMPTION_COMB\")\nplt.ylabel(\"Emission\")\nplt.show()\n\n\n\n\n\n\n\n\n\n#scatter plot untuk enginesize\nplt.scatter(cdf.ENGINESIZE, cdf.CO2EMISSIONS, color = 'blue')\nplt.xlabel(\"Engine Size\")\nplt.ylabel(\"Emission\")\nplt.show()\n\n\n\n\n\n\n\n\n\n #scatter plot untuk cylinders\nplt.scatter(cdf.CYLINDERS, cdf.CO2EMISSIONS, color = 'red')\nplt.xlabel(\"Cylinders\")\nplt.ylabel(\"Emission\")\nplt.show()\n\n\n\n\n\n\n\n\n\ndari ketiga visualisasi diatas, scatter plot Engine Size dan Fuel Consumption terlihat menarik untuk diteliti lebih jauh. Langkah selanjutnya kita akan membuat model untuk memprediksi Emisi CO2 (CO2 Emission) berdasarkan Ukuran Mesin (Engine Size) dan model untuk memprediksi Emisi CO2 (CO2 Emission) berdasarkan Konsumsi Bahan Bakar (Fuel Consumption)"
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#train-test-set",
    "href": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#train-test-set",
    "title": "MODUL 2 PRAKTIKUM SAINS DATA",
    "section": "Train-Test Set",
    "text": "Train-Test Set\nPertama tama, kita bagi data yang kita punya sebagai data latih (untuk melatih model) dan data uji (untuk menguji model).\nData uji diperlukan agar kita dapat melihat akurasi dari model yang telah dibuat.\nData latih dan data uji harus bersifat saling lepas (tidak memiliki irisan) agar memberikan gambaran peforma model terhadap data baru\n\n#memisahkan data train dan test dengan perbandingan 8:2\nmsk = np.random.rand(len(df)) &lt; 0.8\ntrain = cdf[msk]\ntest = cdf[~msk]"
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#regresi-linear-sederhana-engine-size-vs.-co2-emissions",
    "href": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#regresi-linear-sederhana-engine-size-vs.-co2-emissions",
    "title": "MODUL 2 PRAKTIKUM SAINS DATA",
    "section": "Regresi Linear Sederhana (Engine Size vs. CO2 Emissions)",
    "text": "Regresi Linear Sederhana (Engine Size vs. CO2 Emissions)\n\n #scatter plot dari data latih\nplt.scatter(train.ENGINESIZE, train.CO2EMISSIONS, color = 'blue')\nplt.xlabel(\"Engine Size\")\nplt.ylabel(\"Emission\")\nplt.show()"
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#membuat-model",
    "href": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#membuat-model",
    "title": "MODUL 2 PRAKTIKUM SAINS DATA",
    "section": "Membuat model",
    "text": "Membuat model\nUntuk membuat model, kita akan menggunakan LinearRegression dari package sklearn\n\n#import package sklearn dan modul linear_model\nfrom sklearn import linear_model\n#definisikan model regresi linier dengan nama 'regr'\nregr = linear_model.LinearRegression()\n#definisikan fitur/kolom yang akan di-fit kedalam model\ntrain_x = np.asanyarray(train[['ENGINESIZE']])\ntrain_y = np.asanyarray(train[['CO2EMISSIONS']])\n#fit data training ke model regr\nregr.fit(train_x, train_y)\n#output koefisien dan intersepnya\nprint('Coefficients: ', regr.coef_)\nprint('y-Intercept: ', regr.intercept_)\n\nCoefficients:  [[38.54948831]]\ny-Intercept:  [126.65891652]\n\n\nsehingga diperoleh fungsi: \\(y = 38.549x+126.658\\)\nSelanjutnya, kita dapat visualisasikan fungsi diatas beserta scatter plot dari data latih.\n\nplt.scatter(train.ENGINESIZE, train.CO2EMISSIONS, color = 'blue')\n#visualisasi fungsi yang diperoleh\nplt.plot(train_x, regr.coef_[0][0]*train_x + regr.intercept_[0], '-r')\nplt.xlabel(\"Engine Size\")\nplt.ylabel(\"Emission\")\nplt.show()"
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#evaluasi-model",
    "href": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#evaluasi-model",
    "title": "MODUL 2 PRAKTIKUM SAINS DATA",
    "section": "Evaluasi Model",
    "text": "Evaluasi Model\nTahap terakhir adalah membandingkan nilai aktual (nilai y yang ada pada data test) dengan nilai prediksi (nilai y setelah x test disubstitusikan ke fungsi yang telah diperoleh) Selisih nilai aktual dan prediksi disebut error.\nBeberapa metriks/ukuran yang dapat digunakan utk evaluasi model: - Mean Absolute Error: Mean dari mutlak dari error. Paling mudah dipahami, sebab berupa kesalahan rata-rata. - Mean Squared Error (MSE): Rata-rata dari error kuadrat. Lebih populer daripada MAE karena fokusnya lebih diarahkan pada kesalahan besar. Ini karena suku kuadrat secara eksponensial meningkatkan kesalahan yang lebih besar dibandingkan dengan kesalahan yang lebih kecil. - Root Mean Squared Error (RMSE): akar dari MSE. - R-square (R-2) : metrik populer untuk mengukur kinerja model regresi. Mewakili seberapa dekat titik data dengan garis regresi yang dipasang. Semakin tinggi nilai R-2, semakin baik model tersebut sesuai dengan data. Skor terbaik adalah 1.0 dan bisa juga bernilai negatif.\n\n#gunakan package sklearn.metrics utk melihat evaluasi model\nfrom sklearn.metrics import r2_score\ntest_x = np.asanyarray(test[['ENGINESIZE']])\ntest_y = np.asanyarray(test[['CO2EMISSIONS']])\ntest_y_ = regr.predict(test_x)\nprint(\"Mean absolute error: %.2f\" % np.mean(np.absolute(test_y_ - test_y)))\nprint(\"Residual sum of squares (MSE): %.2f\" % np.mean((test_y_ - test_y) ** 2))\nprint(\"R2-score: %.2f\" % r2_score(test_y, test_y_))\n\nMean absolute error: 24.75\nResidual sum of squares (MSE): 1133.59\nR2-score: 0.76"
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#regression-fuel-consumption-vs.-co2-emission",
    "href": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#regression-fuel-consumption-vs.-co2-emission",
    "title": "MODUL 2 PRAKTIKUM SAINS DATA",
    "section": "Regression (Fuel Consumption vs. CO2 Emission)",
    "text": "Regression (Fuel Consumption vs. CO2 Emission)\n\nplt.scatter(train.FUELCONSUMPTION_COMB, train.CO2EMISSIONS, color = 'red')\nplt.xlabel(\"Fuel Consumption\")\nplt.ylabel(\"Emission\")\nplt.show()\n\n\n\n\n\n\n\n\n\nregr = linear_model.LinearRegression()\ntrain_x = np.asanyarray(train[['FUELCONSUMPTION_COMB']])\ntrain_y = np.asanyarray(train[['CO2EMISSIONS']])\nregr.fit(train_x, train_y)\nprint('Coefficients: ', regr.coef_)\nprint('y-Intercept: ', regr.intercept_)\n\nCoefficients:  [[15.99115452]]\ny-Intercept:  [71.06166585]\n\n\nsehingga diperoleh fungsi: \\(y = 15.991x+71.061\\)\n\nplt.scatter(train.FUELCONSUMPTION_COMB, train.CO2EMISSIONS, color = 'red')\nplt.plot(train_x, regr.coef_[0][0]*train_x + regr.intercept_[0], '-k')\nplt.xlabel(\"Fuel Consumption\")\nplt.ylabel(\"Emission\")\nplt.show()\n\n\n\n\n\n\n\n\n\ntest_x = np.asanyarray(test[['FUELCONSUMPTION_COMB']])\ntest_y = np.asanyarray(test[['CO2EMISSIONS']])\ntest_y_ = regr.predict(test_x)\nprint(\"Mean absolute error: %.2f\" % np.mean(np.absolute(test_y_ - test_y)))\nprint(\"Residual sum of squares (MSE): %.2f\" % np.mean((test_y_ - test_y) ** 2))\nprint(\"R2-score: %.2f\" % r2_score(test_y, test_y_))\n\nMean absolute error: 21.10\nResidual sum of squares (MSE): 849.92\nR2-score: 0.82\n\n\n\nBerdasarkan perbandingan MAE, MSE dan R2-scorenya dapat disimpulkan bahwa model regresi linier Fuel Consumption vs. CO2 Emission lebih baik dari model regresi linier Engine Size vs. CO2 Emission."
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#traintest-set",
    "href": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#traintest-set",
    "title": "MODUL 2 PRAKTIKUM SAINS DATA",
    "section": "Train/Test Set",
    "text": "Train/Test Set\n\n#memisah data uji dan data latih dgn perbandingan 8:2\nmsk = np.random.rand(len(df)) &lt; 0.8\ntrain = cdf[msk]\ntest = cdf[~msk]\n\n\n#membuat model\nregr = linear_model.LinearRegression()\n#perhatikan pada x, dipilih beberapa feature/kolom sebagai variabel bebasnya. kali ini akan dibuat model\n#berdasarkan ukuran mesin, banyak tabung, dan konsumsi bahan bakar\nx = np.asanyarray(train[['ENGINESIZE', 'CYLINDERS', 'FUELCONSUMPTION_COMB']])\ny = np.asanyarray(train[['CO2EMISSIONS']])\nregr.fit(x, y)\nprint('Coefficients: ', regr.coef_)\nprint('Intercept: ', regr.intercept_)\n\nCoefficients:  [[10.77193129  7.70821711  9.51766547]]\nIntercept:  [64.90866441]\n\n\n\\(y=10.771x_1 + 7.708x_2 + 9.517x_3 + 64.908\\)"
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#evaluasi-model-1",
    "href": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#evaluasi-model-1",
    "title": "MODUL 2 PRAKTIKUM SAINS DATA",
    "section": "Evaluasi Model",
    "text": "Evaluasi Model\nExplained Variance: Misal ŷ adalah prediksi, y adalah nilai aktual, dan Var adalah Varians (kuadrat dari standar deviasi).\n\\(\\text{explainedVariance} (y,ŷ) = 1-\\frac{\\text{Var }y-ŷ}{\\text{Var }y}\\)\nSkor terbaik adalah 1. Semakin rendah berarti kinerja model lebih buruk.\nResidual Sum of Square (RSS): Sum dari error kuadrat. Semakin tinggi nialinya, maka kinerja model lebih buruk.\n\n#evaluasi fungsi diatas\nx = np.asanyarray(test[['ENGINESIZE', 'CYLINDERS', 'FUELCONSUMPTION_COMB']])\ny = np.asanyarray(test[['CO2EMISSIONS']])\ny_hat = regr.predict(test[['ENGINESIZE', 'CYLINDERS', 'FUELCONSUMPTION_COMB']])\nprint(\"Residual sum of squares: %.2f\" % np.mean((y_hat - y) ** 2))\nprint(\"Variance score: %.2f\" % regr.score(x, y))\n\nResidual sum of squares: 462.42\nVariance score: 0.88\n\n\n/usr/local/lib/python3.10/dist-packages/sklearn/base.py:432: UserWarning: X has feature names, but LinearRegression was fitted without feature names\n  warnings.warn("
  },
  {
    "objectID": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#membuat-model-pembanding",
    "href": "semuahalaman/modulprak/2022/genap/saindat/modul2.html#membuat-model-pembanding",
    "title": "MODUL 2 PRAKTIKUM SAINS DATA",
    "section": "Membuat Model Pembanding",
    "text": "Membuat Model Pembanding\n‘FUELCONSUMPTION_COMB’ digantikan dengan ‘FUELCONSUMPTION_CITY’, ‘FUELCONSUMPTION_HWY’\n\nregr = linear_model.LinearRegression()\n#perhatikan pada x, dipilih beberapa feature/kolom sebagai variabel bebasnya. kali ini akan dibuat model\n#berdasarkan ukuran mesin, banyak tabung, konsumsi bahan bakar dalam kota dan konsumsi bahan bakar luar kota\nx = np.asanyarray(train[['ENGINESIZE', 'CYLINDERS', 'FUELCONSUMPTION_CITY', 'FUELCONSUMPTION_HWY']])\ny = np.asanyarray(train[['CO2EMISSIONS']])\nregr.fit(x, y)\nprint('Coefficients: ', regr.coef_)\nprint('Intercept: ', regr.intercept_)\n\nCoefficients:  [[10.89417412  7.24796498  6.44569745  2.65762343]]\nIntercept:  [66.53100166]\n\n\n\\(y=10.894x_1 + 7.247x_2 + 6.445x_3 + 2.657x_4 + 66.531\\)\n\n#evaluasi model diatas\nx = np.asanyarray(test[['ENGINESIZE', 'CYLINDERS', 'FUELCONSUMPTION_CITY', 'FUELCONSUMPTION_HWY']])\ny = np.asanyarray(test[['CO2EMISSIONS']])\ny_hat = regr.predict(test[['ENGINESIZE', 'CYLINDERS', 'FUELCONSUMPTION_CITY', 'FUELCONSUMPTION_HWY']])\nprint(\"Residual sum of squares: %.2f\" % np.mean((y_hat - y) ** 2))\nprint(\"Variance score: %.2f\" % regr.score(x, y))\n\nResidual sum of squares: 465.14\nVariance score: 0.88\n\n\n/usr/local/lib/python3.10/dist-packages/sklearn/base.py:432: UserWarning: X has feature names, but LinearRegression was fitted without feature names\n  warnings.warn(\n\n\n\nBerdasarkan Residual sum of square (RSS) dari kedua model, terlihat bahwa model regresi \\[y=10.894x_1 + 7.247x_2 + 6.445x_3 + 2.657x_4 + 66.531\\] memiliki performa sedikit lebih baik dibandingkan dengan model regresi \\[y=10.771x_1 + 7.708x_2 + 9.517x_3 + 64.908\\]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Lab Praktikum Departemen Matematika FMIPA UI",
    "section": "",
    "text": "Langsung pencet Praktikum aja yaa!\nThis is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "semuahalaman/about.html",
    "href": "semuahalaman/about.html",
    "title": "About",
    "section": "",
    "text": "Langsung pencet Praktikum aja yaa!\nAbout this site"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul2.html",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul2.html",
    "title": "Modul 2 Persamaan Diferensial Numerik",
    "section": "",
    "text": "Kembali ke Persamaan Diferensial Numerik"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul2.html#metode-euler",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul2.html#metode-euler",
    "title": "Modul 2 Persamaan Diferensial Numerik",
    "section": "Metode Euler",
    "text": "Metode Euler\nMetode Euler adalah metode paling dasar dalam mencari solusi dari permasalahan nilai awal dari suatu PD.\nMisalkan kita mempunyai suatu persamaan diferensial dengan nilai awal:\n\\[y^{\\prime}=f(t, y), a \\leq t \\leq b\\] \\[y(a)=\\alpha\\]\nmaka solusi secara numeriknya adalah \\(w_i= y(t_i)\\), dengan:\n\\[w_1=\\alpha\\] \\[w_{i+1}=w_i+h f\\left(t_i, w_i\\right), \\quad i=1,2, \\ldots, N\\]\ndengan \\(N+1\\in \\mathbb{N}\\) menyatakan banyaknya titik nantinya.\nSolusi kita akan berupa titik yang nantinya dapat menggunakan interpolasi untuk nilai yang tidak dimuat di \\(w_i\\)\nMetode Euler juga bisa ditulis:\n\\[w_1=\\alpha\\]\ndiikuti iterasi untuk \\(i=1,2, \\ldots, N\\),\n\\[m_1 = f\\left(t_i, w_i\\right)\\] \\[w_{i+1}=w_i+h m_1\\]\nMetode Euler membutuhkan\n\nfungsi \\(f\\left(t,y\\right)\\) dalam MNA \\(y' = f\\left(t,y\\right)\\)\ninterval \\([a,b]\\)\nniali \\(N\\), agar digunakan \\(N+1\\) titik, yaitu sebagai pembagi dalam perhitungan step size \\(h = \\frac{b-a}{N}\\)\n\\(\\alpha\\) (alpha) sebagai nilai awal dalam \\(y(a) = \\alpha\\)\n\nsehingga programnya (fungsi metode Euler) bisa ditulis sebagai berikut:\n\nfunction [t, w] = euler(f, a, b, N, alpha)\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1 : N\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    w(i + 1) = w(i) + h * m1;\n  endfor\nendfunction\n\nSekarang akan kita coba gunakan untuk menyelesaikan suatu MNA (masalah nilai awal) PDB orde 1. Misal diberikan MNA sebagai berikut:\n\\[y^{\\prime}=y-t^2+1\\] \\[0 \\leq t \\leq 2\\] \\[y(0)=0.5\\]\nmaka kita dapat mendefinisikan\n\nf = @(t, y) y-t^2+1,\na=0,\nb=2, dan\nalpha \\(=0.5\\)\n\nsehingga untuk \\(N=10\\), diperoleh kode dan hasil sebagai berikut:\n\nf = @(t, y) (y-t^2 + 1);\na = 0;\nb = 2;\nN = 10;\nalpha= 0.5;\n[t_euler, w_euler] = euler(f, a, b, N, alpha);\n\n\n[t_euler, w_euler]\n\nans =\n\n        0   0.5000\n   0.2000   0.8000\n   0.4000   1.1520\n   0.6000   1.5504\n   0.8000   1.9885\n   1.0000   2.4582\n   1.2000   2.9498\n   1.4000   3.4518\n   1.6000   3.9501\n   1.8000   4.4282\n   2.0000   4.8658\n\n\n\nSebenarnya, MNA tersebut bisa dihitung solusi eksaknya, yaitu\n\\[y(t)=(t+1)^2- 0.5 e^t\\]\nsehingga kita bisa menghitung error metode Euler:\n\nTulis fungsi solusi eksak sebagai anonymous function\nTerapkan fungsi tersebut pada array t untuk memperoleh array y (yaitu nilai solusi eksak pada tiap nilai t)\nHitung mutlak dari selisih antara array w (hasil aproksimasi metode Euler) dengan array y, untuk memperoleh array baru yaitu error metode Euler\n\n\nsln = @(t) (t + 1).^2 - 0.5 * exp(t);\ny_eksak = sln(t_euler);\nerr_euler = abs(y_eksak - w_euler);\n\nSekarang, kita bisa menampilkan empat kolom berdampingan (membentuk tabel): nilai t, nilai w, nilai y (eksak), dan error.\n\n[t_euler, w_euler, y_eksak, err_euler]\n\nans =\n\n        0   0.5000   0.5000        0\n   0.2000   0.8000   0.8293   0.0293\n   0.4000   1.1520   1.2141   0.0621\n   0.6000   1.5504   1.6489   0.0985\n   0.8000   1.9885   2.1272   0.1387\n   1.0000   2.4582   2.6409   0.1827\n   1.2000   2.9498   3.1799   0.2301\n   1.4000   3.4518   3.7324   0.2806\n   1.6000   3.9501   4.2835   0.3334\n   1.8000   4.4282   4.8152   0.3870\n   2.0000   4.8658   5.3055   0.4397\n\n\n\nUntuk visualisasinya, kita akan membuat plot dari hasil yang kita peroleh.\nKita tambahkan kode berikut pada file, untuk membandingkan plot solusi eksak dengan plot dari titik-titik hasil algoritma.\n\nhold on;\nfplot(sln, [0, 2], 'b');\nscatter(t_euler, w_euler, 'r');\nlegend('Solusi eksak', 'Metode Euler');\ntitle(\"Metode Euler\");\n\n\n\n\nSaat dijalankan, akan muncul jendela pop-up yang berisi plot yang telah dibuat.\n\nPenjelasan:\n\nsln berisi fungsi referensi kita untuk di-plot dan dibandingkan.\nfplot(f, [a, b]) akan menampilkan plot dari suatu fungsi f dengan domain [a, b]. Argumen tambahan ‘b’ memberi warna biru pada plot.\nhold on akan menahan plot yang ada agar kita bisa menampilkan banyak plot sekaligus.\nscatter(x, y) akan menampilkan x-y scatter plot.\nlegend memberi legenda/keterangan pada plot yang telah dibuat. Legenda tersebut dimasukkan berurutan mulai dari plot yang didefinsikan terlebih dahulu\ntitle memberi judul pada plot\n\nSecara keseluruhan, kodenya menjadi seperti berikut.\n\n% setup\nf = @(t, y) (y-t^2 + 1);\na = 0;\nb = 2;\nN = 10;\nalpha= 0.5;\n\n% hitung metode Euler\n[t_euler, w_euler] = euler(f, a, b, N, alpha);\n\n% solusi eksak\nsln = @(t) (t + 1).^2 - 0.5 * exp(t);\ny_eksak = sln(t_euler); % hitung solusi eksak di tiap titik t\n\n% error: nilai mutlak dari selisih\nerr_euler = abs(y_eksak - w_euler);\n\n% tampilkan sejumlah kolom menjadi seperti tabel\n[t_euler, w_euler, y_eksak, err_euler]\n\n% plotting\nhold on;\nfplot(sln, [0, 2], 'b');\nscatter(t_euler, w_euler, 'r');\nlegend('Solusi eksak', 'Metode Euler');\ntitle(\"Metode Euler\");\n\nans =\n\n        0   0.5000   0.5000        0\n   0.2000   0.8000   0.8293   0.0293\n   0.4000   1.1520   1.2141   0.0621\n   0.6000   1.5504   1.6489   0.0985\n   0.8000   1.9885   2.1272   0.1387\n   1.0000   2.4582   2.6409   0.1827\n   1.2000   2.9498   3.1799   0.2301\n   1.4000   3.4518   3.7324   0.2806\n   1.6000   3.9501   4.2835   0.3334\n   1.8000   4.4282   4.8152   0.3870\n   2.0000   4.8658   5.3055   0.4397"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul2.html#metode-taylor-orde-n",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul2.html#metode-taylor-orde-n",
    "title": "Modul 2 Persamaan Diferensial Numerik",
    "section": "Metode Taylor orde \\(n\\)",
    "text": "Metode Taylor orde \\(n\\)\nMetode Taylor orde \\(n\\) adalah perluasan dari metode Euler (di mana metode Taylor orde 1 sama saja dengan metode Euler). Rumus iterasinya bisa ditulis sebagai berikut:\n\\[w_1 = \\alpha\\]\n\\[\\begin{align*}\nT^{(n)} \\left(t_i, w_i\\right) &= f\\left(t_i, w_i\\right) + \\frac{h}{2}f'\\left(t_i, w_i\\right) + \\cdots + \\frac{h^{n-1}}{n!} f^{\\left(n-1\\right)} \\left(t_i,w_i\\right) \\\\\n\\end{align*}\\]\n\\[w_{i+1} = w_i + hT^{(n)} \\left(t_i, w_i\\right) \\]\nPerhatikan bahwa, dengan metode Taylor orde \\(n\\), kita perlu memperoleh terlebih dahulu rumus analitik untuk sejumlah turunan (terhadap \\(t\\)) dari \\(f\\left(t_i, w_i\\right)\\) yaitu \\(f', f'', \\dots, f^{(n-1)}\\).\nKebetulan, untuk metode Euler, yaitu metode Taylor orde 1 (\\(n=1\\)), kita tidak perlu menghitung turunan fungsinya sama sekali.\nUntuk mempermudah pemrograman, kita coba tulis ulang rumus \\(T^{(n)} \\left(t_i, w_i\\right)\\) dengan sumasi:\n\\[\\begin{align*}\nT^{(n)} \\left(t_i, w_i\\right) &= f\\left(t_i, w_i\\right) + \\frac{h}{2}f'\\left(t_i, w_i\\right) + \\cdots + \\frac{h^{n-1}}{n!} f^{\\left(n-1\\right)} \\left(t_i,w_i\\right) \\\\\n&= \\sum_{j=1}^{n} \\frac{h^{j-1}}{j!} f^{\\left(j-1\\right)} \\left(t_i,w_i\\right) \\\\\n&= f\\left(t_i,w_i\\right) + \\sum_{j=2}^{n} \\frac{h^{j-1}}{j!} f^{\\left(j-1\\right)} \\left(t_i,w_i\\right)\n\\end{align*}\\]\nDengan demikian, kita bisa menyimpan fungsi-fungsi \\(f', f'', \\dots, f^{(n-1)}\\) di dalam suatu cell array, misal dinamakan fp, sehingga\n\nkita bisa mengakses turunan ke-\\(i\\) dengan menulis fp{i}\norde \\(n\\) untuk metode Taylor bisa ditentukan menggunakan panjang cell array tersebut, yaitu n = length(fp) + 1;\njika cell array kosong (tidak ada fungsi turunan), otomatis \\(n=1\\) dan algoritmanya menjadi sama saja dengan metode Euler (sesuai harapan)\npenjumlahannya bisa menggunakan for loop sederhana\nkita cukup mendefinisikan fungsi metode Taylor ini sekali saja di Octave, daripada harus membuat definisi terpisah untuk orde 2, orde 3, orde 4, dan seterusnya (di mana banyaknya fungsi turunan memang berbeda)\n\nSetelah manipulasi tersebut, secara keseluruhan, metode Taylor orde \\(n\\) bisa ditulis:\n\\[w_1 = \\alpha\\]\n\\[\\begin{align*}\nT^{(n)} \\left(t_i, w_i\\right) &= f\\left(t_i, w_i\\right) + \\frac{h}{2}f'\\left(t_i, w_i\\right) + \\cdots + \\frac{h^{n-1}}{n!} f^{\\left(n-1\\right)} \\left(t_i,w_i\\right) \\\\\n&= \\sum_{j=1}^{n} \\frac{h^{j-1}}{j!} f^{\\left(j-1\\right)} \\left(t_i,w_i\\right) \\\\\n&= f\\left(t_i,w_i\\right) + \\sum_{j=2}^{n} \\frac{h^{j-1}}{j!} f^{\\left(j-1\\right)} \\left(t_i,w_i\\right)\n\\end{align*}\\]\n\\[w_{i+1} = w_i + hT^{(n)} \\left(t_i, w_i\\right) \\]\nAtau lebih singkatnya:\n\\[w_1 = \\alpha\\]\n\\[T^{(n)} \\left(t_i, w_i\\right) = f\\left(t_i,w_i\\right) + \\sum_{j=2}^{n} \\frac{h^{j-1}}{j!} f^{\\left(j-1\\right)} \\left(t_i,w_i\\right)\\]\n\\[w_{i+1} = w_i + hT^{(n)} \\left(t_i, w_i\\right) \\]\n\nfunction [t, w] = taylor(f, fp, a, b, N, alpha)\n  h = (b - a) / N;\n  n = length(fp) + 1;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1 : N\n    t(i + 1) = t(i) + h;\n    \n    T = f(t(i), w(i));\n    for j = 2 : n\n      T += h^(j-1) * fp{j-1}(t(i),w(i)) / factorial(j);\n    endfor\n    \n    w(i + 1) = w(i) + h * T;\n  endfor\nendfunction\n\nContoh penggunaan:\nMisalkan diberikan MNA sebagai berikut, yang diminta untuk diselesaikan secara numerik dengan metode Taylor orde 4:\n\\[y' = y - t^2 + 1\\] \\[0 \\le t \\le 2\\] \\[y(0) = 0.5\\]\nMaka, dengan \\(y' = f\\left(t, y\\right) = y - t^2 + 1\\), bisa dihitung:\n\\[f'\\left(t, y\\right) = y - t^2 + 1 - 2t\\]\n\\[f''\\left(t, y\\right) = y - t^2 - 2t - 1\\]\n\\[f^{(3)}\\left(t, y\\right) = y - t^2 - 2t - 1, \\hspace{0.2cm} \\text{kebetulan sama persis dengan} \\hspace{0.2cm} f''\\left(t, y\\right)\\]\n\n% contoh pakai: subbab 5.3 example 1b (orde 4)\n\n% f(t_i, w_i)\nf0 = @(t,y) y - t^2 + 1;\n\n% f'(t_i, w_i)\nf1 = @(t,y) y - t^2 + 1 - 2*t;\n\n% f''(t_i, w_i)\nf2 = @(t,y) y - t^2 - 2*t - 1;\n\n% f'''(t_i, w_i)\nf3 = @(t,y) y - t^2 - 2*t - 1;\n\n% hitung pada interval [0,2], N=10, y(0)=alpha=0.5\n[t, w] = taylor(f0, {f1, f2, f3}, 0, 2, 10, 0.5);\n% otomatis Taylor orde 4 karena\n% ada tiga fungsi turunan f1, f2, f3\n% yang diinput di cell array\n\n% bandingkan dengan Tabel 5.4\n[t, w]\n\nans =\n\n        0   0.5000\n   0.2000   0.8293\n   0.4000   1.2141\n   0.6000   1.6489\n   0.8000   2.1272\n   1.0000   2.6409\n   1.2000   3.1800\n   1.4000   3.7324\n   1.6000   4.2835\n   1.8000   4.8152\n   2.0000   5.3056\n\n\n\nKita bisa membandingkan antara solusi eksak, metode Euler, dan metode Taylor orde 4, baik dalam menampilkan tabel iterasi maupun menampilkan plot:\n\n% fungsi f(t,y) dan turunan pertama, kedua, ketiga\nf0 = @(t,y) y - t^2 + 1;\nf1 = @(t,y) y - t^2 + 1 - 2*t;\nf2 = @(t,y) y - t^2 - 2*t - 1;\nf3 = @(t,y) y - t^2 - 2*t - 1;\n\na = 0;\nb = 2;\nN = 10;\nalpha = 0.5;\n\n% menghitung metode Euler dan metode Taylor orde 4\n[t_euler, w_euler] = euler(f0, a, b, N, alpha);\n[t_taylor, w_taylor] = taylor(f0, {f1,f2,f3}, a, b, N, alpha);\n\n% solusi eksak\nsln = @(t) (t + 1).^2 - 0.5 * exp(t);\ny_eksak = sln(t_euler);\n\n% tampilkan tabel\n[t_euler, w_euler, w_taylor, y_eksak]\n\n% plotting\nhold on;\nfplot(sln, [0,2], 'b');\nscatter(t_euler, w_euler, 'r');\nscatter(t_taylor, w_taylor, 'g');\nlegend(\"Solusi Eksak\", \"Metode Euler\", \"Metode Taylor\");\n\nans =\n\n        0   0.5000   0.5000   0.5000\n   0.2000   0.8000   0.8293   0.8293\n   0.4000   1.1520   1.2141   1.2141\n   0.6000   1.5504   1.6489   1.6489\n   0.8000   1.9885   2.1272   2.1272\n   1.0000   2.4582   2.6409   2.6409\n   1.2000   2.9498   3.1800   3.1799\n   1.4000   3.4518   3.7324   3.7324\n   1.6000   3.9501   4.2835   4.2835\n   1.8000   4.4282   4.8152   4.8152\n   2.0000   4.8658   5.3056   5.3055"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul2.html#metode-runge-kutta-dan-variasinya",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul2.html#metode-runge-kutta-dan-variasinya",
    "title": "Modul 2 Persamaan Diferensial Numerik",
    "section": "Metode Runge-Kutta dan variasinya",
    "text": "Metode Runge-Kutta dan variasinya\n\nOrde 2: Metode Midpoint\n\\[w_1=\\alpha\\] \\[w_{i+1}=w_i+h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{h}{2} f\\left(t_i, w_i\\right)\\right)\\]\nbisa juga ditulis,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[w_{i+1}=w_i+h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{h}{2} m_1\\right)\\]\natau bahkan,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[m_2 = f\\left(t_i+\\frac{h}{2}, w_i+\\frac{h}{2} m_1\\right)\\] \\[w_{i+1}=w_i+h m_2\\]\n\nfunction [t, w] = midpoint(f, a, b, N, alpha)\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1 : N\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i) + (h / 2), w(i) + (h / 2) * m1);\n    w(i + 1) = w(i) + h * m2;\n  endfor\nendfunction\n\n\n\nOrde 2: Metode Modified Euler\n\\[w_1=\\alpha\\] \\[w_{i+1}=w_i+\\frac{h}{2}\\left(f\\left(t_i, w_i\\right)+f\\left(t_{i+1}, w_i+h f\\left(t_i, w_i\\right)\\right)\\right)\\]\nbisa juga ditulis,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[w_{i+1}=w_i+\\frac{h}{2}\\left(m_1+f\\left(t_{i+1}, w_i+h m_1\\right)\\right)\\]\natau bahkan,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[m_2 = f\\left(t_{i+1}, w_i+h m_1\\right)\\] \\[w_{i+1}=w_i+\\frac{h}{2}\\left(m_1+m_2\\right)\\]\n\nfunction [t, w] = modified_euler(f, a, b, N, alpha)\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1 : N\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i + 1), w(i) + h * m1);\n    w(i + 1) = w(i) + h * (m1 + m2) / 2;\n  endfor\nendfunction\n\n\n\nOrde 3: Metode Heun\n\\[w_1=\\alpha\\] \\[w_{i+1}=w_i+\\frac{h}{4}\\left(f\\left(t_i, w_i\\right)+3 f\\left(t_i+\\frac{2 h}{3}, w_i+\\frac{2 h}{3} f\\left(t_i+\\frac{h}{3}, w_i+\\frac{h}{3} f\\left(t_i, w_i\\right)\\right)\\right)\\right)\\]\nbisa juga ditulis,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[w_{i+1}=w_i+\\frac{h}{4}\\left(m_1+3 f\\left(t_i+\\frac{2 h}{3}, w_i+\\frac{2 h}{3} f\\left(t_i+\\frac{h}{3}, w_i+\\frac{h}{3} m_1\\right)\\right)\\right)\\]\natau,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[m_2 = f\\left(t_i+\\frac{h}{3}, w_i+\\frac{h}{3} m_1\\right)\\] \\[w_{i+1}=w_i+\\frac{h}{4}\\left(m_1+3 f\\left(t_i+\\frac{2 h}{3}, w_i+\\frac{2 h}{3} m_2\\right)\\right)\\]\natau bahkan,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[m_2 = f\\left(t_i+\\frac{h}{3}, w_i+\\frac{h}{3} m_1\\right)\\] \\[m_3 = f\\left(t_i+\\frac{2 h}{3}, w_i+\\frac{2 h}{3} m_2\\right)\\] \\[w_{i+1}=w_i+\\frac{h}{4}\\left(m_1+3 m_3\\right)\\]\n\nfunction [t, w] = heun(f, a, b, N, alpha)\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1 : N\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i) + (h / 3), w(i) + (h / 3) * m1);\n    m3 = f(t(i) + (2 * h / 3), w(i) + (2 * h / 3) * m2);\n    w(i + 1) = w(i) + (h / 4) * (m1 + 3 * m3);\n  endfor\nendfunction\n\n\n\nMetode Runge-Kutta orde 4\n\\[w_1=\\alpha\\] \\[k_1=h f\\left(t_i, w_i\\right)\\] \\[k_2=h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{k_1}{2}\\right)\\] \\[k_3=h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{k_2}{2}\\right)\\] \\[k_4=h f\\left(t_{i+1}, w_i+k_3\\right)\\] \\[w_{i+1}=w_i+\\frac{1}{6}\\left(k_1+2 k_2+2 k_3+k_4\\right)\\]\n\nfunction [t, w] = rko4(f, a, b, N, alpha)\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1 : N\n    t(i + 1) = t(i) + h;\n    k1 = h * f(t(i), w(i));\n    k2 = h * f(t(i) + (h / 2), w(i) + (k1 / 2));\n    k3 = h * f(t(i) + (h / 2), w(i) + (k2 / 2));\n    k4 = h * f(t(i + 1), w(i) + k3);\n    w(i + 1) = w(i) + (k1 + 2 * k2 + 2 * k3 + k4) / 6;\n  endfor\nendfunction\n\n\n\nContoh penggunaan\nMisalkan diberikan MNA sebagai berikut:\n\\[y' = y - t^2 + 1\\] \\[0 \\le t \\le 2\\] \\[y(0) = 0.5\\]\n\nf = @(t, y) (y - t .^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\n[t1, w1] = midpoint(f, a, b, 10, alpha);\n[t2, w2] = modified_euler(f, a, b, 10, alpha);\n[t3, w3] = heun(f, a, b, 10, alpha);\n[t4, w4] = rko4(f, a, b, 10, alpha);\n\nsln = @(t) (t + 1) .^ 2 - 0.5 * exp(t);\n\nt5 = linspace(a, b, 11);\nw5 = sln(t5);\n\n\n[t1, w1, w2, w3, w4, w5']\n\nans =\n\n        0   0.5000   0.5000   0.5000   0.5000   0.5000\n   0.2000   0.8280   0.8260   0.8292   0.8293   0.8293\n   0.4000   1.2114   1.2069   1.2140   1.2141   1.2141\n   0.6000   1.6447   1.6372   1.6488   1.6489   1.6489\n   0.8000   2.1213   2.1102   2.1270   2.1272   2.1272\n   1.0000   2.6332   2.6177   2.6406   2.6408   2.6409\n   1.2000   3.1705   3.1496   3.1796   3.1799   3.1799\n   1.4000   3.7212   3.6937   3.7320   3.7323   3.7324\n   1.6000   4.2706   4.2351   4.2830   4.2834   4.2835\n   1.8000   4.8010   4.7556   4.8147   4.8151   4.8152\n   2.0000   5.2904   5.2331   5.3050   5.3054   5.3055\n\n\n\n\nfplot(sln, [0, 2], 'k');\nhold on;\nscatter(t1, w1, 'r');\nscatter(t2, w2, 'g');\nscatter(t3, w3, 'b');\nscatter(t4, w4, 'm');\nlegend('Fungsi eksak', 'Midpoint', 'Modified Euler', 'Heun',\n'Runge-Kutta orde 4');\nlegend(\"location\", \"northwest\");\ntitle('Perbandingan metode Runge-Kutta');"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul2.html#plotting-fungsi",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul2.html#plotting-fungsi",
    "title": "Modul 2 Persamaan Diferensial Numerik",
    "section": "Plotting Fungsi",
    "text": "Plotting Fungsi\nSebelum mulai mempelajari metode-metode untuk menyelesaikan persamaan diferensial secara numerik, kita akan membahas terlebih dahulu tentang teknis plotting fungsi, juga sedikit tambahan materi mengenai fungsi.\nMisalnya kita punya fungsi \\(g(x)=2x\\), suatu fungsi matematis (terkadang disebut “pure function” di dunia pemrograman). Ada dua cara untuk mendefinisikannya di Octave.\nCara pertama, yang sudah dibahas di pertemuan sebelumnya, adalah menggunakan keyword function:\n\nfunction y = g(x)\n  y = 2*x;\nendfunction\n\nSehingga bisa dipanggil:\n\ng(3)\n\nans = 6\n\n\nCara kedua, yang lebih praktis, adalah dengan membuat yang namanya anonymous function. Perhatikan syntax berikut:\n\ng = @(x) 2*x;\ng(3)\n\nans = 6\n\n\nTerlihat lebih sederhana, dan cukup mirip dengan penulisan matematis \\(g(x)=2x\\). Sebutannya anonymous function karena sebenarnya fungsinya tidak memiliki nama yang tetap, kebetulan saja kali ini bisa diakses melalui variabel g yang menyimpannya. Secara umum, penulisannya adalah seperti berikut:\nnama_fungsi = @(input1, input2, ..., input_terakhir) rumus;\nSehingga misalnya kita bisa menuliskan fungsi \\(h(x,y) = x^2 + y^3\\), lalu menghitung \\(h(4,5)\\), sebagai berikut:\n\nh = @(x,y) x^2 + y^3;\nh(4,5)\n\nans = 141\n\n\nSelanjutnya, kita akan membahas tentang plotting.\nMisalkan kita memiliki titik-titik \\((0,0)\\), \\((\\frac{\\pi}{2},1)\\), \\((\\pi,0)\\), dan \\((\\frac{3\\pi}{2},-1)\\). Kita bisa membuat dua array, yaitu satu array yang menyimpan tiap nilai x, dan satu lagi untuk menyimpan tiap nilai y.\nKemudian, kita bisa menggambar plot yang menyambung titik-titik tersebut dengan fungsi plot:\n\nx = [0, pi/2, pi, 3*pi/2];\ny = [0, 1, 0, -1];\nplot(x,y)\n\n\n\n\nTitik-titik tersebut sebenarnya adalah hasil dari fungsi \\(\\sin(x)\\) yang diterapkan pada nilai \\(x=0, \\frac{\\pi}{2}, \\pi, \\frac{3\\pi}{2}\\).\nSebenarnya, kita bisa saja hanya membuat array nilai x, kemudian memperoleh array nilai y dengan memasukkan array x ke dalam fungsi \\(\\sin(x)\\), agar tiap nilai pada array x diterapkan fungsi \\(\\sin(x)\\). Penerapan fungsi pada tiap elemen array seperti itu sering disebut broadcasting.\n\nx = [0, pi/2, pi, 3*pi/2];\ny = sin(x);\nplot(x,y)\n\n\n\n\nUntuk plot yang menyambung-nyambung titik-titik, plotnya sudah bagus. Namun, bagaimana kalau misalnya kita ingin membuat plot fungsi \\(\\sin(x)\\) itu sendiri, misalnya pada interval \\([0,5]\\)?\nCaranya, kita tinggal memperbanyak titik di array x tersebut, agar lebih presisi. Makin banyak titiknya, makin akurat gambarnya.\nTenang saja, kita tidak perlu pegal-pegal mengetik titik-titik \\([0, 0.1, 0.2, ..., 4.9, 5]\\). Di Octave, ada syntax untuk membuat array dari titik-titik pada interval \\([a,b]\\) dengan step size \\(h\\), yaitu sebagai berikut:\nnama_array = a : h : b\nMisalnya, untuk menyimpan titik-titik pada interval \\([0,5]\\) dengan step size 0.1, ketik:\n\nx = 0 : 0.1 : 5\n\nx =\n\n Columns 1 through 8:\n\n         0    0.1000    0.2000    0.3000    0.4000    0.5000    0.6000    0.7000\n\n Columns 9 through 16:\n\n    0.8000    0.9000    1.0000    1.1000    1.2000    1.3000    1.4000    1.5000\n\n Columns 17 through 24:\n\n    1.6000    1.7000    1.8000    1.9000    2.0000    2.1000    2.2000    2.3000\n\n Columns 25 through 32:\n\n    2.4000    2.5000    2.6000    2.7000    2.8000    2.9000    3.0000    3.1000\n\n Columns 33 through 40:\n\n    3.2000    3.3000    3.4000    3.5000    3.6000    3.7000    3.8000    3.9000\n\n Columns 41 through 48:\n\n    4.0000    4.1000    4.2000    4.3000    4.4000    4.5000    4.6000    4.7000\n\n Columns 49 through 51:\n\n    4.8000    4.9000    5.0000\n\n\n\nSehingga, kita bisa membuat plot \\(\\sin(x)\\) pada interval \\([0,5]\\) seperti berikut:\n\nx = 0 : 0.1 : 5;\ny = sin(x);\nplot(x,y)\n\n\n\n\nKita bisa menambahkan judul pada plot dengan title\n\nx = 0 : 0.1 : 5;\ny = sin(x);\nplot(x,y);\ntitle(\"Sinus pada [0,5]\");\n\n\n\n\nWarnanya bisa ditentukan, misal menjadi merah (‘r’), hijau (‘g’), atau biru (‘b’), dengan menambah keterangan di plot\n\nx = 0 : 0.1 : 5;\ny = sin(x);\nplot(x, y, 'r');\ntitle(\"Sinus pada [0,5]\");\n\n\n\n\nPilihan warna lainnya bisa dilihat di link berikut: https://docs.octave.org/latest/Colors.html\nKalau mau, kita bisa mem-plot titik-titiknya saja (tanpa disambung-sambung), menggunakan scatter:\n\nx = 0 : 0.1 : 5;\ny = sin(x);\nscatter(x,y)\n\n\n\n\nSeperti di plot, kita juga bisa menentukan warna di scatter:\n\nx = 0 : 0.1 : 5;\ny = sin(x);\nscatter(x, y, 'g')\n\n\n\n\nSebenarnya, ada cara yang lebih otomatis untuk mem-plot fungsi, yaitu menggunakan fplot. Kita tinggal memberikan:\n\nfungsi yang ingin dibuat gambarnya\ninterval \\([a,b]\\) yang kita inginkan\n(opsional) warna yang kita inginkan\n\n\nf = @(x) sin(x);\nfplot(f, [0, 5], 'r')\n\n\n\n\nNamun, cara ini khusus fungsi kontinu, bahkan langsung menambahkan keterangan yang belum tentu sesuai dengan yang kita inginkan. Agar lebih fleksibel, kita akan lebih sering menggunakan cara manual saja, yaitu dengan membuat array x, menghitung array y, dan memanggil plot.\nKita coba contoh lain yuk! Misalnya kita ingin membuat plot dari fungsi \\(f(x) = x^3\\) pada interval \\([-1,1]\\). Kita bisa coba definisikan fungsinya dulu, lalu buat array x dan y nya:\n\nf = @(x) x^3;\nx = 0 : 0.1 : 5;\ny = f(x);\n\nerror: for x^y, only square matrix arguments are permitted and one argument must be scalar.  Use .^ for elementwise power.\nerror: called from\n    @&lt;anonymous&gt; at line 1 column 11\n\n\nLho, kok error?\nPerhatikan bahwa kita memasukkan array x ke dalam fungsi \\(f(x) = x^3\\). Untuk contoh yang tadi, fungsi \\(\\sin(x)\\), ketika kita memasukkan array x, Octave paham bahwa tiap nilai pada array perlu diterapkan fungsi \\(\\sin\\).\nNamun, kali ini, Octave melihat bahwa ada array yang dipangkatkan tiga. Octave memandang array sebagai matriks dengan satu baris saja (atau satu kolom saja), sehingga Octave mencoba melakukan parpangkatan matriks. Padahal, syarat perpangkatan matriks adalah matriksnya harus persegi. Array ini bukanlah matriks persegi, sehingga jadilah error.\nLalu, bagaimana cara memberi tahu Octave bahwa perpangkatan yang kita maksud adalah perpangkatan per elemen (elementwise)?\nAda syntax khusus untuk itu, yaitu menggunakan .^ daripada ^\nMari kita coba lagi, kali ini membuat plot dengan step size 0.05:\n\nf = @(x) x.^3;\nx = -1 : 0.05 : 1;\ny = f(x);\nplot(x,y)\n\n\n\n\nFun fact: apabila ingin menggunakan fplot (daripada plot) untuk mem-plot suatu fungsi, dan apabila ada perpangkatan di dalam definisi fungsi tersebut, maka penulisannya juga harus menggunakan .^ daripada ^\nBagaimana kalau kita mau plot lebih dari satu fungsi? Kita tetap membuat satu array x saja, lalu membuat array y untuk tiap fungsi, seperti berikut:\n\nx = -1 : 0.05 : 1;\ny1 = sin(x);\ny2 = cos(x);\ny3 = tan(x);\nhold on;\nplot(x, y1, 'r');\nplot(x, y2, 'g');\nplot(x, y3, 'b');\n\n\n\n\nAda baris hold on. Apa itu?\nBaris itu memastikan bahwa semua plot tetap di satu window yang sama, sehingga di satu gambar yang sama (daripada terpisah-pisah).\n(Kalian bisa coba, kalau tidak ada baris hold on, maka plot fungsi \\(\\sin\\), \\(\\cos\\), dan \\(\\tan\\) akan terpisah semua)\nNantinya, kalian juga bisa menambahkan baris hold off kalau kalian ingin plot selanjutnya buka di window yang baru lagi.\nKita juga bisa menambahkan legenda (legend) atau keterangan, seperti berikut. Tuliskan keterangannya secara berurutan, sesuai dengan urutan mem-plot fungsi.\n\nx = -1 : 0.05 : 1;\ny1 = sin(x);\ny2 = cos(x);\ny3 = tan(x);\nhold on;\nplot(x, y1, 'r');\nplot(x, y2, 'g');\nplot(x, y3, 'b');\nlegend(\"Sinus\", \"Kosinus\", \"Tangen\");\n\n\n\n\nSedikit tambahan, kita bisa menyimpan fungsi ke dalam sejenis array yang khusus (sehingga bisa diakses melalui indeks), yang bernama cell array.\nMisalnya kita ingin menyimpan fungsi \\(f(x)=3x^2\\), \\(g(x)=6\\) (fungsi konstan), dan \\(h(x,y) = \\sin(x) + \\cos(y)\\), di dalam satu cell array bernama array_fungsi. Penulisannya menggunakan kurung kurawal { } dan indeksnya juga menggunakan kurung kurawal, seperti berikut:\n\nf = @(x) 3 * x.^2;\ng = @(x) 6;\nh = @(x,y) sin(x) + cos(y);\narray_fungsi = {f, g, h};\n\narray_fungsi{3}(pi/2, 0)\n\nans = 2\n\n\nPerhatikan bahwa kita bisa mengindeks cell array tersebut untuk memperoleh suatu fungsi yang kemudian langsung bisa dipanggil. Misalnya, dipilih indeks ketiga yaitu fungsi \\(h(x,y)\\), kemudian langsung dipanggil dengan \\(x=\\frac{\\pi}{2}\\) dan \\(y=0\\).\nSebenarnya, cell array ini adalah sejenis array yang bisa menyimpan apapun (tidak seperti array biasa yang hanya bisa menyimpan nilai numerik).\n\ntest_cell = {9, 8, 7};\ntest_cell{2} * 3\n\nans = 24\n\n\nNamun, broadcasting tidak berlaku pada cell array, sehingga cell array jarang digunakan (toh Octave paling sering digunakan untuk perhitungan numerik).\nArray biasa dan cell array di Octave, bagaikan array numpy dan list di Python."
  },
  {
    "objectID": "semuahalaman/modulprak/2023/genap/metnum/modul3.html",
    "href": "semuahalaman/modulprak/2023/genap/metnum/modul3.html",
    "title": "Review matplotlib",
    "section": "",
    "text": "Praktikum Metode Numerik 2023 Semester Genap\nModul Pertemuan 3: Interpolasi\nKembali ke Metode Numerik\nOUTLINE"
  },
  {
    "objectID": "semuahalaman/modulprak/2023/genap/metnum/modul3.html#penjelasan-ide-dengan-contoh-indeks-mulai-dari-1",
    "href": "semuahalaman/modulprak/2023/genap/metnum/modul3.html#penjelasan-ide-dengan-contoh-indeks-mulai-dari-1",
    "title": "Review matplotlib",
    "section": "Penjelasan ide dengan contoh (indeks mulai dari 1)",
    "text": "Penjelasan ide dengan contoh (indeks mulai dari 1)\nMisal diketahui empat titik yaitu \\((x_1, y_1)\\), \\((x_2, y_2)\\), \\((x_3, y_3)\\), dan \\((x_4, y_4)\\). Ide polinom interpolasi Lagrange adalah membuat fungsi \\(P(x)\\) sebagai berikut (yang diduga akan berupa polinom):\n\\[P(x) = y_1 L_{4,1} (x) + y_2 L_{4,2} (x) + y_3 L_{4,3} (x) + y_4 L_{4,4} (x)\\]\nLalu apa itu fungsi \\(L_{n,k} (x)\\)? Pada subscript (tulisan di sebelah bawah), bilangan pertama adalah \\(n\\) atau banyaknya titik, sedangkan bilangan kedua adalah \\(k\\) atau titik ke-\\(k\\). Fungsi \\(L_{n,k} (x)\\) ini memang bergantung \\(k\\), artinya tiap titik dipasangkan dengan suatu fungsi \\(L_{n,k} (x)\\) yang sesuai.\nFungsi \\(L_{4,k} (x)\\) tersebut diharapkan memiliki sifat sebagai berikut:\n\\[P(x_1) = \\color{blue}{y_1 * 1} + \\color{red}{y_2 * 0} + \\color{red}{y_3 * 0} + \\color{red}{y_4 * 0} = \\color{blue}{y_1}\\]\n\\[P(x_2) = \\color{red}{y_1 * 0} + \\color{blue}{y_2 * 1} + \\color{red}{y_3 * 0} + \\color{red}{y_4 * 0} = \\color{blue}{y_2}\\]\n\\[P(x_3) = \\color{red}{y_1 * 0} + \\color{red}{y_2 * 0} + \\color{blue}{y_3 * 1} + \\color{red}{y_4 * 0} = \\color{blue}{y_3}\\]\n\\[P(x_4) = \\color{red}{y_1 * 0} + \\color{red}{y_2 * 0} + \\color{red}{y_3 * 0} + \\color{blue}{y_4 * 1} = \\color{blue}{y_4}\\]\nArtinya, \\(L_{n,k} (x_k) = 1\\), sedangkan \\(L_{n,k} (x_i) = 0\\) untuk nilai \\(i\\) selain \\(k\\) (lebih tepatnya, bernilai nol ketika ada titik ke-\\(i\\) yaitu titik selain titik ke-\\(k\\)). Sebenarnya, kita tidak peduli apa nilai \\(L_{n,k} (x)\\) untuk apapun nilai \\(x\\) selain titik yang diketahui.\nMengingat sifat yang diharapkan, kita bisa merancang fungsi \\(L_{4,k} (x)\\) sebagai berikut untuk \\(k = 1, 2, 3, 4\\):\n\\[L_{4,1} (x) = \\frac{(x-x_2)(x-x_3)(x-x_4)}{(x_1-x_2)(x_1-x_3)(x_1-x_4)}\\]\n\\[L_{4,2} (x) = \\frac{(x-x_1)(x-x_3)(x-x_4)}{(x_2-x_1)(x_2-x_3)(x_2-x_4)}\\]\n\\[L_{4,3} (x) = \\frac{(x-x_1)(x-x_2)(x-x_4)}{(x_3-x_1)(x_3-x_2)(x_3-x_4)}\\]\n\\[L_{4,4} (x) = \\frac{(x-x_1)(x-x_2)(x-x_3)}{(x_4-x_1)(x_4-x_2)(x_4-x_3)}\\]\nPerhatikan: * bagian pembilang terdiri dari perkalian \\((x-x_i)\\) untuk semua \\(i\\) kecuali \\(i=k\\). Tujuannya, ketika \\(L_{4,k} (x)\\) itu disubstitusikan \\(x=x_i\\) untuk \\(i\\) selain \\(k\\), hasilnya menjadi \\(L_{4,k} (x_i) = 0\\), kecuali untuk \\(x=x_k\\) itu hasilnya tidak nol. * bagian penyebut/pembagi itu sebenarnya sama saja dengan pembilang, tapi disubstitusikan \\(x=x_k\\). Tujuannya, ketika \\(L_{4,k} (x)\\) disubstitusikan dengan \\(x=x_k\\), apapun hasil taknol dari pembilang itu dibagi dengan dirinya sendiri agar menjadi \\(L_{4,k} (x_k) = 1\\).\nDengan demikian, \\(P(x)\\) bisa terbentuk. Perhatikan bahwa \\(L_{n,k} (x)\\) berbentuk polinom, sehingga \\(P(x)\\) yang terbentuk juga akan berupa polinom. Sehingga, metode polinom interpolasi Lagrange berhasil menghasilkan polinom interpolasi. Ide ini berlaku umum untuk banyaknya titik \\(n\\) sebesar apapun.\nPerhatikan bahwa masing-masing fungsi \\(L_{4,k} (x)\\) bisa dituliskan sebagai berikut:\n\\[L_{4,1} (x) = \\frac{(x-x_2)}{(x_1-x_2)} * \\frac{(x-x_3)}{(x_1-x_3)} * \\frac{(x-x_4)}{(x_1-x_4)}\\]\n\\[L_{4,2} (x) = \\frac{(x-x_1)}{(x_2-x_1)} * \\frac{(x-x_3)}{(x_2-x_3)} * \\frac{(x-x_4)}{(x_2-x_4)}\\]\n\\[L_{4,3} (x) = \\frac{(x-x_1)}{(x_3-x_1)} * \\frac{(x-x_2)}{(x_3-x_2)} * \\frac{(x-x_4)}{(x_3-x_4)}\\]\n\\[L_{4,4} (x) = \\frac{(x-x_1)}{(x_4-x_1)} * \\frac{(x-x_2)}{(x_4-x_2)} * \\frac{(x-x_3)}{(x_4-x_3)}\\]\natau, di mana warna merah artinya tidak dituliskan,\n\\[\\text{Untuk } k=1, \\text{ } L_{4,1} (x) = \\color{red}{\\frac{(x-x_1)}{(x_1-x_1)} * } \\color{black}{\\frac{(x-x_2)}{(x_1-x_2)} * \\frac{(x-x_3)}{(x_1-x_3)} * \\frac{(x-x_4)}{(x_1-x_4)}}\\]\n\\[\\text{Untuk } k=2, \\text{ } L_{4,2} (x) = \\frac{(x-x_1)}{(x_2-x_1)} \\color{red}{* \\frac{(x-x_2)}{(x_2-x_2)}} \\color{black}{* \\frac{(x-x_3)}{(x_2-x_3)} * \\frac{(x-x_4)}{(x_2-x_4)}}\\]\n\\[\\text{Untuk } k=3, \\text{ } L_{4,3} (x) = \\frac{(x-x_1)}{(x_3-x_1)} * \\frac{(x-x_2)}{(x_3-x_2)} \\color{red}{* \\frac{(x-x_3)}{(x_3-x_3)}} \\color{black}{* \\frac{(x-x_4)}{(x_3-x_4)}}\\]\n\\[\\text{Untuk } k=4, \\text{ } L_{4,4} (x) = \\frac{(x-x_1)}{(x_4-x_1)} * \\frac{(x-x_2)}{(x_4-x_2)} * \\frac{(x-x_3)}{(x_4-x_3)} \\color{red}{* \\frac{(x-x_4)}{(x_4-x_4)}}\\]\nDengan demikian, pembentukan fungsi \\(L_{n,k} (x)\\) secara pemrograman bisa dilakukan dengan perkalian iteratif, seperti iterasi \\(i = 1, 2, 3, 4\\), tetapi dengan syarat \\(i \\ne k\\)."
  },
  {
    "objectID": "semuahalaman/modulprak/2023/genap/metnum/modul3.html#bentuk-umum-indeks-mulai-dari-0-dan-kode",
    "href": "semuahalaman/modulprak/2023/genap/metnum/modul3.html#bentuk-umum-indeks-mulai-dari-0-dan-kode",
    "title": "Review matplotlib",
    "section": "Bentuk umum (indeks mulai dari 0) dan kode",
    "text": "Bentuk umum (indeks mulai dari 0) dan kode\nBila diberikan \\(n+1\\) titik \\(x_0, x_1, \\dots, x_n\\), dan \\(f\\) adalah fungsi yang nilainya pada titik-titik tersebut diberikan, maka polinom interpolasi Lagrange ke-n didefinisikan sebagai\n\\[P(x) = f(x_0) L_{n,0}(x_0) + f(x_1) L_{n,1}(x_1) + \\cdots f(x_n) L_{n,n}(x_n)\\]\ndi mana, untuk setiap \\(k = 0, 1, \\dots, n\\),\n\\[L_{n,k}(x) = \\prod_{\\substack{i=0 \\\\ i\\ne k}}^{n} \\frac{x - x_i}{x_k - x_i}\\]\ndi mana \\(\\Pi\\) atau pi besar melambangkan perkalian yang “berulang” atau “teriterasi”, layaknya \\(\\Sigma\\) (sigma besar) yang melambangkan penjumlahan yang “berulang” atau “teriterasi”. Perhatikan syarat \\(i\\ne k\\).\n\nimport sympy\nx = sympy.symbols('x')\n\n# jaga-jaga ada konstanta pi pada data titik-titik yang diberikan\nfrom numpy import pi\n\ntitik_x = eval(input(\"Masukkan list nilai x : \"))\ntitik_y = eval(input(\"Masukkan list nilai fungsi di titik-titik tersebut : \"))\neval_x = eval(input(\"Masukkan nilai x yang akan diaproksimasi nilai fungsinya : \"))\n\ndef LagrangePol(x, x_points, y_points):\n    pol = 0 # nilai awal polinom sebelum ditambahkan apa-apa\n    n = len(x_points) # n adalah banyak titik\n    for k in range(n): # membuat y*L_(n,k) untuk tiap k\n        L = 1 # nilai awal fungsi L\n        for i in range(n):\n            if i!=k: # syarat i != k\n                L *= ((x-x_points[i])/(x_points[k]-x_points[i])) # iterasi perkalian\n        pol += y_points[k]*L # menambahkan pasangan y*L ke polinom\n    return pol\n\ny_lagrange = LagrangePol(x, titik_x, titik_y)\n# bentuk masih berantakan, sehingga perlu disederhanakan:\ny_sederhana = sympy.simplify(y_lagrange)\n# perlu diubah menjadi function biasa agar bisa disubstitusikan nilai x:\ny_function = sympy.lambdify(x, y_sederhana)\n# akhirnya bisa substitusi:\nnilai_y = y_function(eval_x)\n\nprint(\"Polinom hasil interpolasi Lagrange:\")\nsympy.pprint(y_lagrange)\nprint(\"Disederhanakan:\")\nsympy.pprint(y_sederhana)\nprint(\"Aproksimasi nilai fungsi di x = {0} adalah y = {1:.5f}\".format(eval_x, nilai_y))\n\nMasukkan list nilai x : [1, 2, 3, 4]\nMasukkan list nilai fungsi di titik-titik tersebut : [1, 4, 9, 16]\nMasukkan nilai x yang akan diaproksimasi nilai fungsinya : 1.5\nPolinom hasil interpolasi Lagrange:\n⎛4   x⎞ ⎛3   x⎞             ⎛    x⎞                             ⎛x   1⎞       \n⎜─ - ─⎟⋅⎜─ - ─⎟⋅(2 - x) + 4⋅⎜2 - ─⎟⋅(3 - x)⋅(x - 1) + 9⋅(4 - x)⋅⎜─ - ─⎟⋅(x - 2\n⎝3   3⎠ ⎝2   2⎠             ⎝    2⎠                             ⎝2   2⎠       \n\n       ⎛x   1⎞ ⎛x    ⎞        \n) + 16⋅⎜─ - ─⎟⋅⎜─ - 1⎟⋅(x - 3)\n       ⎝3   3⎠ ⎝2    ⎠        \nDisederhanakan:\n 2\nx \nAproksimasi nilai fungsi di x = 1.5 adalah y = 2.25000"
  },
  {
    "objectID": "semuahalaman/modulprak/2023/genap/metnum/modul3.html#kode-versi-sederhana",
    "href": "semuahalaman/modulprak/2023/genap/metnum/modul3.html#kode-versi-sederhana",
    "title": "Review matplotlib",
    "section": "Kode Versi Sederhana",
    "text": "Kode Versi Sederhana\nNDD memiliki bentuk sebagai berikut :\n\\[P_n (x) = f[x_0] + \\sum_{k=1}^{n} f[x_0, x_1, \\dots, x_k](x-x_0)(x-x_1)\\dots (x-x_k)\\]\ndi mana \\(f[x_k] = f(x_k)\\) dan\n\\[f[x_i, x_{i+1}, \\dots, x_{i+k}] = \\frac{f[x_{i+1}, x_{i+2}, \\dots, x_{i+k}]-f[x_i, x_{i+1}, \\dots, x_{i+k-1}]}{x_{i+k} - x_i}\\]\nPada rumusan di atas, \\(f[x_i x_{i+1}, \\dots, x_{i+k}]\\) disebut k-th divided difference relatif terhadap \\(x_i x_{i+1}, \\dots, x_{i+k}\\).\nDalam membentuk polinomial interpolasi dengan NDD, seringkali tabel divided difference dibuat untuk memudahkan. Tabel tersebut berbentuk seperti berikut.\n\n\n\ncrop table3_9 page 126 Numerical analysis by Richard L Burden J Douglas Faires (z-lib.org) copy.jpg\n\n\nSumber gambar: Burden, Richard L., Faires, J. Douglas. Numerical Analysis. Bab 3, “Interpolation and Polynomial Approximation”. Subbab 3.3, “Divided Differences”. Hlm. 126\nAda dua cara pembentukan polinomial interpolasi dengan DD, yaitu cara Forward dan Backward.\n\nForward DD menggunakan baris paling atas dari setiap kolom pada tabel DD.\n\n\\[P_n (x) = f[x_0] + \\sum_{k=1}^{n} f[x_0, x_1, \\dots, x_k] (x-x_0) (x-x_1) \\dots (x-x_{k-1})\\]\n\nBackward DD menggunakan baris paling akhir dari setiap kolom pada tabel DD.\n\n\\[P_n (x) = f[x_n] + \\sum_{k=1}^{n} f[x_n, x_{n-1}, \\dots, x_{n-k}] (x-x_n) (x-x_{n-1}) \\dots (x - x_{n-k+1})\\]\nKode Python untuk menginterpolasi titik-titik data dengan menggunakan NDD adalah sebagai berikut.\n\nimport sympy\nx = sympy.symbols('x')\n\n# jaga-jaga ada konstanta pi pada data titik-titik yang diberikan\nfrom numpy import pi\n\ntitik_x = eval(input('Masukkan list nilai x : '))\ntitik_y = eval(input('Masukkan list nilai fungsi di titik-titik tersebut : '))\neval_x = eval(input('Masukkan nilai x yang akan diaproksimasi nilai fungsinya : '))\n\ndef DDTableGenerator(x_points, y_points): #buat fungsi untuk membuat tabel DD\n    DDTable = [y_points] #kolom-kolom pada tabel. Kolom pertama berisi f\n    for column in range(1,len(y_points)):\n        DDcolumn = [] #isi dari setiap kolom\n        for row in range(len(DDTable[-1])-1): #mulai mengisi kolom tabel\n            DD = (DDTable[-1][row+1]-DDTable[-1][row])/(x_points[column+row]-x_points[row])\n            DDcolumn.append(DD)\n        DDTable.append(DDcolumn) #tambahkan kolom yang telah diisi ke tabel\n    return DDTable\n\ndef ForwardDD(x, x_points, y_points):\n    DDTable = DDTableGenerator(x_points,y_points)\n    pol = DDTable[0][0] #nilai dari polinom. Inisiasi : suku pertama po\n    mult_term = 1 #variabel untuk menyimpan nilai dari (x-x0)(x-x\n    for k in range(1,len(DDTable)):\n        mult_term*=(x-x_points[k-1]) #menghitung (x-x0)(x-x1)...(x-x(n-1))\n        pol+=DDTable[k][0]*mult_term #menghitung nilai interpolasi\n    return pol\n\ndef BackwardDD(x, x_points, y_points):\n    DDTable = DDTableGenerator(x_points,y_points)\n    pol = DDTable[0][-1] #nilai dari polinom. Inisiasi : suku pertama po\n    mult_term = 1 #variabel untuk menyimpan nilai dari (x-xn)(x-x\n    for k in range(1,len(DDTable)):\n        mult_term*=(x-x_points[-k]) #menghitung (x-xn)(x-x(n-1))...(x-x1)\n        pol+=DDTable[k][-1]*mult_term #menghitung nilai interpolasi\n    return pol\n\nforw_pol = ForwardDD(x, titik_x,titik_y)\nback_pol = BackwardDD(x, titik_x,titik_y)\n\nforw_sederhana = sympy.simplify(forw_pol)\nback_sederhana = sympy.simplify(back_pol)\n\nforw_function = sympy.lambdify(x, forw_sederhana)\nback_function = sympy.lambdify(x, back_sederhana)\n\nnilai_forw = forw_function(eval_x)\nnilai_back = back_function(eval_x)\n\nprint(\"Polinom hasil foward DD:\")\nsympy.pprint(forw_pol)\nprint(\"disederhanakan:\")\nsympy.pprint(forw_sederhana)\nprint(\"Polinom hasil backward DD:\")\nsympy.pprint(back_pol)\nprint(\"disederhanakan:\")\nsympy.pprint(back_sederhana)\n\nprint(\"Aproksimasi nilai fungsi di x = {0} adalah : \".format(eval_x))\nprint(\"Forward DD : {0:.5f}\".format(nilai_forw))\nprint(\"Backward DD : {0:.5f}\".format(nilai_back))\n\nMasukkan list nilai x : [1, 2, 3, 4]\nMasukkan list nilai fungsi di titik-titik tersebut : [1, 4, 9, 16]\nMasukkan nilai x yang akan diaproksimasi nilai fungsinya : 1.5\nPolinom hasil foward DD:\n3.0⋅x + 1.0⋅(x - 2)⋅(x - 1) - 2.0\ndisederhanakan:\n     2\n1.0⋅x \nPolinom hasil backward DD:\n7.0⋅x + 1.0⋅(x - 4)⋅(x - 3) - 12.0\ndisederhanakan:\n     2\n1.0⋅x \nAproksimasi nilai fungsi di x = 1.5 adalah : \nForward DD : 2.25000\nBackward DD : 2.25000"
  },
  {
    "objectID": "semuahalaman/modulprak/2023/genap/metnum/modul3.html#kode-versi-tabel-bagus",
    "href": "semuahalaman/modulprak/2023/genap/metnum/modul3.html#kode-versi-tabel-bagus",
    "title": "Review matplotlib",
    "section": "Kode Versi Tabel Bagus",
    "text": "Kode Versi Tabel Bagus\nKode versi sebelumnya lebih sederhana, namun sayangnya tidak bisa menampilkan tabel divided difference. Kode yang akan dijelaskan di bagian ini, walaupun lebih rumit, tetapi pada akhirnya lebih intuitif, karena nantinya proses pembuatan polinom Forward DD dan Backward DD akan langsung menggunakan data dari tabel yang sudah dibentuk. (Lagipula, enak kan kalo bisa liat tabelnya? Hehe)\nKita review kembali, metode interpolasi Newton Divided Difference (NDD) melibatkan pembuatan tabel besar seperti berikut:\n\n\n\ncrop table3_9 page 126 Numerical analysis by Richard L Burden J Douglas Faires (z-lib.org) copy.jpg\n\n\nSumber gambar: Burden, Richard L., Faires, J. Douglas. Numerical Analysis. Bab 3, “Interpolation and Polynomial Approximation”. Subbab 3.3, “Divided Differences”. Hlm. 126\nData pada dua kolom pertama adalah data titik \\((x, y)\\) yang diketahui, sedangkan perhitungan data pada tiap kolom lainnya (first divided differences, second divided differences, dll.) itu bergantung pada kolom sebelumnya.\nPembuatan tabel Newton Divided Differences (NDD) melibatkan suatu fungsi \\(f\\) dengan kurung siku, dengan rumus sesuai tabel di atas. Istilah “divided differences” artinya “beda/selisih yang saling dibagi”, sesuai rumus \\(f\\) tersebut.\nKetika hanya terdiri dari satu input, \\(f[x_k] = f(x_k) = y_k\\), untuk suatu data titik \\((x_k, y_k)\\) yang diketahui.\nSecara umum, rumusnya adalah\n\\[f[x_i, x_{i+1}, \\dots, x_{i+k}] = \\frac{f[x_{i+1}, x_{i+2}, \\dots, x_{i+k}]-f[x_i, x_{i+1}, \\dots, x_{i+k-1}]}{x_{i+k} - x_i}\\]\nUntuk titik yang banyak, penulisan nama fungsi \\(f[\\dots]\\) bisa menjadi sangat panjang. Perhatikan bahwa isi inputnya selalu berurutan, misal dari \\(x_a\\) sampai \\(x_b\\). Kita bisa mendefinisikan suatu fungsi untuk mempersingkat penulisan tersebut, misal kita namakan F-rentang atau kita singkat FR:\n\\[\\text{FR}(a, b) = f[x_a, x_{a+1}, x_{a+2}, \\dots, x_{b-2}, x_{b-1}, x_b]\\]\nyaitu fungsi yang sebenarnya menerima input berupa rentang nilai \\(x_k\\) dari \\(x_a\\) (\\(k=a\\)) sampai \\(x_b\\) (\\(k=b\\)).\nMaka, rumus \\(f\\) di atas dapat disingkat menjadi\n\\[\\text{FR}(a, a+k) = \\frac{\\text{FR}(a+1, a+k) - \\text{FR}(a, a+k-1)}{x_{a+k}-x_a}\\]\nDengan memasang \\(b = a+k\\), diperoleh\n\\[\\text{FR}(a, b) = \\frac{\\text{FR}(a+1, b) - \\text{FR}(a, b-1)}{x_b-x_a}\\]\nMenariknya, pada tabel,\n\nnilai \\(\\text{FR}(a, b-1)\\) selalu terletak di sebelah kiri atas dari \\(\\text{FR}(a, b)\\)\nnilai \\(\\text{FR}(a+1, b)\\) selalu terletak di sebelah kiri bawah dari \\(\\text{FR}(a, b)\\)\n\nDengan demikian, bisa saja kita memrogram perhitungan NDD menggunakan tabel.\nSeolah-olah, rumusnya adalah “kiri bawah dikurang kiri atas, dibagi \\(x_b - x_a\\)”.\nSelain itu, untuk data sebanyak \\(n+1\\),\n\nada sebanyak \\(n\\) kolom divided difference.\ndengan banyak kotak kosong (seperti pada gambar di atas), tabel utama terdiri dari \\(2n+1\\) baris dan \\(n+1\\) kolom, termasuk kolom \\(f(x_i)\\) tetapi tidak termasuk kolom \\(x_i\\).\n\nDengan demikian, kita dapat menghitung banyaknya data (yang kita anggap sebanyak \\(n+1\\)), kemudian menghitung \\(n\\) (tinggal dikurang 1), lalu mulai membangun tabel berdasarkan sifat baris dan kolom tersebut.\nIstilah “tabel utama” yang kita gunakan di sini merujuk pada tabel divided difference dari kolom \\(f(x_k)\\) sampai kolom divided difference ke-n, tanpa adanya kolom \\(x_i\\) maupun \\(i\\). Untuk ke depannya, tabel divided difference yang lengkap (yang termasuk kolom \\(x_i\\) dan \\(i\\)) akan kita sebut “tabel besar”, dibedakan dengan tabel utama.\n\nfrom tabulate import tabulate\n\n# jaga-jaga ada konstanta pi pada data titik-titik yang diberikan\nfrom numpy import pi\n\n# menyusun tabel Newton Divided Differences (NDD)\ndef CreateDDTable(list_x, list_y):\n    # === Menyusun tabel utama === #\n    # mengandung kolom f(x_i) serta semua kolom divided difference\n\n    MainDDTable = []\n    banyak_data = len(list_x) # = n + 1\n    n = banyak_data - 1\n    \n    # mengisi tabel dengan string kosong\n    # ingat: 2n+1 baris, n+1 kolom\n    for i in range(2*n+1):\n        calon_baris = []\n        for j in range(n+1):\n            calon_baris.append(\"\")\n        MainDDTable.append(calon_baris)\n    \n    # mengisi kolom pertama dengan nilai y_i = f(x_i)\n    for i in range(0, 2*n+1, 2): # untuk tiap baris, lompat 2\n        MainDDTable[i][0] = list_y[int(i/2)]\n    \n    # iterasi mengisi tiap kolom divided difference\n    for j in range(1, n+1): # untuk tiap kolom divided difference\n        # nilai a dan b untuk DD yang paling atas pada kolom\n        a = 0\n        b = j # nilai b pertama adalah j, selalu sesuai kolom DD ke-j\n        for i in range(j, 2*n - j + 1, 2): # untuk tiap baris, lompat 2\n            # iterasi dimulai dari baris j,\n            # baris terakhir adalah baris dengan indeks 2*n - j.\n            # Alasannya: total baris sebanyak 2*n + 1 (indeks 2*n),\n            # dan secara umum, pada kolom DD ke-j, perhitungan DD terakhir\n            # adalah pada j baris sebelum baris terakhir pada tabel,\n            # sehingga baris terakhir tersebut ada pada indeks 2*n - j.\n            # Pada for loop, kita gunakan 2*n - j + 1\n            # agar baris terakhir menjadi 2*n - j (karena keanehan Python)\n\n            # kiri bawah dikurang kiri atas, dibagi (x_b - x_a)\n            MainDDTable[i][j] = (MainDDTable[i+1][j-1] - MainDDTable[i-1][j-1])/(list_x[b] - list_x[a])\n            # memperbarui nilai a dan b untuk iterasi selanjutnya\n            a += 1\n            b += 1\n    \n    # === Menyusun tabel besar === #\n\n    # duplikasi MainDDTable\n    BigDDTable = []\n    for row in MainDDTable:\n        calon_baris = []\n        for col in row:\n            calon_baris.append(col)\n        BigDDTable.append(calon_baris)\n\n    # tempel kolom nilai i dan x_i di sebelah kiri tabel\n    for i in range(2*n+1):\n        indeks_x = int(i/2)\n        if i % 2 == 0: # baris berindeks genap, seperti baris pertama (i=0)\n            BigDDTable[i].insert(0, list_x[indeks_x])\n            BigDDTable[i].insert(0, indeks_x)\n        else:\n            BigDDTable[i].insert(0, \"\")\n            BigDDTable[i].insert(0, \"\")\n    \n    # menyusun list semua header\n    semua_header = [\"i\", \"x_i\", \"f(x_i)\"]\n    for k in range(1, n+1):\n        semua_header.append(\"DD ke-\" + str(k))\n\n    olahan_BigDDTable = tabulate(BigDDTable, headers=semua_header,\n                                 tablefmt=\"orgtbl\")\n    \n    return MainDDTable, olahan_BigDDTable\n\n\ntitik_x = eval(input('Masukkan list nilai x : '))\ntitik_y = eval(input('Masukkan list nilai fungsi di titik-titik tersebut : '))\n\ntabel_utama, tabel_olahan = CreateDDTable(titik_x, titik_y)\n\nprint(\"Tabel Newton Divided Difference:\")\nprint(tabel_olahan)\n\nMasukkan list nilai x : [1.0, 1.3, 1.6, 1.9, 2.2]\nMasukkan list nilai fungsi di titik-titik tersebut : [0.7651977, 0.6200860, 0.4554022, 0.2818186, 0.1103623]\nTabel Newton Divided Difference:\n| i   | x_i   | f(x_i)    | DD ke-1             | DD ke-2              | DD ke-3             | DD ke-4               |\n|-----+-------+-----------+---------------------+----------------------+---------------------+-----------------------|\n| 0   | 1.0   | 0.7651977 |                     |                      |                     |                       |\n|     |       |           | -0.4837056666666664 |                      |                     |                       |\n| 1   | 1.3   | 0.620086  |                     | -0.10873388888888935 |                     |                       |\n|     |       |           | -0.548946           |                      | 0.06587839506172834 |                       |\n| 2   | 1.6   | 0.4554022 |                     | -0.04944333333333385 |                     | 0.0018251028806604353 |\n|     |       |           | -0.5786120000000003 |                      | 0.06806851851852086 |                       |\n| 3   | 1.9   | 0.2818186 |                     | 0.011818333333334928 |                     |                       |\n|     |       |           | -0.5715209999999994 |                      |                     |                       |\n| 4   | 2.2   | 0.1103623 |                     |                      |                     |                       |\n\n\nNantinya, dari tabel NDD yang sudah lengkap, ada dua jenis polinom interpolasi NDD yang dapat diperoleh, yaitu Newton Forward-Difference dan Newton Backward-Difference, tergantung nilai mana pada tabel yang digunakan. Misalkan ada data sebanyak \\(n+1\\) titik, yaitu \\(x_0, x_1, x_2, \\dots, x_{n-1}, x_n\\). Maka, akan ada sebanyak \\(n\\) kolom divided differences pada tabel.\n\nNewton Forward-Difference (juga disebut Forward DD) menggunakan baris paling atas dari setiap kolom pada tabel DD.\n\n\\[P_n (x) = f[x_0] + \\sum_{k=1}^{n} f[x_0, x_1, \\dots, x_k] \\left( \\prod_{j=0}^{k-1} (x-x_j) \\right)\\]\n\nNewton Backward-Difference (juga disebut Backward DD) menggunakan baris paling akhir dari setiap kolom pada tabel DD.\n\n\\[P_n (x) = f[x_n] + \\sum_{k=1}^{n} f[x_{n-k}, \\dots, x_{n-1}, x_n] \\left( \\prod_{j=n-k+1}^{n} (x-x_j) \\right)\\]\nCatatan: \\(f[x_n, x_{n-1}, \\dots, x_{n-k}] = f[x_{n-k}, \\dots, x_{n-1}, x_n]\\). Artinya, penulisan terbalik (seperti di beberapa sumber referensi Metode Numerik) sebenarnya tidak mempengaruhi perhitungan.\nMenyingkat penulisan dengan \\(\\text{FR}(a, b)\\), kita peroleh:\n\nForward DD\n\n\\[P_n (x) = f[x_0] + \\sum_{k=1}^{n} \\text{FR}(0, k) \\left( \\prod_{j=0}^{k-1} (x-x_j) \\right)\\]\natau, mengingat bahwa \\(\\text{FR}(0, 0) = f[x_0]\\), kemudian menjabarkan,\n[ \\[\\begin{align*}\nP_n (x) = \\text{FR}(0, 0) &+ \\text{FR}(0, 1) (x-x_0) \\\\\n&+ \\text{FR}(0, 2) (x-x_0)(x-x_1) \\\\\n&+ \\dots \\\\\n&+ \\text{FR}(0, n)\\prod_{j=0}^{n-1} (x-x_j)\n\\end{align*}\\] ]\n\nBackward DD\n\n\\[P_n (x) = f[x_n] + \\sum_{k=1}^{n} \\text{FR}(n-k, n) \\left( \\prod_{j=n-k+1}^{n} (x-x_j) \\right)\\]\natau, mengingat bahwa \\(\\text{FR}(n, n) = f[x_n]\\), kemudian menjabarkan,\n[ \\[\\begin{align*}\nP_n (x) = \\text{FR}(n, n) &+ \\text{FR}(n-1, n) (x-x_n) \\\\\n&+ \\text{FR}(n-2, n) (x-x_{n-1}) (x-x_n) \\\\\n&+ \\dots \\\\\n&+ \\text{FR}(0, n) \\prod_{j=1}^{n} (x-x_j)\n\\end{align*}\\] ]\n\n# jaga-jaga ada konstanta pi pada data titik-titik yang diberikan\nfrom numpy import pi\n\nfrom tabulate import tabulate\n\nimport sympy\nx = sympy.symbols('x')\n\ntitik_x = eval(input('Masukkan list nilai x : '))\ntitik_y = eval(input('Masukkan list nilai fungsi di titik-titik tersebut : '))\neval_x = eval(input('Masukkan nilai x yang akan diaproksimasi nilai fungsinya : '))\n\n# Kita asumsikan function/fungsi CreateDDTable sudah terdefinisi sebelumnya.\n# Kalau belum terdefinisi, boleh copy-paste definisi fungsinya ke sini\n\ntabel_utama, tabel_olahan = CreateDDTable(titik_x, titik_y)\n\nprint(\"Tabel Newton Divided Difference:\")\nprint(tabel_olahan)\nprint() # jaga jarak dengan print yang selanjutnya\n\ndef ForwardDD(tabel_utama, list_x):\n    banyak_data = len(tabel_utama[0])\n    pol = 0\n    for k in range(0, banyak_data): # tiap suku penjumlahan\n        suku = tabel_utama[k][k] # FR(0, k)\n        for j in range(0, k): # perkalian dari j=0 sampai j=k-1\n            suku *= (x - list_x[j])\n        pol += suku\n    return pol\n\ndef BackwardDD(tabel_utama, list_x):\n    banyak_data = len(tabel_utama[0])\n    n = banyak_data - 1\n    pol = 0\n    for k in range(banyak_data): # tiap suku penjumlahan\n        suku = tabel_utama[2*n-k][k] # FR(n-k, k)\n        for j in range(n-k+1, n+1): # perkalian dari j=n-k+1 sampai j=n\n            suku *= (x - list_x[j])\n        pol += suku\n    return pol\n\nforw_pol = ForwardDD(tabel_utama, titik_x)\nback_pol = BackwardDD(tabel_utama, titik_x)\n\nforw_sederhana = sympy.simplify(forw_pol)\nback_sederhana = sympy.simplify(back_pol)\n\nforw_function = sympy.lambdify(x, forw_sederhana)\nback_function = sympy.lambdify(x, back_sederhana)\n\nnilai_forw = forw_function(eval_x)\nnilai_back = back_function(eval_x)\n\nprint(\"Polinom hasil foward DD:\")\nsympy.pprint(forw_pol)\nprint()\nprint(\"disederhanakan:\")\nsympy.pprint(forw_sederhana)\nprint()\n\nprint(\"Polinom hasil backward DD:\")\nsympy.pprint(back_pol)\nprint()\nprint(\"disederhanakan:\")\nsympy.pprint(back_sederhana)\nprint()\n\nprint(\"Aproksimasi nilai fungsi di x = {0} adalah : \".format(eval_x))\nprint(\"Forward DD : {0}\".format(nilai_forw))\nprint(\"Backward DD : {0}\".format(nilai_back))\n\nMasukkan list nilai x : [1.0, 1.3, 1.6, 1.9, 2.2]\nMasukkan list nilai fungsi di titik-titik tersebut : [0.7651977, 0.6200860, 0.4554022, 0.2818186, 0.1103623]\nMasukkan nilai x yang akan diaproksimasi nilai fungsinya : 1.5\nTabel Newton Divided Difference:\n| i   | x_i   | f(x_i)    | DD ke-1             | DD ke-2              | DD ke-3             | DD ke-4               |\n|-----+-------+-----------+---------------------+----------------------+---------------------+-----------------------|\n| 0   | 1.0   | 0.7651977 |                     |                      |                     |                       |\n|     |       |           | -0.4837056666666664 |                      |                     |                       |\n| 1   | 1.3   | 0.620086  |                     | -0.10873388888888935 |                     |                       |\n|     |       |           | -0.548946           |                      | 0.06587839506172834 |                       |\n| 2   | 1.6   | 0.4554022 |                     | -0.04944333333333385 |                     | 0.0018251028806604353 |\n|     |       |           | -0.5786120000000003 |                      | 0.06806851851852086 |                       |\n| 3   | 1.9   | 0.2818186 |                     | 0.011818333333334928 |                     |                       |\n|     |       |           | -0.5715209999999994 |                      |                     |                       |\n| 4   | 2.2   | 0.1103623 |                     |                      |                     |                       |\n\nPolinom hasil foward DD:\n-0.483705666666666⋅x + (0.108733888888889 - 0.108733888888889⋅x)⋅(x - 1.3) + (\n0.00182510288066044⋅x - 0.00182510288066044)⋅(x - 1.9)⋅(x - 1.6)⋅(x - 1.3) + (\n0.0658783950617283⋅x - 0.0658783950617283)⋅(x - 1.6)⋅(x - 1.3) + 1.24890336666\n667\n\ndisederhanakan:\n                     4                       3                      2         \n0.00182510288066044⋅x  + 0.0552927983538978⋅x  - 0.343046604938247⋅x  + 0.0733\n\n                                  \n913477366034⋅x + 0.977735055967085\n\nPolinom hasil backward DD:\n-0.571520999999999⋅x + (0.00182510288066044⋅x - 0.00237263374485857)⋅(x - 2.2)\n⋅(x - 1.9)⋅(x - 1.6) + (0.0118183333333349⋅x - 0.0224548333333364)⋅(x - 2.2) +\n (0.0680685185185209⋅x - 0.108909629629633)⋅(x - 2.2)⋅(x - 1.9) + 1.3677085\n\ndisederhanakan:\n                     4                       3                      2         \n0.00182510288066044⋅x  + 0.0552927983538978⋅x  - 0.343046604938247⋅x  + 0.0733\n\n                                  \n913477366035⋅x + 0.977735055967086\n\nAproksimasi nilai fungsi di x = 1.5 adalah : \nForward DD : 0.5118199942386829\nBackward DD : 0.511819994238684"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul3.html",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul3.html",
    "title": "Modul 3 Sains Data",
    "section": "",
    "text": "Kembali ke Sains Data\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nInstall scikit-learn dengan:\n!pip install scikit-learn\nLalu import sklearn:\nimport sklearn"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul3.html#import-dataset",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul3.html#import-dataset",
    "title": "Modul 3 Sains Data",
    "section": "Import Dataset",
    "text": "Import Dataset\nUntuk praktikum kali ini, kita akan menggunakan dataset “California Housing Prices” (housing.csv) yang bisa didownload dari salah satu sumber berikut:\n\nDirect link (langsung dari GitHub Pages ini)\nKaggle: https://www.kaggle.com/datasets/camnugent/california-housing-prices\n\nKemudian, baca sebagai dataframe:\n\ndf = pd.read_csv(\"./housing.csv\")\n\nMari kita lihat isinya:\n\ndf\n\n\n\n\n\n\n\n\nlongitude\nlatitude\nhousing_median_age\ntotal_rooms\ntotal_bedrooms\npopulation\nhouseholds\nmedian_income\nmedian_house_value\nocean_proximity\n\n\n\n\n0\n-122.23\n37.88\n41.0\n880.0\n129.0\n322.0\n126.0\n8.3252\n452600.0\nNEAR BAY\n\n\n1\n-122.22\n37.86\n21.0\n7099.0\n1106.0\n2401.0\n1138.0\n8.3014\n358500.0\nNEAR BAY\n\n\n2\n-122.24\n37.85\n52.0\n1467.0\n190.0\n496.0\n177.0\n7.2574\n352100.0\nNEAR BAY\n\n\n3\n-122.25\n37.85\n52.0\n1274.0\n235.0\n558.0\n219.0\n5.6431\n341300.0\nNEAR BAY\n\n\n4\n-122.25\n37.85\n52.0\n1627.0\n280.0\n565.0\n259.0\n3.8462\n342200.0\nNEAR BAY\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n20635\n-121.09\n39.48\n25.0\n1665.0\n374.0\n845.0\n330.0\n1.5603\n78100.0\nINLAND\n\n\n20636\n-121.21\n39.49\n18.0\n697.0\n150.0\n356.0\n114.0\n2.5568\n77100.0\nINLAND\n\n\n20637\n-121.22\n39.43\n17.0\n2254.0\n485.0\n1007.0\n433.0\n1.7000\n92300.0\nINLAND\n\n\n20638\n-121.32\n39.43\n18.0\n1860.0\n409.0\n741.0\n349.0\n1.8672\n84700.0\nINLAND\n\n\n20639\n-121.24\n39.37\n16.0\n2785.0\n616.0\n1387.0\n530.0\n2.3886\n89400.0\nINLAND\n\n\n\n\n20640 rows × 10 columns\n\n\n\nAda satu data kategorik, yaitu ocean_proximity. Mari kita liat jenis-jenisnya (kategorinya):\n\ndf[\"ocean_proximity\"].value_counts()\n\nocean_proximity\n&lt;1H OCEAN     9136\nINLAND        6551\nNEAR OCEAN    2658\nNEAR BAY      2290\nISLAND           5\nName: count, dtype: int64\n\n\nApakah ada missing value?\n\ndf.isna().sum()\n\nlongitude               0\nlatitude                0\nhousing_median_age      0\ntotal_rooms             0\ntotal_bedrooms        207\npopulation              0\nhouseholds              0\nmedian_income           0\nmedian_house_value      0\nocean_proximity         0\ndtype: int64\n\n\n\ndf[df[\"total_bedrooms\"].isna()]\n\n\n\n\n\n\n\n\nlongitude\nlatitude\nhousing_median_age\ntotal_rooms\ntotal_bedrooms\npopulation\nhouseholds\nmedian_income\nmedian_house_value\nocean_proximity\n\n\n\n\n290\n-122.16\n37.77\n47.0\n1256.0\nNaN\n570.0\n218.0\n4.3750\n161900.0\nNEAR BAY\n\n\n341\n-122.17\n37.75\n38.0\n992.0\nNaN\n732.0\n259.0\n1.6196\n85100.0\nNEAR BAY\n\n\n538\n-122.28\n37.78\n29.0\n5154.0\nNaN\n3741.0\n1273.0\n2.5762\n173400.0\nNEAR BAY\n\n\n563\n-122.24\n37.75\n45.0\n891.0\nNaN\n384.0\n146.0\n4.9489\n247100.0\nNEAR BAY\n\n\n696\n-122.10\n37.69\n41.0\n746.0\nNaN\n387.0\n161.0\n3.9063\n178400.0\nNEAR BAY\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n20267\n-119.19\n34.20\n18.0\n3620.0\nNaN\n3171.0\n779.0\n3.3409\n220500.0\nNEAR OCEAN\n\n\n20268\n-119.18\n34.19\n19.0\n2393.0\nNaN\n1938.0\n762.0\n1.6953\n167400.0\nNEAR OCEAN\n\n\n20372\n-118.88\n34.17\n15.0\n4260.0\nNaN\n1701.0\n669.0\n5.1033\n410700.0\n&lt;1H OCEAN\n\n\n20460\n-118.75\n34.29\n17.0\n5512.0\nNaN\n2734.0\n814.0\n6.6073\n258100.0\n&lt;1H OCEAN\n\n\n20484\n-118.72\n34.28\n17.0\n3051.0\nNaN\n1705.0\n495.0\n5.7376\n218600.0\n&lt;1H OCEAN\n\n\n\n\n207 rows × 10 columns\n\n\n\nPerhatikan bahwa tipe datanya adalah int64 atau bilangan bulat.\nDari 20640 baris, ada satu kolom/fitur (total_bedrooms) dengan 207 missing value.\nSecara umum, ada dua cara untuk menangani missing value:\n\nMenghapus baris-baris yang memiliki missing value, dengan df.dropna()\nMelakukan metode imputasi\n\nKarena banyaknya missing value relatif sedikit, sebenarnya tidak masalah apabila baris-baris tersebut cukup dihapus saja. Namun, kita akan mempelajari metode imputasi."
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul3.html#encoding-data-kategorik",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul3.html#encoding-data-kategorik",
    "title": "Modul 3 Sains Data",
    "section": "Encoding Data Kategorik",
    "text": "Encoding Data Kategorik\nSebelum kita membahas metode imputasi, kita akan membahas tentang melakukan “encoding” untuk data kategorik.\nBanyak metode sains data / machine learning yang hanya bisa digunakan dengan data numerik. Oleh karena itu, data kategorik perlu diubah terlebih dahulu menjadi data numerik, melakukan yang namanya categorical data encoding\nMetode yang sering digunakan adalah one hot encoding. Misalnya ada satu fitur kategorik dengan \\(n\\) kemungkinan data, bernama \\(D_i\\) untuk \\(i = 1, 2, \\dots, n\\). Maka fitur tersebut diganti dengan \\(n\\) kolom baru, misal bernama \\(K_i\\) untuk \\(i = 1, 2, \\dots, n\\), di mana pada kolom ke-i, isinya adalah\n\n\\(1\\), apabila data aslinya pada baris tersebut adalah \\(D_i\\)\n\\(0\\) apabila bukan \\(D_i\\)\n\n\nfrom sklearn.preprocessing import OneHotEncoder\n\n\nencoder = OneHotEncoder()\n\n\nhasil_onehot = encoder.fit_transform(df[[\"ocean_proximity\"]])\n\n\nprint(encoder.categories_)\n\n[array(['&lt;1H OCEAN', 'INLAND', 'ISLAND', 'NEAR BAY', 'NEAR OCEAN'],\n      dtype=object)]\n\n\n\nprint(encoder.categories_[0])\n\n['&lt;1H OCEAN' 'INLAND' 'ISLAND' 'NEAR BAY' 'NEAR OCEAN']\n\n\n\nkolom_encoding = list(encoder.categories_[0])\n\n\nprint(kolom_encoding)\n\n['&lt;1H OCEAN', 'INLAND', 'ISLAND', 'NEAR BAY', 'NEAR OCEAN']\n\n\n\nonehot_array = hasil_onehot.toarray()\n\n\nprint(onehot_array)\n\n[[0. 0. 0. 1. 0.]\n [0. 0. 0. 1. 0.]\n [0. 0. 0. 1. 0.]\n ...\n [0. 1. 0. 0. 0.]\n [0. 1. 0. 0. 0.]\n [0. 1. 0. 0. 0.]]\n\n\n\nonehot_df = pd.DataFrame(onehot_array, columns=kolom_encoding)\n\n\nonehot_df\n\n\n\n\n\n\n\n\n&lt;1H OCEAN\nINLAND\nISLAND\nNEAR BAY\nNEAR OCEAN\n\n\n\n\n0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n1\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n2\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n3\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n4\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n...\n...\n...\n...\n...\n...\n\n\n20635\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20636\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20637\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20638\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20639\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n\n\n20640 rows × 5 columns\n\n\n\n\ndf = pd.concat([df, onehot_df], axis=1)\n\n\ndf\n\n\n\n\n\n\n\n\nlongitude\nlatitude\nhousing_median_age\ntotal_rooms\ntotal_bedrooms\npopulation\nhouseholds\nmedian_income\nmedian_house_value\nocean_proximity\n&lt;1H OCEAN\nINLAND\nISLAND\nNEAR BAY\nNEAR OCEAN\n\n\n\n\n0\n-122.23\n37.88\n41.0\n880.0\n129.0\n322.0\n126.0\n8.3252\n452600.0\nNEAR BAY\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n1\n-122.22\n37.86\n21.0\n7099.0\n1106.0\n2401.0\n1138.0\n8.3014\n358500.0\nNEAR BAY\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n2\n-122.24\n37.85\n52.0\n1467.0\n190.0\n496.0\n177.0\n7.2574\n352100.0\nNEAR BAY\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n3\n-122.25\n37.85\n52.0\n1274.0\n235.0\n558.0\n219.0\n5.6431\n341300.0\nNEAR BAY\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n4\n-122.25\n37.85\n52.0\n1627.0\n280.0\n565.0\n259.0\n3.8462\n342200.0\nNEAR BAY\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n20635\n-121.09\n39.48\n25.0\n1665.0\n374.0\n845.0\n330.0\n1.5603\n78100.0\nINLAND\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20636\n-121.21\n39.49\n18.0\n697.0\n150.0\n356.0\n114.0\n2.5568\n77100.0\nINLAND\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20637\n-121.22\n39.43\n17.0\n2254.0\n485.0\n1007.0\n433.0\n1.7000\n92300.0\nINLAND\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20638\n-121.32\n39.43\n18.0\n1860.0\n409.0\n741.0\n349.0\n1.8672\n84700.0\nINLAND\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20639\n-121.24\n39.37\n16.0\n2785.0\n616.0\n1387.0\n530.0\n2.3886\n89400.0\nINLAND\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n\n\n20640 rows × 15 columns\n\n\n\n\ndf = df.drop([\"ocean_proximity\"], axis=1)\n\n\ndf\n\n\n\n\n\n\n\n\nlongitude\nlatitude\nhousing_median_age\ntotal_rooms\ntotal_bedrooms\npopulation\nhouseholds\nmedian_income\nmedian_house_value\n&lt;1H OCEAN\nINLAND\nISLAND\nNEAR BAY\nNEAR OCEAN\n\n\n\n\n0\n-122.23\n37.88\n41.0\n880.0\n129.0\n322.0\n126.0\n8.3252\n452600.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n1\n-122.22\n37.86\n21.0\n7099.0\n1106.0\n2401.0\n1138.0\n8.3014\n358500.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n2\n-122.24\n37.85\n52.0\n1467.0\n190.0\n496.0\n177.0\n7.2574\n352100.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n3\n-122.25\n37.85\n52.0\n1274.0\n235.0\n558.0\n219.0\n5.6431\n341300.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n4\n-122.25\n37.85\n52.0\n1627.0\n280.0\n565.0\n259.0\n3.8462\n342200.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n20635\n-121.09\n39.48\n25.0\n1665.0\n374.0\n845.0\n330.0\n1.5603\n78100.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20636\n-121.21\n39.49\n18.0\n697.0\n150.0\n356.0\n114.0\n2.5568\n77100.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20637\n-121.22\n39.43\n17.0\n2254.0\n485.0\n1007.0\n433.0\n1.7000\n92300.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20638\n-121.32\n39.43\n18.0\n1860.0\n409.0\n741.0\n349.0\n1.8672\n84700.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20639\n-121.24\n39.37\n16.0\n2785.0\n616.0\n1387.0\n530.0\n2.3886\n89400.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n\n\n20640 rows × 14 columns"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul3.html#metode-imputasi",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul3.html#metode-imputasi",
    "title": "Modul 3 Sains Data",
    "section": "Metode Imputasi",
    "text": "Metode Imputasi\n\nMedian\n\ndf_fill_median = df.copy()\n\n\ndf[\"total_bedrooms\"].median()\n\n435.0\n\n\n\nbedrooms_median = df[\"total_bedrooms\"].median()\nprint(bedrooms_median)\n\n435.0\n\n\n\ndf_fill_median[\"total_bedrooms\"] = df_fill_median[\"total_bedrooms\"].fillna(bedrooms_median)\n\n\ndf_fill_median.isna().sum()\n\nlongitude             0\nlatitude              0\nhousing_median_age    0\ntotal_rooms           0\ntotal_bedrooms        0\npopulation            0\nhouseholds            0\nmedian_income         0\nmedian_house_value    0\n&lt;1H OCEAN             0\nINLAND                0\nISLAND                0\nNEAR BAY              0\nNEAR OCEAN            0\ndtype: int64\n\n\nCara lain, menggunakan scikit-learn:\n\ndf_fill_median2 = df.copy()\n\n\nfrom sklearn.impute import SimpleImputer\n\n\nmedian_imputer = SimpleImputer(\n    missing_values=np.nan, strategy='median'\n)\n\n\ndf_fill_median2[[\"total_bedrooms\"]] = median_imputer.fit_transform(\n    df_fill_median2[[\"total_bedrooms\"]]\n)\n\n\ndf_fill_median2.isna().sum()\n\nlongitude             0\nlatitude              0\nhousing_median_age    0\ntotal_rooms           0\ntotal_bedrooms        0\npopulation            0\nhouseholds            0\nmedian_income         0\nmedian_house_value    0\n&lt;1H OCEAN             0\nINLAND                0\nISLAND                0\nNEAR BAY              0\nNEAR OCEAN            0\ndtype: int64\n\n\n\n\nModus\n\ndf_fill_mode = df.copy()\n\n\ndf[\"total_bedrooms\"].mode()\n\n0    280.0\nName: total_bedrooms, dtype: float64\n\n\n\ndf[\"total_bedrooms\"].mode()[0]\n\n280.0\n\n\n\nbedrooms_mode = df[\"total_bedrooms\"].mode()[0]\nprint(bedrooms_mode)\n\n280.0\n\n\n\ndf_fill_mode[\"total_bedrooms\"] = df_fill_mode[\"total_bedrooms\"].fillna(bedrooms_mode)\n\n\ndf_fill_mode.isna().sum()\n\nlongitude             0\nlatitude              0\nhousing_median_age    0\ntotal_rooms           0\ntotal_bedrooms        0\npopulation            0\nhouseholds            0\nmedian_income         0\nmedian_house_value    0\n&lt;1H OCEAN             0\nINLAND                0\nISLAND                0\nNEAR BAY              0\nNEAR OCEAN            0\ndtype: int64\n\n\nCara lain, menggunakan scikit-learn:\n\ndf_fill_mode2 = df.copy()\n\n\nmode_imputer = SimpleImputer(\n    missing_values=np.nan, strategy='most_frequent'\n)\n\n\ndf_fill_mode2[[\"total_bedrooms\"]] = mode_imputer.fit_transform(\n    df_fill_mode2[[\"total_bedrooms\"]]\n)\n\n\ndf_fill_mode2.isna().sum()\n\nlongitude             0\nlatitude              0\nhousing_median_age    0\ntotal_rooms           0\ntotal_bedrooms        0\npopulation            0\nhouseholds            0\nmedian_income         0\nmedian_house_value    0\n&lt;1H OCEAN             0\nINLAND                0\nISLAND                0\nNEAR BAY              0\nNEAR OCEAN            0\ndtype: int64\n\n\n\n\nMean (rata-rata)\n\ndf_fill_mean = df.copy()\n\n\ndf_fill_mean[\"total_bedrooms\"].mean()\n\n537.8705525375618\n\n\n\nnp.round(df_fill_mean[\"total_bedrooms\"].mean())\n\n538.0\n\n\n\nbedrooms_mean = np.round(df_fill_mean[\"total_bedrooms\"].mean())\nprint(bedrooms_mean)\n\n538.0\n\n\n\ndf_fill_mean[\"total_bedrooms\"] = df_fill_mean[\"total_bedrooms\"].fillna(bedrooms_mean)\n\n\ndf_fill_mean.isna().sum()\n\nlongitude             0\nlatitude              0\nhousing_median_age    0\ntotal_rooms           0\ntotal_bedrooms        0\npopulation            0\nhouseholds            0\nmedian_income         0\nmedian_house_value    0\n&lt;1H OCEAN             0\nINLAND                0\nISLAND                0\nNEAR BAY              0\nNEAR OCEAN            0\ndtype: int64\n\n\nCara lain, menggunakan scikit-learn:\n\ndf_fill_mean2 = df.copy()\n\n\nmean_imputer = SimpleImputer(\n    missing_values=np.nan, strategy='mean'\n)\n\n\ndf_fill_mean2[[\"total_bedrooms\"]] = mean_imputer.fit_transform(\n    df_fill_mean2[[\"total_bedrooms\"]]\n)\n\n\ndf_fill_mean2.isna().sum()\n\nlongitude             0\nlatitude              0\nhousing_median_age    0\ntotal_rooms           0\ntotal_bedrooms        0\npopulation            0\nhouseholds            0\nmedian_income         0\nmedian_house_value    0\n&lt;1H OCEAN             0\nINLAND                0\nISLAND                0\nNEAR BAY              0\nNEAR OCEAN            0\ndtype: int64\n\n\n\n\nKNNImputer\n\nfrom sklearn.impute import KNNImputer\n\n\nknn_imputer = KNNImputer(n_neighbors=3)\n\n\ndf_fill_knn = df.copy()\n\nKNN Imputer memerlukan kolom-kolom lainnya sebagai acuan, dan hanya bisa bekerja dengan data numerik. Sehingga, kita perlu mem-filter terlebih dahulu kolom-kolom numerik dari dataset kita.\n\ndf_fill_knn.select_dtypes(include='number')\n\n\n\n\n\n\n\n\nlongitude\nlatitude\nhousing_median_age\ntotal_rooms\ntotal_bedrooms\npopulation\nhouseholds\nmedian_income\nmedian_house_value\n&lt;1H OCEAN\nINLAND\nISLAND\nNEAR BAY\nNEAR OCEAN\n\n\n\n\n0\n-122.23\n37.88\n41.0\n880.0\n129.0\n322.0\n126.0\n8.3252\n452600.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n1\n-122.22\n37.86\n21.0\n7099.0\n1106.0\n2401.0\n1138.0\n8.3014\n358500.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n2\n-122.24\n37.85\n52.0\n1467.0\n190.0\n496.0\n177.0\n7.2574\n352100.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n3\n-122.25\n37.85\n52.0\n1274.0\n235.0\n558.0\n219.0\n5.6431\n341300.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n4\n-122.25\n37.85\n52.0\n1627.0\n280.0\n565.0\n259.0\n3.8462\n342200.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n20635\n-121.09\n39.48\n25.0\n1665.0\n374.0\n845.0\n330.0\n1.5603\n78100.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20636\n-121.21\n39.49\n18.0\n697.0\n150.0\n356.0\n114.0\n2.5568\n77100.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20637\n-121.22\n39.43\n17.0\n2254.0\n485.0\n1007.0\n433.0\n1.7000\n92300.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20638\n-121.32\n39.43\n18.0\n1860.0\n409.0\n741.0\n349.0\n1.8672\n84700.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20639\n-121.24\n39.37\n16.0\n2785.0\n616.0\n1387.0\n530.0\n2.3886\n89400.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n\n\n20640 rows × 14 columns\n\n\n\n\ndf_fill_knn.select_dtypes(include='number').columns\n\nIndex(['longitude', 'latitude', 'housing_median_age', 'total_rooms',\n       'total_bedrooms', 'population', 'households', 'median_income',\n       'median_house_value', '&lt;1H OCEAN', 'INLAND', 'ISLAND', 'NEAR BAY',\n       'NEAR OCEAN'],\n      dtype='object')\n\n\n\nnum_col = df_fill_knn.select_dtypes(include='number').columns\n\n\ndf_fill_knn[num_col] = knn_imputer.fit_transform(df_fill_knn[num_col])\n\n\ndf_fill_knn.isna().sum()\n\nlongitude             0\nlatitude              0\nhousing_median_age    0\ntotal_rooms           0\ntotal_bedrooms        0\npopulation            0\nhouseholds            0\nmedian_income         0\nmedian_house_value    0\n&lt;1H OCEAN             0\nINLAND                0\nISLAND                0\nNEAR BAY              0\nNEAR OCEAN            0\ndtype: int64"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul3.html#perbandingan-metode-imputasi",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul3.html#perbandingan-metode-imputasi",
    "title": "Modul 3 Sains Data",
    "section": "Perbandingan Metode Imputasi",
    "text": "Perbandingan Metode Imputasi\nKita bisa membandingkan beberapa metode imputasi (dan memilih yang mana yang terbaik) dengan langkah-langkah berikut.\n\nUse a sample of your own dataset that does not contain any missing data (will serve as ground truth).\nIntroduce increasing proportions of missing data at random (e.g. 5–50 % in 5 % increments).\nReconstruct the missing data using the various methods.\nCompute the sum of squared errors between the reconstructed and the original data, for each method and each proportion of missing data.\n\nLangkah pertama, kita perlu memperoleh sample dari dataset kita yang tidak mengandung missing value, yang bisa disebut ground truth. Cara termudah adalah dengan menghapus baris-baris yang memiliki missing value (biasanya dipilih lagi sample hanya sebagian baris, tapi di sini tidak kita lakukan):\n\ndf_ground_truth = df.dropna()\n\n\ndf_ground_truth\n\n\n\n\n\n\n\n\nlongitude\nlatitude\nhousing_median_age\ntotal_rooms\ntotal_bedrooms\npopulation\nhouseholds\nmedian_income\nmedian_house_value\n&lt;1H OCEAN\nINLAND\nISLAND\nNEAR BAY\nNEAR OCEAN\n\n\n\n\n0\n-122.23\n37.88\n41.0\n880.0\n129.0\n322.0\n126.0\n8.3252\n452600.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n1\n-122.22\n37.86\n21.0\n7099.0\n1106.0\n2401.0\n1138.0\n8.3014\n358500.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n2\n-122.24\n37.85\n52.0\n1467.0\n190.0\n496.0\n177.0\n7.2574\n352100.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n3\n-122.25\n37.85\n52.0\n1274.0\n235.0\n558.0\n219.0\n5.6431\n341300.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n4\n-122.25\n37.85\n52.0\n1627.0\n280.0\n565.0\n259.0\n3.8462\n342200.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n20635\n-121.09\n39.48\n25.0\n1665.0\n374.0\n845.0\n330.0\n1.5603\n78100.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20636\n-121.21\n39.49\n18.0\n697.0\n150.0\n356.0\n114.0\n2.5568\n77100.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20637\n-121.22\n39.43\n17.0\n2254.0\n485.0\n1007.0\n433.0\n1.7000\n92300.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20638\n-121.32\n39.43\n18.0\n1860.0\n409.0\n741.0\n349.0\n1.8672\n84700.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20639\n-121.24\n39.37\n16.0\n2785.0\n616.0\n1387.0\n530.0\n2.3886\n89400.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n\n\n20433 rows × 14 columns\n\n\n\nSelanjutnya, kita perlu membolong-bolongi dataset ini, agar sekian persen diisi missing value.\n\nimport random\n\n\ndef missing_value_generator(df_original, percentage):\n    df_miss = df_original.copy()\n    baris, kolom = df_miss.shape\n    n_total = baris*kolom\n\n    permutasi = list(range(n_total))\n    random.shuffle(permutasi)\n\n    n_pilih = int(percentage * n_total)\n    pilihan = permutasi[0 : n_pilih]\n\n    for p in pilihan:\n        df_miss.iloc[ int(p/kolom), p%kolom ] = np.nan\n    \n    return df_miss\n\n\ndf_miss_5 = missing_value_generator(df, 0.05)\n\n\ndf_miss_5.isna().sum()\n\nlongitude             1021\nlatitude              1015\nhousing_median_age    1064\ntotal_rooms           1004\ntotal_bedrooms        1205\npopulation            1087\nhouseholds            1032\nmedian_income         1004\nmedian_house_value    1018\n&lt;1H OCEAN             1050\nINLAND                1023\nISLAND                1085\nNEAR BAY              1051\nNEAR OCEAN             981\ndtype: int64\n\n\n\ndef compare_imputation(df_ground_truth, methods, percentages):\n    list_missing_df = []\n    for percent in percentages:\n        df_miss = missing_value_generator(df_ground_truth, percent)\n        list_missing_df.append(df_miss)\n\n    all_results = []\n    for method in methods:\n        method_results = []\n        for df_miss in list_missing_df:\n            df_imputed = method.fit_transform(df_miss)\n            SSE = ((df_ground_truth - df_imputed)**2).sum().sum()\n            method_results.append(SSE)\n        all_results.append(method_results)\n\n    return all_results\n\n\nmedian_imputer = SimpleImputer(missing_values=np.nan, strategy='median')\nmean_imputer = SimpleImputer(missing_values=np.nan, strategy='mean')\nmode_imputer = SimpleImputer(missing_values=np.nan, strategy=\"most_frequent\")\n\n\nlist_persen = [0.05, 0.10, 0.15, 0.20, 0.25]\n\n\nall_results = compare_imputation(\n    df_ground_truth,\n    [median_imputer, mean_imputer, mode_imputer],\n    list_persen\n)\n\n\nall_results\n\n[[16106399718053.193,\n  27686624654974.12,\n  42067852690522.375,\n  57674869517426.2,\n  71398507402041.0],\n [15149962314993.664,\n  26691038947100.4,\n  39993567341678.87,\n  54874386927172.04,\n  67502299532092.21],\n [104263768244576.97,\n  200631901715894.3,\n  302872434183477.3,\n  413821496079702.0,\n  502638602704461.3]]\n\n\n\nprint(\"Median:\", all_results[0])\nprint(\"Mean:\", all_results[1])\nprint(\"Mode:\", all_results[2])\n\nMedian: [16106399718053.193, 27686624654974.12, 42067852690522.375, 57674869517426.2, 71398507402041.0]\nMean: [15149962314993.664, 26691038947100.4, 39993567341678.87, 54874386927172.04, 67502299532092.21]\nMode: [104263768244576.97, 200631901715894.3, 302872434183477.3, 413821496079702.0, 502638602704461.3]\n\n\n\nplt.plot(list_persen, all_results[0])\nplt.plot(list_persen, all_results[1])\nplt.plot(list_persen, all_results[2])\nplt.legend([\"Median\", \"Mean\", \"Mode\"])\nplt.show()\n\n\n\n\nDari hasil tersebut, didapat bahwa secara keseluruhan, untuk setiap persentase missing values, metode imputasi dengan menggunakan mean menghasilkan SSE yang terkecil dibandingkan imputasi dengan median dan modus. Oleh karena itu, kita akan menggunakan metode imputasi menggunakan mean untuk mengisi missing value pada kolom “total_bedrooms” dari df asli.\n\n# melihat kembali df awal\ndf\n\n\n\n\n\n\n\n\nlongitude\nlatitude\nhousing_median_age\ntotal_rooms\ntotal_bedrooms\npopulation\nhouseholds\nmedian_income\nmedian_house_value\n&lt;1H OCEAN\nINLAND\nISLAND\nNEAR BAY\nNEAR OCEAN\n\n\n\n\n0\n-122.23\n37.88\n41.0\n880.0\n129.0\n322.0\n126.0\n8.3252\n452600.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n1\n-122.22\n37.86\n21.0\n7099.0\n1106.0\n2401.0\n1138.0\n8.3014\n358500.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n2\n-122.24\n37.85\n52.0\n1467.0\n190.0\n496.0\n177.0\n7.2574\n352100.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n3\n-122.25\n37.85\n52.0\n1274.0\n235.0\n558.0\n219.0\n5.6431\n341300.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n4\n-122.25\n37.85\n52.0\n1627.0\n280.0\n565.0\n259.0\n3.8462\n342200.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n20635\n-121.09\n39.48\n25.0\n1665.0\n374.0\n845.0\n330.0\n1.5603\n78100.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20636\n-121.21\n39.49\n18.0\n697.0\n150.0\n356.0\n114.0\n2.5568\n77100.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20637\n-121.22\n39.43\n17.0\n2254.0\n485.0\n1007.0\n433.0\n1.7000\n92300.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20638\n-121.32\n39.43\n18.0\n1860.0\n409.0\n741.0\n349.0\n1.8672\n84700.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20639\n-121.24\n39.37\n16.0\n2785.0\n616.0\n1387.0\n530.0\n2.3886\n89400.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n\n\n20640 rows × 14 columns\n\n\n\n\ndf.isna().sum()\n\nlongitude               0\nlatitude                0\nhousing_median_age      0\ntotal_rooms             0\ntotal_bedrooms        207\npopulation              0\nhouseholds              0\nmedian_income           0\nmedian_house_value      0\n&lt;1H OCEAN               0\nINLAND                  0\nISLAND                  0\nNEAR BAY                0\nNEAR OCEAN              0\ndtype: int64\n\n\n\n# lakukan imputasi dengan metode terbaik yg telah didapat, yaitu dengan mean\n\ndf[['total_bedrooms']] = mean_imputer.fit_transform(df[['total_bedrooms']] )\n\n\ndf\n\n\n\n\n\n\n\n\nlongitude\nlatitude\nhousing_median_age\ntotal_rooms\ntotal_bedrooms\npopulation\nhouseholds\nmedian_income\nmedian_house_value\n&lt;1H OCEAN\nINLAND\nISLAND\nNEAR BAY\nNEAR OCEAN\n\n\n\n\n0\n-122.23\n37.88\n41.0\n880.0\n129.0\n322.0\n126.0\n8.3252\n452600.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n1\n-122.22\n37.86\n21.0\n7099.0\n1106.0\n2401.0\n1138.0\n8.3014\n358500.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n2\n-122.24\n37.85\n52.0\n1467.0\n190.0\n496.0\n177.0\n7.2574\n352100.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n3\n-122.25\n37.85\n52.0\n1274.0\n235.0\n558.0\n219.0\n5.6431\n341300.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n4\n-122.25\n37.85\n52.0\n1627.0\n280.0\n565.0\n259.0\n3.8462\n342200.0\n0.0\n0.0\n0.0\n1.0\n0.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n20635\n-121.09\n39.48\n25.0\n1665.0\n374.0\n845.0\n330.0\n1.5603\n78100.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20636\n-121.21\n39.49\n18.0\n697.0\n150.0\n356.0\n114.0\n2.5568\n77100.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20637\n-121.22\n39.43\n17.0\n2254.0\n485.0\n1007.0\n433.0\n1.7000\n92300.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20638\n-121.32\n39.43\n18.0\n1860.0\n409.0\n741.0\n349.0\n1.8672\n84700.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n20639\n-121.24\n39.37\n16.0\n2785.0\n616.0\n1387.0\n530.0\n2.3886\n89400.0\n0.0\n1.0\n0.0\n0.0\n0.0\n\n\n\n\n20640 rows × 14 columns\n\n\n\n\ndf.isna().sum()\n\nlongitude             0\nlatitude              0\nhousing_median_age    0\ntotal_rooms           0\ntotal_bedrooms        0\npopulation            0\nhouseholds            0\nmedian_income         0\nmedian_house_value    0\n&lt;1H OCEAN             0\nINLAND                0\nISLAND                0\nNEAR BAY              0\nNEAR OCEAN            0\ndtype: int64\n\n\n\nExport Dataframe yang telah diimputasi ke CSV\n\ndf.to_csv(\"housing_modified.csv\")"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/saindat/modul3.html#regresi-linier",
    "href": "semuahalaman/modulprak/2024/genap/saindat/modul3.html#regresi-linier",
    "title": "Modul 3 Sains Data",
    "section": "Regresi Linier",
    "text": "Regresi Linier"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul3.html",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul3.html",
    "title": "Modul 3 Persamaan Diferensial Numerik",
    "section": "",
    "text": "Kembali ke Persamaan Diferensial Numerik"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul3.html#format-long",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul3.html#format-long",
    "title": "Modul 3 Persamaan Diferensial Numerik",
    "section": "Format long",
    "text": "Format long\n\nsin(pi/4)\n\nans = 0.7071\n\n\n\nformat long\n\n\nsin(pi/4)\n\nans = 0.707106781186547\n\n\nKembali ke default:\n\nformat\n\n\nsin(pi/4)\n\nans = 0.7071"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul3.html#metode-runge-kutta-dan-variasinya",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul3.html#metode-runge-kutta-dan-variasinya",
    "title": "Modul 3 Persamaan Diferensial Numerik",
    "section": "Metode Runge-Kutta dan variasinya",
    "text": "Metode Runge-Kutta dan variasinya\n\nOrde 2: Metode Midpoint\n\\[w_1=\\alpha\\] \\[w_{i+1}=w_i+h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{h}{2} f\\left(t_i, w_i\\right)\\right)\\]\nbisa juga ditulis,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[w_{i+1}=w_i+h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{h}{2} m_1\\right)\\]\natau bahkan,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[m_2 = f\\left(t_i+\\frac{h}{2}, w_i+\\frac{h}{2} m_1\\right)\\] \\[w_{i+1}=w_i+h m_2\\]\n\nfunction [t, w] = midpoint(f, a, b, N, alpha)\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1 : N\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i) + (h / 2), w(i) + (h / 2) * m1);\n    w(i + 1) = w(i) + h * m2;\n  endfor\nendfunction\n\nMisalkan diberikan MNA sebagai berikut, yang ingin diselesaikan secara numerik dengan \\(N = 10\\):\n\\[y' = y - t^2 + 1\\] \\[0 \\le t \\le 2\\] \\[y(0) = 0.5\\]\nyang kebetulan memiliki solusi eksak:\n\\[y\\left(t\\right) = \\left( t + 1 \\right)^2 - 0.5 e^t\\]\nContoh penggunaan:\n\nf = @(t, y) (y - t .^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\n\n[t, w] = midpoint(f, a, b, 10, alpha);\n\nsln = @(t) (t + 1) .^ 2 - 0.5 * exp(t);\ny_eksak = sln(t);\n\nerr_midpoint = abs(w - y_eksak);\n\n[t, w, y_eksak, err_midpoint]\n\nhold on;\nfplot(sln, [a, b], 'b');\nscatter(t, w, 500, 'r');\nlegend(\"Solusi Eksak\", \"Metode Midpoint\");\n\nans =\n\n        0   0.5000   0.5000        0\n   0.2000   0.8280   0.8293   0.0013\n   0.4000   1.2114   1.2141   0.0027\n   0.6000   1.6447   1.6489   0.0043\n   0.8000   2.1213   2.1272   0.0059\n   1.0000   2.6332   2.6409   0.0077\n   1.2000   3.1705   3.1799   0.0095\n   1.4000   3.7212   3.7324   0.0112\n   1.6000   4.2706   4.2835   0.0129\n   1.8000   4.8010   4.8152   0.0142\n   2.0000   5.2904   5.3055   0.0151\n\n\n\n\n\n\n\n\nOrde 2: Metode Modified Euler\n\\[w_1=\\alpha\\] \\[w_{i+1}=w_i+\\frac{h}{2}\\left(f\\left(t_i, w_i\\right)+f\\left(t_{i+1}, w_i+h f\\left(t_i, w_i\\right)\\right)\\right)\\]\nbisa juga ditulis,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[w_{i+1}=w_i+\\frac{h}{2}\\left(m_1+f\\left(t_{i+1}, w_i+h m_1\\right)\\right)\\]\natau bahkan,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[m_2 = f\\left(t_{i+1}, w_i+h m_1\\right)\\] \\[w_{i+1}=w_i+\\frac{h}{2}\\left(m_1+m_2\\right)\\]\n\nfunction [t, w] = modified_euler(f, a, b, N, alpha)\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1 : N\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i + 1), w(i) + h * m1);\n    w(i + 1) = w(i) + h * (m1 + m2) / 2;\n  endfor\nendfunction\n\nMisalkan diberikan MNA sebagai berikut, yang ingin diselesaikan secara numerik dengan \\(N = 10\\):\n\\[y' = y - t^2 + 1\\] \\[0 \\le t \\le 2\\] \\[y(0) = 0.5\\]\ndan misalkan solusi eksak tidak diketahui.\nContoh penggunaan (perbandingan metode Runge-Kutta orde 2):\n\nf = @(t, y) (y - t .^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\n\n[t1, w1] = midpoint(f, a, b, 10, alpha);\n[t2, w2] = modified_euler(f, a, b, 10, alpha);\n\n[t1, w1, w2]\n\nhold on;\nscatter(t1, w1, 500, 'r');\nscatter(t2, w2, 500, 'g');\nlegend(\"Midpoint\", \"Modified Euler\");\n\nans =\n\n        0   0.5000   0.5000\n   0.2000   0.8280   0.8260\n   0.4000   1.2114   1.2069\n   0.6000   1.6447   1.6372\n   0.8000   2.1213   2.1102\n   1.0000   2.6332   2.6177\n   1.2000   3.1705   3.1496\n   1.4000   3.7212   3.6937\n   1.6000   4.2706   4.2351\n   1.8000   4.8010   4.7556\n   2.0000   5.2904   5.2331\n\n\n\n\n\n\nMisalkan diketahui solusi eksak:\n\\[y\\left(t\\right) = \\left( t + 1 \\right)^2 - 0.5 e^t\\]\nMaka kita juga bisa menghitung error dari masing-masing metode.\n\nf = @(t, y) (y - t .^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\n\n[t1, w1] = midpoint(f, a, b, 10, alpha);\n[t2, w2] = modified_euler(f, a, b, 10, alpha);\n\nsln = @(t) (t + 1) .^ 2 - 0.5 * exp(t);\ny_eksak = sln(t1);\n\nerr1 = abs(y_eksak - w1);\nerr2 = abs(y_eksak - w2);\n\n[t1, y_eksak, w1, err1, w2, err2]\n\nhold on;\nfplot(sln, [0, 2], 'b');\nscatter(t1, w1, 500, 'r');\nscatter(t2, w2, 500, 'g');\nlegend(\"Solusi Eksak\", \"Midpoint\", \"Modified Euler\");\n\nans =\n\n        0   0.5000   0.5000        0   0.5000        0\n   0.2000   0.8293   0.8280   0.0013   0.8260   0.0033\n   0.4000   1.2141   1.2114   0.0027   1.2069   0.0072\n   0.6000   1.6489   1.6447   0.0043   1.6372   0.0117\n   0.8000   2.1272   2.1213   0.0059   2.1102   0.0170\n   1.0000   2.6409   2.6332   0.0077   2.6177   0.0232\n   1.2000   3.1799   3.1705   0.0095   3.1496   0.0304\n   1.4000   3.7324   3.7212   0.0112   3.6937   0.0387\n   1.6000   4.2835   4.2706   0.0129   4.2351   0.0484\n   1.8000   4.8152   4.8010   0.0142   4.7556   0.0596\n   2.0000   5.3055   5.2904   0.0151   5.2331   0.0724\n\n\n\n\n\n\n\n\nOrde 3: Metode Heun\n\\[w_1=\\alpha\\] \\[w_{i+1}=w_i+\\frac{h}{4}\\left(f\\left(t_i, w_i\\right)+3 f\\left(t_i+\\frac{2 h}{3}, w_i+\\frac{2 h}{3} f\\left(t_i+\\frac{h}{3}, w_i+\\frac{h}{3} f\\left(t_i, w_i\\right)\\right)\\right)\\right)\\]\nbisa juga ditulis,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[w_{i+1}=w_i+\\frac{h}{4}\\left(m_1+3 f\\left(t_i+\\frac{2 h}{3}, w_i+\\frac{2 h}{3} f\\left(t_i+\\frac{h}{3}, w_i+\\frac{h}{3} m_1\\right)\\right)\\right)\\]\natau,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[m_2 = f\\left(t_i+\\frac{h}{3}, w_i+\\frac{h}{3} m_1\\right)\\] \\[w_{i+1}=w_i+\\frac{h}{4}\\left(m_1+3 f\\left(t_i+\\frac{2 h}{3}, w_i+\\frac{2 h}{3} m_2\\right)\\right)\\]\natau bahkan,\n\\[w_1=\\alpha\\] \\[m_1 = f\\left(t_i, w_i\\right)\\] \\[m_2 = f\\left(t_i+\\frac{h}{3}, w_i+\\frac{h}{3} m_1\\right)\\] \\[m_3 = f\\left(t_i+\\frac{2 h}{3}, w_i+\\frac{2 h}{3} m_2\\right)\\] \\[w_{i+1}=w_i+\\frac{h}{4}\\left(m_1+3 m_3\\right)\\]\n\nfunction [t, w] = heun(f, a, b, N, alpha)\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1 : N\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i) + (h / 3), w(i) + (h / 3) * m1);\n    m3 = f(t(i) + (2 * h / 3), w(i) + (2 * h / 3) * m2);\n    w(i + 1) = w(i) + (h / 4) * (m1 + 3 * m3);\n  endfor\nendfunction\n\nMisalkan diberikan MNA sebagai berikut, yang ingin diselesaikan secara numerik dengan \\(N = 10\\):\n\\[y' = y - t^2 + 1\\] \\[0 \\le t \\le 2\\] \\[y(0) = 0.5\\]\nyang kebetulan memiliki solusi eksak:\n\\[y\\left(t\\right) = \\left( t + 1 \\right)^2 - 0.5 e^t\\]\nContoh penggunaan:\n\nf = @(t, y) (y - t .^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\n\n[t, w] = heun(f, a, b, 10, alpha);\n\nsln = @(t) (t + 1) .^ 2 - 0.5 * exp(t);\ny_eksak = sln(t);\n\nerr_heun = abs(w - y_eksak);\n\n[t, w, y_eksak, err_heun]\n\nhold on;\nfplot(sln, [a, b], 'b');\nscatter(t, w, 500, 'r');\nlegend(\"Solusi Eksak\", \"Metode Heun\");\n\nans =\n\n        0   0.5000   0.5000        0\n   0.2000   0.8292   0.8293   0.0001\n   0.4000   1.2140   1.2141   0.0001\n   0.6000   1.6488   1.6489   0.0002\n   0.8000   2.1270   2.1272   0.0002\n   1.0000   2.6406   2.6409   0.0003\n   1.2000   3.1796   3.1799   0.0004\n   1.4000   3.7320   3.7324   0.0004\n   1.6000   4.2830   4.2835   0.0005\n   1.8000   4.8147   4.8152   0.0005\n   2.0000   5.3050   5.3055   0.0005\n\n\n\n\n\n\nTernyata errornya sangat kecil! KIta bisa melihat errornya dengan lebih detail/presisi, dengan menggunakan format long\n\nf = @(t, y) (y - t .^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\n\n[t, w] = heun(f, a, b, 10, alpha);\n\nsln = @(t) (t + 1) .^ 2 - 0.5 * exp(t);\ny_eksak = sln(t);\n\nerr_heun = abs(w - y_eksak);\n\nformat long; % pasang format output menjadi panjang (lebih presisi)\n[t, w, y_eksak, err_heun]\nformat; % kembali ke ukuran default\n\nhold on;\nfplot(sln, [a, b], 'b');\nscatter(t, w, 500, 'r');\nlegend(\"Solusi Eksak\", \"Metode Heun\");\n\nans =\n\n                   0   0.500000000000000   0.500000000000000                   0\n   0.200000000000000   0.829244444444444   0.829298620919915   0.000054176475471\n   0.400000000000000   1.213974992592593   1.214087651179365   0.000112658586772\n   0.600000000000000   1.648765902064198   1.648940599804746   0.000174697740548\n   0.800000000000000   2.126990532832184   2.127229535753766   0.000239002921582\n   1.000000000000000   2.640555548543485   2.640859085770478   0.000303537226992\n   1.200000000000000   3.179576287732221   3.179941538631727   0.000365250899506\n   1.400000000000000   3.731980283861397   3.732400016577663   0.000419732716265\n   1.600000000000000   4.283023031133831   4.283483787802441   0.000460756668610\n   1.800000000000000   4.814696573135897   4.815176267793527   0.000479694657630\n   2.000000000000000   5.305007192434419   5.305471950534676   0.000464758100256\n\n\n\n\n\n\n\n\nMetode Runge-Kutta orde 4\n\\[w_1=\\alpha\\] \\[k_1=h f\\left(t_i, w_i\\right)\\] \\[k_2=h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{k_1}{2}\\right)\\] \\[k_3=h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{k_2}{2}\\right)\\] \\[k_4=h f\\left(t_{i+1}, w_i+k_3\\right)\\] \\[w_{i+1}=w_i+\\frac{1}{6}\\left(k_1+2 k_2+2 k_3+k_4\\right)\\]\n\nfunction [t, w] = rko4(f, a, b, N, alpha)\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1 : N\n    t(i + 1) = t(i) + h;\n    k1 = h * f(t(i), w(i));\n    k2 = h * f(t(i) + (h / 2), w(i) + (k1 / 2));\n    k3 = h * f(t(i) + (h / 2), w(i) + (k2 / 2));\n    k4 = h * f(t(i + 1), w(i) + k3);\n    w(i + 1) = w(i) + (k1 + 2 * k2 + 2 * k3 + k4) / 6;\n  endfor\nendfunction\n\nMisalkan diberikan MNA sebagai berikut, yang ingin diselesaikan secara numerik dengan \\(N = 10\\):\n\\[y' = y - t^2 + 1\\] \\[0 \\le t \\le 2\\] \\[y(0) = 0.5\\]\nyang kebetulan memiliki solusi eksak:\n\\[y\\left(t\\right) = \\left( t + 1 \\right)^2 - 0.5 e^t\\]\n\nf = @(t, y) (y - t .^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\n\n[t, w] = rko4(f, a, b, 10, alpha);\n\nsln = @(t) (t + 1) .^ 2 - 0.5 * exp(t);\ny_eksak = sln(t);\n\nerr_rko4 = abs(w - y_eksak);\n\nformat long; % pasang format output menjadi panjang (lebih presisi)\n[t, w, y_eksak, err_rko4]\nformat; % kembali ke ukuran default\n\nhold on;\nfplot(sln, [a, b], 'b');\nscatter(t, w, 500, 'r');\nlegend(\"Solusi Eksak\", \"Metode Runge-Kutta orde 4\");\n\nans =\n\n                   0   0.500000000000000   0.500000000000000                   0\n   0.200000000000000   0.829293333333333   0.829298620919915   0.000005287586582\n   0.400000000000000   1.214076210666667   1.214087651179365   0.000011440512698\n   0.600000000000000   1.648922017041600   1.648940599804746   0.000018582763146\n   0.800000000000000   2.127202684947944   2.127229535753766   0.000026850805823\n   1.000000000000000   2.640822692728752   2.640859085770478   0.000036393041726\n   1.200000000000000   3.179894170232231   3.179941538631727   0.000047368399497\n   1.400000000000000   3.732340072854980   3.732400016577663   0.000059943722683\n   1.600000000000000   4.283409498318406   4.283483787802441   0.000074289484035\n   1.800000000000000   4.815085694579435   4.815176267793527   0.000090573214092\n   2.000000000000000   5.305363000692655   5.305471950534676   0.000108949842021\n\n\n\n\n\n\n\n\nPerbandingan metode Runge-Kutta orde 2, 3, 4\nMisalkan diberikan MNA sebagai berikut, yang ingin diselesaikan secara numerik dengan \\(N = 10\\):\n\\[y' = y - t^2 + 1\\] \\[0 \\le t \\le 2\\] \\[y(0) = 0.5\\]\nyang kebetulan memiliki solusi eksak:\n\\[y\\left(t\\right) = \\left( t + 1 \\right)^2 - 0.5 e^t\\]\n\nf = @(t, y) (y - t .^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\n\n[t1, w1] = midpoint(f, a, b, 10, alpha);\n[t2, w2] = modified_euler(f, a, b, 10, alpha);\n[t3, w3] = heun(f, a, b, 10, alpha);\n[t4, w4] = rko4(f, a, b, 10, alpha);\n\nsln = @(t) (t + 1) .^ 2 - 0.5 * exp(t);\ny_eksak = sln(t1);\n\n\n[t1, w1, w2, w3, w4, y_eksak]\n\nans =\n\n        0   0.5000   0.5000   0.5000   0.5000   0.5000\n   0.2000   0.8280   0.8260   0.8292   0.8293   0.8293\n   0.4000   1.2114   1.2069   1.2140   1.2141   1.2141\n   0.6000   1.6447   1.6372   1.6488   1.6489   1.6489\n   0.8000   2.1213   2.1102   2.1270   2.1272   2.1272\n   1.0000   2.6332   2.6177   2.6406   2.6408   2.6409\n   1.2000   3.1705   3.1496   3.1796   3.1799   3.1799\n   1.4000   3.7212   3.6937   3.7320   3.7323   3.7324\n   1.6000   4.2706   4.2351   4.2830   4.2834   4.2835\n   1.8000   4.8010   4.7556   4.8147   4.8151   4.8152\n   2.0000   5.2904   5.2331   5.3050   5.3054   5.3055\n\n\n\n\nhold on;\nfplot(sln, [0, 2], 'k');\nscatter(t1, w1, 'r');\nscatter(t2, w2, 'g');\nscatter(t3, w3, 'b');\nscatter(t4, w4, 'm');\nlegend('Fungsi eksak', 'Midpoint', 'Modified Euler', 'Heun', 'Runge-Kutta orde 4');\nlegend(\"location\", \"northwest\");\ntitle('Perbandingan metode Runge-Kutta orde 2, 3, 4');"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/pdnum/modul3.html#metode-multistep-eksplisit-metode-n-step-adams-bashforth",
    "href": "semuahalaman/modulprak/2024/genap/pdnum/modul3.html#metode-multistep-eksplisit-metode-n-step-adams-bashforth",
    "title": "Modul 3 Persamaan Diferensial Numerik",
    "section": "Metode Multistep Eksplisit: Metode \\(n\\)-step Adams-Bashforth",
    "text": "Metode Multistep Eksplisit: Metode \\(n\\)-step Adams-Bashforth\nMetode-metode sebelumnya, seperi Euler, Runge-Kutta, dan kawan-kawannya adalah metode jenis one-step, karena di tiap iterasinya kita hanya menggunakan informasi dari satu nilai \\(t_{i}\\). Berikut kita akan mulai membahas mengenai metode multistep, di mana kita menggunakan lebih dari satu nilai \\(t_{i}\\) untuk membuat aproksimasi.\nTerdapat dua jenis metode multistep, yaitu:\n\nMultistep eksplisit, di mana kita mengaproksimasi nilai pada \\(t_{i+1}\\) menggunakan nilai \\(t\\) sebelumnya.\nMultistep implisit, di mana kita mengaproksimasi nilai pada \\(t_{i+1}\\) menggunakan nilai pada \\(t\\) sebelumnya, sekaligus nilai pada \\(t_{i+1}\\) itu sendiri.\n\nMetode multistep eksplisit yang akan kita bahas adalah metode \\(n\\)-step Adams-Bashforth.\nMetode \\(n\\)-step Adams-Bashforth menggunakan \\(n\\) titik sebelumnya untuk mengaproksimasi nilai. Karena metode ini adalah metode multistep, maka \\(n\\) nilai awalnya pun harus diperoleh terlebih dahulu. Misal kita ingin menggunakan metode Adams-Bashforth orde 3 , maka \\(w_{1}, w_{2}\\), dan \\(w_{3}\\) harus ada terlebih dahulu sebelum dilanjutkan ke metode Adams-Bashforth. Nilai-nilai awal tersebut dapat diperoleh dari metode-metode one-step sebelumnya, seperti metode Runge-Kutta (biasanya digunakan metode Runge-Kutta orde 4).\nBerikut rumus untuk metode \\(n\\)-step Adams-Bashforth, masing-masing sesuai dengan jumlah step nya.\n\nTwo-step Adams-Bashforth\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\\\\nw_{i+1}=w_{i}+\\frac{h}{2}\\left[3 f\\left(t_{i}, w_{i}\\right)-f\\left(t_{i-1}, w_{i-1}\\right)\\right]\n\\end{gathered}\n\\]\nBisa ditulis:\n\\[\n\\begin{gathered}\nw_{1}=\\alpha, \\\\\nw_{2}=\\alpha_1 \\hspace{0.2cm} \\text{(hitung dengan metode Runge-Kutta orde 4)}, \\\\\nm_1 = f\\left(t_{i}, w_{i}\\right) \\\\\nm_2 = f\\left(t_{i-1}, w_{i-1}\\right) \\\\\nw_{i+1}=w_{i}+\\frac{h}{2}\\left[3 m_1-m_2\\right]\n\\end{gathered}\n\\]\n\nfunction [t, w] = adams_bashforth2(f, a, b, N, alpha)\n  % Inisiasi variabel awal\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  \n  % Hitung w(2) menggunakan metode Runge-Kutta orde 4\n  i = 1;\n  t(i + 1) = t(i) + h;\n  k1 = h * f(t(i), w(i));\n  k2 = h * f(t(i) + (h/2), w(i) + (k1/2));\n  k3 = h * f(t(i) + (h/2), w(i) + (k2/2));\n  k4 = h * f(t(i + 1), w(i) + k3);\n  w(i+1) = w(i) + (k1 + 2*k2 + 2*k3 + k4) / 6;\n  \n  % Algoritma utama Adams-Bashforth orde 2\n  for i = 2 : N\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i-1), w(i-1));\n    w(i+1) = w(i) + (h/2) * (3*m1 - m2);\n  endfor\nendfunction\n\nMisalkan diberikan MNA sebagai berikut, yang ingin diselesaikan secara numerik dengan \\(N = 10\\):\n\\[y' = y - t^2 + 1\\] \\[0 \\le t \\le 2\\] \\[y(0) = 0.5\\]\nyang kebetulan memiliki solusi eksak:\n\\[y\\left(t\\right) = \\left( t + 1 \\right)^2 - 0.5 e^t\\]\nContoh penggunaan:\n\nf = @(t, y) y - t .^ 2 + 1;\na = 0;\nb = 2;\nalpha = 0.5;\nN = 10;\n\n[t, w] = adams_bashforth2(f, a, b, N, alpha);\n\nsln = @(t) (t + 1) .^ 2 - 0.5 * exp(t);\ny_eksak = sln(t);\n\nerr_ab2 = abs(y_eksak - w);\n\n[t, w, y_eksak, err_ab2]\n\nhold on;\nfplot(sln, [0, 2], 'b');\nscatter(t1, w1, 'r');\n\nans =\n\n        0   0.5000   0.5000        0\n   0.2000   0.8293   0.8293   0.0000\n   0.4000   1.2161   1.2141   0.0020\n   0.6000   1.6540   1.6489   0.0050\n   0.8000   2.1366   2.1272   0.0093\n   1.0000   2.6561   2.6409   0.0153\n   1.2000   3.2033   3.1799   0.0234\n   1.4000   3.7667   3.7324   0.0343\n   1.6000   4.3324   4.2835   0.0489\n   1.8000   4.8834   4.8152   0.0682\n   2.0000   5.3992   5.3055   0.0937\n\n\n\n\n\n\n\n\nThree-step Adams-Bashforth\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\quad w_{2}=\\alpha_{2}, \\\\\nw_{i+1}=w_{i}+\\frac{h}{12}\\left[23 f\\left(t_{i}, w_{i}\\right)-16 f\\left(t_{i-1}, w_{i-1}\\right)+5 f\\left(t_{i-2}, w_{i-2}\\right)\\right]\n\\end{gathered}\n\\]\nBisa ditulis:\n\\[\n\\begin{gathered}\nw_{1}=\\alpha, \\\\\nw_{2}=\\alpha_{1}, \\quad w_{3}=\\alpha_{2}, \\\\\nm_1 = f\\left(t_{i}, w_{i}\\right) \\\\\nm_2 = f\\left(t_{i-1}, w_{i-1}\\right) \\\\\nm_3 = f\\left(t_{i-2}, w_{i-2}\\right) \\\\\nw_{i+1}=w_{i}+\\frac{h}{12}\\left[23 m_1-16 m_2+5 m_3\\right]\n\\end{gathered}\n\\]\n\nfunction [t, w] = adams_bashforth3(f, a, b, N, alpha)\n  % Inisiasi variabel awal\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  \n  % Hitung w(2), w(3) menggunakan metode Runge-Kutta orde 4\n  for i = 1 : 2\n      t(i + 1) = t(i) + h;\n      k1 = h * f(t(i), w(i));\n      k2 = h * f(t(i) + (h/2), w(i) + (k1/2));\n      k3 = h * f(t(i) + (h/2), w(i) + (k2/2));\n      k4 = h * f(t(i + 1), w(i) + k3);\n      w(i+1) = w(i) + (k1 + 2*k2 + 2*k3 + k4) / 6;\n  endfor\n  \n  % Algoritma utama Adams-Bashforth orde 3\n  for i = 3 : N\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i-1), w(i-1));\n    m3 = f(t(i-2), w(i-2));\n    w(i+1) = w(i) + (h/12) * (23*m1 - 16*m2 + 5*m3);\n  endfor\nendfunction\n\n\n\nFour-step Adams-Bashforth\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\quad w_{2}=\\alpha_{2}, \\quad w_{3}=\\alpha_{3} \\\\\nw_{i+1}=w_{i}+\\frac{h}{24}\\left[55 f\\left(t_{i}, w_{i}\\right)-59 f\\left(t_{i-1}, w_{i-1}\\right)+37 f\\left(t_{i-2}, w_{i-2}\\right)-9 f\\left(t_{i-3}, w_{i-3}\\right)\\right]\n\\end{gathered}\n\\]\nBisa ditulis:\n\\[\n\\begin{gathered}\nw_{1}=\\alpha, \\\\\nw_{2}=\\alpha_{1}, \\quad w_{3}=\\alpha_{2}, \\quad w_{4}=\\alpha_{3} \\\\\nm_1 = f\\left(t_{i}, w_{i}\\right) \\\\\nm_2 = f\\left(t_{i-1}, w_{i-1}\\right) \\\\\nm_3 = f\\left(t_{i-2}, w_{i-2}\\right) \\\\\nm_4 = f\\left(t_{i-3}, w_{i-3}\\right) \\\\\nw_{i+1}=w_{i}+\\frac{h}{24}\\left[55 m_1-59 m_2+37 m_3-9 m_4\\right]\n\\end{gathered}\n\\]\n\nfunction [t, w] = adams_bashforth4(f, a, b, N, alpha)\n  % Inisiasi variabel awal\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  \n  % Hitung w(2), w(3), w(4) menggunakan metode Runge-Kutta orde 4\n  for i = 1 : 3\n      t(i + 1) = t(i) + h;\n      k1 = h * f(t(i), w(i));\n      k2 = h * f(t(i) + (h/2), w(i) + (k1/2));\n      k3 = h * f(t(i) + (h/2), w(i) + (k2/2));\n      k4 = h * f(t(i + 1), w(i) + k3);\n      w(i+1) = w(i) + (k1 + 2*k2 + 2*k3 + k4) / 6;\n  endfor\n  \n  % Algoritma utama Adams-Bashforth orde 4\n  for i = 4 : N\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i-1), w(i-1));\n    m3 = f(t(i-2), w(i-2));\n    m4 = f(t(i-3), w(i-3));\n    w(i+1) = w(i) + (h/24) * (55*m1 - 59*m2 + 37*m3 - 9*m4);\n  endfor\nendfunction\n\n\n\nFive-step Adams-Bashforth\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\quad w_{2}=\\alpha_{2}, \\quad w_{3}=\\alpha_{3}, \\quad w_{4}=\\alpha_{4}, \\\\\nw_{i+1}=w_{i}+\\frac{h}{720}\\left[1901 f\\left(t_{i}, w_{i}\\right)-2774 f\\left(t_{i-1}, w_{i-1}\\right)+2616 f\\left(t_{i-2}, w_{i-2}\\right)\\right. \\\\\n\\left.-1274 f\\left(t_{i-3}, w_{i-3}\\right)+251 f\\left(t_{i-4}, w_{i-4}\\right)\\right]\n\\end{gathered}\n\\]\nBisa ditulis:\n\\[\n\\begin{gathered}\nw_{1}=\\alpha, \\\\\nw_{2}=\\alpha_{1}, \\quad w_{3}=\\alpha_{2}, \\quad w_{4}=\\alpha_{3}, \\quad w_{5}=\\alpha_{4}, \\\\\nm_1 = f\\left(t_{i}, w_{i}\\right) \\\\\nm_2 = f\\left(t_{i-1}, w_{i-1}\\right) \\\\\nm_3 = f\\left(t_{i-2}, w_{i-2}\\right) \\\\\nm_4 = f\\left(t_{i-3}, w_{i-3}\\right) \\\\\nm_5 = f\\left(t_{i-4}, w_{i-4}\\right) \\\\\nw_{i+1}=w_{i}+\\frac{h}{720}\\left[1901 m_1-2774 m_2+2616 m_3\\right. \\\\\n\\left.-1274 m_4+251 m_5\\right]\n\\end{gathered}\n\\]\n\nfunction [t, w] = adams_bashforth4(f, a, b, N, alpha)\n  % Inisiasi variabel awal\n  h = (b - a) / N;\n  t = zeros(N + 1, 1);\n  w = zeros(N + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  \n  % Hitung w(2), ..., w(5) menggunakan metode Runge-Kutta orde 4\n  for i = 1 : 4\n      t(i + 1) = t(i) + h;\n      k1 = h * f(t(i), w(i));\n      k2 = h * f(t(i) + (h/2), w(i) + (k1/2));\n      k3 = h * f(t(i) + (h/2), w(i) + (k2/2));\n      k4 = h * f(t(i + 1), w(i) + k3);\n      w(i+1) = w(i) + (k1 + 2*k2 + 2*k3 + k4) / 6;\n  endfor\n  \n  % Algoritma utama Adams-Bashforth orde 5\n  for i = 5 : N\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i-1), w(i-1));\n    m3 = f(t(i-2), w(i-2));\n    m4 = f(t(i-3), w(i-3));\n    m5 = f(t(i-4), w(i-4));\n    w(i+1) = w(i) + (h/720) * (1901*m1 - 2774*m2 + 2616*m3 -1274*m4 +251*m5);\n  endfor\nendfunction"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html",
    "title": "Modul 3 Kalkulin: LaTeX Beamer",
    "section": "",
    "text": "Kembali ke Kalkulin"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html#outline",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html#outline",
    "title": "Modul 3 Kalkulin: LaTeX Beamer",
    "section": "Outline",
    "text": "Outline\n\n\n\n\n\n\n\nClick to open this exercise in Overleaf\nClick to open the model document\nhttp://www.cgd.ucar.edu/cms/agu/scientific_talk.html\n\n\nClick to open the example document in Overleaf\n\n\n\n\nhttp://www.math.umbc.edu/~rouben/beamer/quickstart-Z-H-25.html\n\n\n\n\nhttp://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html\n\n\n\nClick to open this exercise in Overleaf\nClick to download image\nClick to open the model document\nhttp://norvig.com/Gettysburg\n\n\n\n\n\n\n\n\n\nTeXample\n\nhttp://xkcd.com/1022\n\n\n\nhttp://www.ctan.org/pkg/spreadtab"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html#latex-recap",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html#latex-recap",
    "title": "Modul 3 Kalkulin: LaTeX Beamer",
    "section": "LaTeX Recap",
    "text": "LaTeX Recap\n\n\n\n\n\n\nClick to open this exercise in Overleaf\nClick to open the model document\nhttp://www.cgd.ucar.edu/cms/agu/scientific_talk.html"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html#presentations-with-beamer",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html#presentations-with-beamer",
    "title": "Modul 3 Kalkulin: LaTeX Beamer",
    "section": "Presentations with beamer",
    "text": "Presentations with beamer\n\n\nClick to open the example document in Overleaf\n\n\n\n\nhttp://www.math.umbc.edu/~rouben/beamer/quickstart-Z-H-25.html\n\n\n\n\nhttp://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html\n\n\n\nClick to open this exercise in Overleaf\nClick to download image\nClick to open the model document\nhttp://norvig.com/Gettysburg"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html#drawings-with-tikz",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html#drawings-with-tikz",
    "title": "Modul 3 Kalkulin: LaTeX Beamer",
    "section": "Drawings with TikZ",
    "text": "Drawings with TikZ\n\n\n\n\n\n\n\n\n\nTeXample\n\nhttp://xkcd.com/1022"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html#notes-with-todonotes",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html#notes-with-todonotes",
    "title": "Modul 3 Kalkulin: LaTeX Beamer",
    "section": "Notes with todonotes",
    "text": "Notes with todonotes"
  },
  {
    "objectID": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html#spreadsheets-with-spreadtab",
    "href": "semuahalaman/modulprak/2024/genap/kalkulin/modul3.html#spreadsheets-with-spreadtab",
    "title": "Modul 3 Kalkulin: LaTeX Beamer",
    "section": "Spreadsheets with spreadtab",
    "text": "Spreadsheets with spreadtab\n\nhttp://www.ctan.org/pkg/spreadtab"
  }
]