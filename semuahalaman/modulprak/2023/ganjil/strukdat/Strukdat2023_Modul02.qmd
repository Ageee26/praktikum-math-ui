---
title: "Modul 2 Struktur Data: *Array*, fungsi, *struct*, dan proses kompilasi"
---

Kembali ke [Struktur Data](strukdat2023.qmd)

# Outline

* Pengenalan *array* (larik), dan *string* sebagai *array* dari *char*
    + *Array*
    + *char* (huruf), `putchar`, dan `getchar`
    + *string*, `puts`, `fgets`, `strlen`, dan `strcmp`/`strncmp`
* Tentang *function* (fungsi)
    + Menampilkan semua elemen pada *array*
* `struct` ("struktur" atau struktur data)
* Proses kompilasi, *preprocessor directive*, *header file*, dan *build system*
    + Mendalami proses kompilasi program
    + *Preprocessor directive* dan *header file* (.h)
    + *Build system* `make`: kompilasi otomatis dengan Makefile
    + Referensi tambahan: CMake
    + FAQ seputar pembuatan aplikasi
* *Header file* untuk Modul 2 Praktikum: `prakmodul2.h` dan `prakmodul2.c`

# Pengenalan *array* (larik), dan *string* sebagai *array* dari *char*

## *Array*

blabla

(jangan lupa ukuran array dengan sizeof)

## *char* (huruf), `putchar`, dan `getchar`

blabla

## *string*, `puts`, `fgets`, `strlen`, dan `strcmp`/`strncmp`

blabla

# Tentang *function* (fungsi)

blabla

## Menampilkan semua elemen pada *array*

Untuk menampilkan semua elemen yang ada di dalam suatu *array*, kita perlu melakukan iterasi pada tiap elemen di *array*, lalu menggunakan `printf` pada tiap iterasi. Agar mengetahui batasan *for loop*, kita perlu mengetahui panjang *array*. Kita bisa membuat fungsi yang mem-*print* satu per satu elemen suatu *array* sampai panjang *array* tersebut.

```{.c code-line-numbers="true"}
void array_int_print(int arr[], int arr_length) {
    for (int i = 0; i < arr_length; i++) {
        printf("%d ", arr[i]);
    }
}
```

# `struct` ("struktur" atau struktur data)

blabla

# Proses kompilasi, *preprocessor directive*, *header file*, dan *build system*

## Mendalami proses kompilasi program

(diagram, empat langkah, caranya satu-satu di gcc)

blabla

## *Preprocessor directive* dan *header file* (.h)

blabla

## *Build system* `make`: kompilasi otomatis dengan Makefile

Sumber referensi yang digunakan untuk materi pada bagian ini:

*   How to Create a Simple Makefile - Introduction to Makefiles

    https://www.youtube.com/watch?v=_r7i5X0rXJk

*   Makefiles: 95% of what you need to know

    https://www.youtube.com/watch?v=DtGrdB8wQ_8

    https://github.com/gwu-cs-os/evening_os_hour/tree/master/f19/10.2-makefiles

Contoh Makefile 1 (tanpa variabel):

```makefile
# this is a comment

## general format:

# target: its dependencies
# 	command to build target from its dependencies

## ^ tab character

# if you only type "make",
# it's going to execute the top most command,
# which, in here, happens to be "all"
all: helloworld

helloworld: helloworld.o dothing.o
	gcc helloworld.o dothing.o -o helloworld

helloworld.o: helloworld.c
	gcc -c helloworld.c

dothing.o: dothing.c
	gcc -c dothing.c

clean:
	rm helloworld *.o

cleano:
	rm *.o
```

Contoh Makefile 2 (dengan variabel):

```makefile
# this is a comment

# === VARIABLES ===

## general format:

# VARNAME=word1 word2 word3
# no space before NOR after the equal sign!
# make sure NOT A SINGLE LINE ends with a trailing space!!
# the variables will later be accessed with $(VARNAME)

##

COMPILER=gcc

CFILES=helloworld.c dothing.c
OBJFILES=helloworld.o dothing.o
BINARYNAME=helloworld

# === COMMANDS ===

## general format:

# target: dependency
# 	command

## ^ tab character

# $@ refers to the target
# $^ refers to the dependency

# if you only type "make",
# it's going to execute the top most command,
# which, in here, happens to be "all"
all: $(BINARYNAME)

$(BINARYNAME): $(OBJFILES)
	$(COMPILER) $(OBJFILES) -o $(BINARYNAME)

%.o: %.c
	$(COMPILER) -c $^ -o $@

clean:
	rm $(BINARYNAME) $(OBJFILES)

cleano:
	rm $(OBJFILES)
```

blabla

## Referensi tambahan: CMake

Kita telah belajar cara membuat Makefile secara manual dan menggunakannya. Sejauh ini, Makefile yang kita buat melibatkan beberapa variabel yang perlu kita *setting* secara manual. Untuk program dan proyek skala kecil seperti di mata kuliah Struktur Data, itu tidak masalah.

Sebenarnya, sudah ada *software* untuk membuat Makefile secara otomatis, yaitu CMake. Bahkan, CMake bisa menghasilkan Makefile untuk berbagai sistem operasi yang memiliki berbagai macam ketergantungan yang berbeda-beda. Namun, cara penggunaannya bisa agak sulit, sehingga tidak kami ajarkan di praktikum untuk menghemat waktu. Anda bisa membaca lebih lanjut tentang CMake di internet, seperti di link berikut:

https://earthly.dev/blog/cmake-vs-make-diff/

## FAQ seputar pembuatan aplikasi: CLI, GUI, dan sebagainya

Sampai sini, kita sudah bisa mengkompilasi program C ke dalam bentuk *executable*, hingga menggabungkan beberapa *file* yang berbeda dengan bantuan *header file*. Bahkan, kita sudah mempelajari penggunaan *build system* seperti `make` agar proses kompilasi bisa dilakukan secara otomatis.

Sejauh ini, semua program yang kita buat melibatkan *command line* (juga disebut *command prompt* atau *terminal*), karena perlu menampilkan *output* dan menerima input. Bisa dikatakan, tampilan seperti itu adalah semacam "perantara", atau istilahnya "antarmuka" (*interface*), agar kita bisa "berkomunikasi" dengan program atau aplikasi tersebut. Antarmuka seperti itu disebut ***command line interface* (CLI)**.

::: {.callout-note}

## Apakah ada program tanpa antarmuka?

Iya, ada, tidak mustahil. Mungkin terdengar aneh, program yang tidak memberikan *output* di *command line* maupun menerima input, dan terdengar tidak berguna. Biasanya, program seperti itu melakukan beberapa hal (seperti urusan membuat, mengubah, maupun menghapus *file*, yang dibahas di [Modul opsional 4a](./Strukdat2023_Modul04a.qmd)) yang sudah ditentukan dan sudah dibuat kodenya sehingga tidak perlu menerima informasi tambahan apapun (sehingga tidak memerlukan input), dan tidak perlu memberikan informasi apapun (sehingga tidak memberikan *output*).

Namun, program seperti itu jarang ada, dan biasanya dibuat untuk kepentingan pribadi saja.

:::

Mungkin dalam kehidupan sehari-hari, kalian lebih terbiasa dengan aplikasi yang memiliki semacam tampilan dengan tombol-tombol yang bisa ditekan dan sebagainya. Tampilan atau antarmuka seperti itu disebut ***graphical user interface* (GUI)**.

Beberapa aplikasi memiliki CLI, seperti aplikasi atau program yang kita buat selama praktikum. Beberapa aplikasi memiliki GUI, seperti aplikasi yang biasa kalian gunakan di kehidupan sehari-hari. Beberapa aplikasi memiliki CLI dan GUI (biasanya kita bisa memilih di antara keduanya), dan ada juga aplikasi yang tidak memiliki keduanya (sudah dibahas di atas).

Berikut beberapa pertanyaan umum seputar pembuatan aplikasi serta jawabannya.

1. Saya ingin program saya memiliki GUI, bagaimana caranya?

blabla

# *Header file* untuk Modul 2 Praktikum: `prakmodul2.h` dan `prakmodul2.c`

Di Modul 2 Praktikum Struktur Data ini, kita telah mendefinisikan fungsi, seperti `array_int_print`. Tentunya, fungsi ini bisa saja diperlukan untuk praktikum ke depannya ataupun untuk proyek lainnya. Oleh karena itu, berikut ini tercantum kode  *header file* yang memiliki fungsi penting seperti `array_int_print`, yang bisa kalian libatkan ke dalam apapun proyek yang kalian buat dengan bahasa pemrograman C, melalui Makefile, seperti yang sudah kita praktekkan kali ini. Untuk modul-modul praktikum ke depannya, kode untuk *header file* juga akan tercantum di bagian paling bawah seperti di sini.

::: {.panel-tabset}

## `prakmodul2.h`

```{.c code-line-numbers="true"}
#ifndef PRAKMODUL2_H
#define PRAKMODUL2_H

void array_int_print(int arr[], int arr_length);

#endif
```

## `prakmodul2.c`

```{.c code-line-numbers="true"}
#include <stdio.h>
#include "prakmodul2.h"

void array_int_print(int arr[], int arr_length) {
    for (int i = 0; i < arr_length; i++) {
        printf("%d ", arr[i]);
    }
}
```

:::